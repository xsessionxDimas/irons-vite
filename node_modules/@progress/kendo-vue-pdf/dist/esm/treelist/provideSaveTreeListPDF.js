var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
// @ts-ignore
import * as Vue from 'vue';
import { canUseDOM } from '@progress/kendo-vue-common';
var allVue = Vue;
var h = allVue.h;
var createApp = allVue.createApp;
import { exportElement } from './export-element.js';
/**
 * @hidden
 */
export function provideSaveTreeListPDF(savePDF) {
  return function (treeList, pdfExportOptions, callback, data, columns) {
    if (pdfExportOptions === void 0) {
      pdfExportOptions = {};
    }
    return saveTreeListPDF(savePDF, treeList, pdfExportOptions, callback, data, columns);
  };
}
function saveTreeListPDF(savePDF, treeList, pdfExportOptions, callback, data, v3) {
  if (pdfExportOptions === void 0) {
    pdfExportOptions = {};
  }
  renderTreeList();
  var treeListOuterWrapper;
  var treeListInnerWrapper;
  var finalContainer;
  var treeListInstance;
  function renderTreeList() {
    if (!canUseDOM) {
      return;
    }
    treeListOuterWrapper = document.createElement('div');
    treeListOuterWrapper.setAttribute('style', 'position:absolute; left: -5000px; top: 0px;');
    treeListInnerWrapper = document.createElement('div');
    treeListOuterWrapper.appendChild(treeListInnerWrapper);
    document.body.appendChild(treeListOuterWrapper);
    var customDataProps = data && {
      dataItems: data,
      total: data.length,
      pageSize: data.length,
      skip: 0
    };
    if (v3) {
      var treeListForPdf = {
        render: function render() {
          return h(treeList.type, __assign(__assign({}, treeList.props), customDataProps), treeList.children);
        },
        store: treeList.$store,
        mounted: function mounted() {
          // @ts-ignore
          if (this.$el.style) {
            // @ts-ignore
            this.$el.style.width = '1000px';
          }
          onTreeListRendered.call(this);
        }
      };
      treeListInstance = createApp(treeListForPdf);
      treeListInstance.mount(treeListInnerWrapper);
    } else {
      var treeListConstructor = Object.getPrototypeOf(treeList).constructor;
      treeListInstance = new treeListConstructor({
        propsData: Object.assign({}, treeList.$props, customDataProps),
        store: treeList.$store,
        mounted: function mounted() {
          if (treeListInstance.$el.style) {
            treeListInstance.$el.style.width = '1000px';
          }
          onTreeListRendered.call(treeListInstance);
        }
      });
      treeListInstance.$slots = treeList.$slots;
      treeListInstance.$scopedSlots = treeList.$scopedSlots;
      treeListInstance.$mount(treeListInnerWrapper);
    }
  }
  function onTreeListRendered() {
    savePDF(prepareFinalElementForExport.call(this), pdfExportOptions, cleanUpAndInvokeCallback);
  }
  function cleanUpAndInvokeCallback() {
    if (treeListInstance.unmount) {
      treeListInstance.unmount();
    } else {
      treeListInstance.$destroy();
    }
    document.body.removeChild(treeListOuterWrapper);
    document.body.removeChild(finalContainer);
    treeListOuterWrapper = finalContainer = undefined;
    if (callback) {
      callback();
    }
  }
  function prepareFinalElementForExport() {
    /* Ultimatelly, there is no need for double DOM-copying of the treeList.
    The one in this method is a copied Angular implementation
    that has been plugged almost seemlessly. */
    finalContainer = document.createElement('div');
    finalContainer.className = 'k-treelist-pdf-export-element';
    var result = exportElement(this.$el);
    finalContainer.appendChild(result);
    document.body.appendChild(finalContainer);
    return result;
  }
}