/*
 * Application Insights JavaScript SDK - Click Analytics, 3.3.1
 * Copyright (c) Microsoft and contributors. All rights reserved.
 */
/**
* @copyright Microsoft 2020
*/
import dynamicProto from "@microsoft/dynamicproto-js";
import { _throwInternal, getDocument, hasDocument, isNullOrUndefined, objExtend } from "@microsoft/applicationinsights-core-js";
import { strSubstring } from "@nevware21/ts-utils";
import { _DYN_ATTRIBUTES, _DYN_CAPTURE_ALL_META_DAT2, _DYN_CONTENT, _DYN_CONTENT_NAME, _DYN_CUSTOM_DATA_PREFIX, _DYN_DATA_TAGS, _DYN_GET_ATTRIBUTE, _DYN_GET_ELEMENT_CONTENT, _DYN_INDEX_OF, _DYN_LENGTH, _DYN_META_DATA_PREFIX, _DYN_NAME, _DYN_PARENT_DATA_TAG, _DYN_PARENT_ELEMENT, _DYN_PARENT_NODE, _DYN_TAG_NAME, _DYN_USE_DEFAULT_CONTENT_1, _DYN__CONFIG, _DYN__TRACE_LOGGER } from "../__DynamicConstants";
import { isValueAssigned, removeInvalidElements, walkUpDomChainWithElementValidation } from "../common/Utils";
var MAX_CONTENTNAME_LENGTH = 200;
var DomContentHandler = /** @class */ (function () {
    /**
     * @param config - ClickAnalytics configuration object
     * @param traceLogger - Trace logger to log to console.
     */
    function DomContentHandler(_config, _traceLogger) {
        this._config = _config;
        this._traceLogger = _traceLogger;
        dynamicProto(DomContentHandler, this, function (_self) {
            _self.getMetadata = function () {
                var dataTags = (_self[_DYN__CONFIG /* @min:%2e_config */] || {})[_DYN_DATA_TAGS /* @min:%2edataTags */];
                var metaTags = {};
                if (hasDocument()) {
                    metaTags = isValueAssigned(dataTags.metaDataPrefix) ? _getMetaDataFromDOM(dataTags[_DYN_CAPTURE_ALL_META_DAT2 /* @min:%2ecaptureAllMetaDataContent */], dataTags[_DYN_META_DATA_PREFIX /* @min:%2emetaDataPrefix */], false) :
                        _getMetaDataFromDOM(dataTags[_DYN_CAPTURE_ALL_META_DAT2 /* @min:%2ecaptureAllMetaDataContent */], "", false);
                }
                return metaTags;
            };
            _self[_DYN_GET_ELEMENT_CONTENT /* @min:%2egetElementContent */] = function (element) {
                if (!element) {
                    return {};
                }
                var dataTags = (_self[_DYN__CONFIG /* @min:%2e_config */] || {})[_DYN_DATA_TAGS /* @min:%2edataTags */];
                var elementContent = {};
                var biBlobValue;
                var parentDataTagPrefix;
                var dataTagPrefix = dataTags[_DYN_CUSTOM_DATA_PREFIX /* @min:%2ecustomDataPrefix */];
                var aiBlobAttributeTag = dataTagPrefix + dataTags.aiBlobAttributeTag;
                if (isValueAssigned(dataTags[_DYN_PARENT_DATA_TAG /* @min:%2eparentDataTag */])) {
                    parentDataTagPrefix = dataTagPrefix + dataTags[_DYN_PARENT_DATA_TAG /* @min:%2eparentDataTag */];
                }
                if (!_isTracked(element, dataTagPrefix, aiBlobAttributeTag)) {
                    // capture blob from element or hierarchy
                    biBlobValue = element[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](aiBlobAttributeTag);
                    if (biBlobValue) {
                        try {
                            elementContent = JSON.parse(biBlobValue);
                        }
                        catch (e) {
                            _throwInternal(_self[_DYN__TRACE_LOGGER /* @min:%2e_traceLogger */], 1 /* eLoggingSeverity.CRITICAL */, 101 /* _eInternalMessageId.CannotParseAiBlobValue */, "Can not parse " + biBlobValue);
                        }
                    }
                    else {
                        // traverse up the DOM to find the closest parent with data-* tag defined
                        //contentElement = walkUpDomChainWithElementValidation(element, _self._isTracked, dataTagPrefix);
                        elementContent = objExtend(elementContent, _populateElementContent(element, dataTagPrefix, parentDataTagPrefix, aiBlobAttributeTag));
                    }
                }
                else {
                    elementContent = objExtend(elementContent, _populateElementContentwithDataTag(element, dataTagPrefix, parentDataTagPrefix, aiBlobAttributeTag));
                }
                removeInvalidElements(elementContent);
                if (parentDataTagPrefix) {
                    elementContent = objExtend(elementContent, _getParentDetails(element, elementContent, dataTagPrefix, aiBlobAttributeTag));
                }
                return elementContent;
            };
            /**
             * Capture current level Element content
             */
            function _captureElementContentWithDataTag(contentElement, elementContent, dataTagPrefix) {
                for (var i = 0, attrib; i < contentElement.attributes[_DYN_LENGTH /* @min:%2elength */]; i++) {
                    attrib = contentElement[_DYN_ATTRIBUTES /* @min:%2eattributes */][i];
                    if (attrib.name[_DYN_INDEX_OF /* @min:%2eindexOf */](dataTagPrefix) !== 0) {
                        continue;
                    }
                    var attribName = attrib[_DYN_NAME /* @min:%2ename */].replace(dataTagPrefix, "");
                    elementContent[attribName] = attrib.value;
                }
            }
            /**
             * Walk Up the DOM to capture Element content
             */
            function _walkUpDomChainCaptureData(el, elementContent, dataTagPrefix, parentDataTagPrefix, aiBlobAttributeTag) {
                var element = el;
                var parentDataTagFound = false;
                var elementLevelFlag = false; // Use this flag to capture 'id' only at the incoming html element level.
                while (!isNullOrUndefined(element) && !isNullOrUndefined(element[_DYN_ATTRIBUTES /* @min:%2eattributes */])) {
                    var attributes = element[_DYN_ATTRIBUTES /* @min:%2eattributes */];
                    for (var i = 0; i < attributes[_DYN_LENGTH /* @min:%2elength */]; i++) {
                        var attrib = attributes[i];
                        if (attrib.name[_DYN_INDEX_OF /* @min:%2eindexOf */](dataTagPrefix) !== 0) {
                            continue;
                        }
                        if (attrib.name[_DYN_INDEX_OF /* @min:%2eindexOf */](parentDataTagPrefix) === 0) {
                            parentDataTagFound = true;
                        }
                        // Todo handle blob data
                        if (attrib.name[_DYN_INDEX_OF /* @min:%2eindexOf */](aiBlobAttributeTag) === 0) {
                            continue;
                        }
                        var attribName = attrib[_DYN_NAME /* @min:%2ename */].replace(dataTagPrefix, "");
                        if (elementLevelFlag && attribName === "id") {
                            continue; // skip capturing id if not at the first level.
                        }
                        if (!isValueAssigned(elementContent[attribName])) {
                            elementContent[attribName] = attrib.value;
                        }
                    }
                    // break after current level;
                    if (parentDataTagFound) {
                        break;
                    }
                    elementLevelFlag = true; // after the initial level set this flag to true.
                    element = element[_DYN_PARENT_NODE /* @min:%2eparentNode */];
                }
            }
            /**
             * Capture Element content along with Data Tag attributes and values
             */
            function _populateElementContent(element, dataTagPrefix, parentDataTagPrefix, aiBlobAttributeTag) {
                var elementContent = {};
                if (!element) {
                    return elementContent;
                }
                var htmlContent = _getHtmlIdAndContentName(element);
                elementContent = {
                    id: htmlContent.id || "",
                    contentName: htmlContent[_DYN_CONTENT_NAME /* @min:%2econtentName */] || ""
                };
                if (isValueAssigned(parentDataTagPrefix)) {
                    _walkUpDomChainCaptureData(element, elementContent, dataTagPrefix, parentDataTagPrefix, aiBlobAttributeTag);
                }
                // Validate to ensure the minimum required field 'id' or 'contentName' is present.
                // The content schema defines id, aN and sN as required fields.  However,
                // requiring these fields would result in majority of adopter's content from being collected.
                // Just throw a warning and continue collection.
                if (!elementContent.id && !elementContent[_DYN_CONTENT_NAME /* @min:%2econtentName */]) {
                    _throwInternal(_traceLogger, 2 /* eLoggingSeverity.WARNING */, 102 /* _eInternalMessageId.InvalidContentBlob */, "Invalid content blob.  Missing required attributes (id, contentName. " +
                        " Content information will still be collected!");
                }
                return elementContent;
            }
            /**
             * Capture Element content along with Data Tag attributes and values
             */
            function _populateElementContentwithDataTag(element, dataTagPrefix, parentDataTagPrefix, aiBlobAttributeTag) {
                var dataTags = (_self[_DYN__CONFIG /* @min:%2e_config */] || {})[_DYN_DATA_TAGS /* @min:%2edataTags */];
                var elementContent = {};
                if (!element) {
                    return elementContent;
                }
                var htmlContent = _getHtmlIdAndContentName(element);
                if (isValueAssigned(parentDataTagPrefix)) {
                    _walkUpDomChainCaptureData(element, elementContent, dataTagPrefix, parentDataTagPrefix, aiBlobAttributeTag);
                }
                else {
                    _captureElementContentWithDataTag(element, elementContent, dataTagPrefix);
                }
                if (dataTags[_DYN_USE_DEFAULT_CONTENT_1 /* @min:%2euseDefaultContentNameOrId */]) {
                    if (!isValueAssigned(elementContent.id)) {
                        elementContent.id = htmlContent.id || "";
                    }
                    elementContent[_DYN_CONTENT_NAME /* @min:%2econtentName */] = htmlContent[_DYN_CONTENT_NAME /* @min:%2econtentName */] || "";
                }
                // Validate to ensure the minimum required field 'id' or 'contentName' is present.
                // The content schema defines id, aN and sN as required fields.  However,
                // requiring these fields would result in majority of adopter's content from being collected.
                // Just throw a warning and continue collection.
                if (!elementContent.id && !elementContent[_DYN_CONTENT_NAME /* @min:%2econtentName */]) {
                    _throwInternal(_traceLogger, 2 /* eLoggingSeverity.WARNING */, 102 /* _eInternalMessageId.InvalidContentBlob */, "Invalid content blob.  Missing required attributes (id, contentName. " +
                        " Content information will still be collected!");
                }
                return elementContent;
            }
            /**
             * Retrieve a specified metadata tag value from the DOM.
             * @param captureAllMetaDataContent - Flag to capture all metadata content
             * @param prefix - Prefix to search the metatags with.
             * @param removePrefix - Specifies if the prefix must be excluded from key names in the returned collection.
             * @returns Metadata collection/property bag
             */
            function _getMetaDataFromDOM(captureAllMetaDataContent, prefix, removePrefix) {
                var metaElements;
                var metaData = {};
                if (hasDocument()) {
                    metaElements = getDocument().querySelectorAll("meta");
                    for (var i = 0; i < metaElements[_DYN_LENGTH /* @min:%2elength */]; i++) {
                        var meta = metaElements[i];
                        if (meta[_DYN_NAME /* @min:%2ename */]) {
                            if (captureAllMetaDataContent || meta.name[_DYN_INDEX_OF /* @min:%2eindexOf */](prefix) === 0) {
                                var name_1 = removePrefix ? meta[_DYN_NAME /* @min:%2ename */].replace(prefix, "") : meta[_DYN_NAME /* @min:%2ename */];
                                metaData[name_1] = meta[_DYN_CONTENT /* @min:%2econtent */];
                            }
                        }
                    }
                }
                return metaData;
            }
            /**
             * Gets the default content name.
             * @param element - An html element
             * @param useDefaultContentNameOrId - Flag indicating if an element is market PII.
             * @returns Content name
             */
            function _getDefaultContentName(element, useDefaultContentName) {
                if (useDefaultContentName === false || !element[_DYN_TAG_NAME /* @min:%2etagName */]) {
                    return "";
                }
                var doc = getDocument() || {};
                var contentName;
                switch (element[_DYN_TAG_NAME /* @min:%2etagName */]) {
                    case "A":
                        contentName = doc.all ? element.innerText || element.innerHTML : element.text || element.innerHTML;
                        break;
                    case "IMG":
                    case "AREA":
                        contentName = element.alt;
                        break;
                    default:
                        contentName = element.value || element[_DYN_NAME /* @min:%2ename */] || element.alt || element.innerText || element.id;
                }
                return strSubstring(contentName, 0, MAX_CONTENTNAME_LENGTH);
            }
            /**
             * Check if the user wants to track the element, which means if the element has any tags with data-* or customDataPrefix
             * @param element - An html element
             * @returns true if any data-* exist, otherwise return false
             */
            function _isTracked(element, dataTag, aiBlobAttributeTag) {
                var attrs = element[_DYN_ATTRIBUTES /* @min:%2eattributes */];
                var dataTagFound = false;
                for (var i = 0; i < attrs[_DYN_LENGTH /* @min:%2elength */]; i++) {
                    var attributeName = attrs[i][_DYN_NAME /* @min:%2ename */];
                    if (attributeName === aiBlobAttributeTag) {
                        // ignore if the attribute name is equal to aiBlobAttributeTag
                        return false;
                    }
                    else if (attributeName[_DYN_INDEX_OF /* @min:%2eindexOf */](dataTag) === 0) {
                        dataTagFound = true;
                    }
                }
                return dataTagFound;
            }
            function _getHtmlIdAndContentName(element) {
                var _a;
                var dataTags = (_self[_DYN__CONFIG /* @min:%2e_config */] || {})[_DYN_DATA_TAGS /* @min:%2edataTags */];
                var callback = (_self[_DYN__CONFIG /* @min:%2e_config */] || {}).callback;
                var htmlContent = {};
                if (!element) {
                    return htmlContent;
                }
                if (dataTags[_DYN_USE_DEFAULT_CONTENT_1 /* @min:%2euseDefaultContentNameOrId */]) {
                    var customizedContentName = callback[_DYN_CONTENT_NAME /* @min:%2econtentName */] ? callback[_DYN_CONTENT_NAME /* @min:%2econtentName */](element, dataTags[_DYN_USE_DEFAULT_CONTENT_1 /* @min:%2euseDefaultContentNameOrId */]) : "";
                    var defaultContentName = _getDefaultContentName(element, dataTags[_DYN_USE_DEFAULT_CONTENT_1 /* @min:%2euseDefaultContentNameOrId */]);
                    htmlContent = (_a = {
                            id: element.id
                        },
                        _a[_DYN_CONTENT_NAME /* @min:contentName */] = customizedContentName || defaultContentName || element[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */]("alt"),
                        _a);
                }
                return htmlContent;
            }
            /**
            * Computes the parentId of a given element.
            * @param element - An html element
            * @returns An object containing the closest parentId , can be empty if nothing was found
            */
            function _getParentDetails(element, elementContent, dataTagPrefix, aiBlobAttributeTag) {
                var parentId = elementContent["parentid"];
                var parentName = elementContent["parentname"];
                var parentInfo = {};
                if (parentId || parentName || !element) {
                    return parentInfo;
                }
                return _populateParentInfo(element, dataTagPrefix, aiBlobAttributeTag);
            }
            /**
            * Check if parent info already set up, if so take and put into content, if not walk up the DOM to find correct info
            * @param element - An html element that the user wants to track
            * @returns An object containing the parent info, can be empty if nothing was found
            */
            function _populateParentInfo(element, dataTagPrefix, aiBlobAttributeTag) {
                var parentInfo = {};
                var parentId;
                // if the user does not set up parent info, walk to the DOM, find the closest parent element (with tags) and populate the info
                var closestParentElement = walkUpDomChainWithElementValidation(element[_DYN_PARENT_ELEMENT /* @min:%2eparentElement */], _isTracked, dataTagPrefix);
                if (closestParentElement) {
                    var dataAttr = closestParentElement[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](aiBlobAttributeTag) || element[aiBlobAttributeTag];
                    if (dataAttr) {
                        try {
                            var telemetryObject = JSON.parse(dataAttr);
                        }
                        catch (e) {
                            _throwInternal(_traceLogger, 1 /* eLoggingSeverity.CRITICAL */, 101 /* _eInternalMessageId.CannotParseAiBlobValue */, "Can not parse " + dataAttr);
                        }
                        if (telemetryObject) {
                            parentId = telemetryObject.id;
                        }
                    }
                    else {
                        parentId = closestParentElement[_DYN_GET_ATTRIBUTE /* @min:%2egetAttribute */](dataTagPrefix + "id");
                    }
                }
                if (parentId) {
                    parentInfo["parentid"] = parentId;
                }
                else {
                    var htmlContent = _getHtmlIdAndContentName(element[_DYN_PARENT_ELEMENT /* @min:%2eparentElement */]);
                    parentInfo["parentid"] = htmlContent.id;
                    parentInfo["parentname"] = htmlContent[_DYN_CONTENT_NAME /* @min:%2econtentName */];
                }
                return parentInfo;
            }
        });
    }
// Removed Stub for DomContentHandler.prototype.getMetadata.
// Removed Stub for DomContentHandler.prototype.getElementContent.
    // This is a workaround for an IE bug when using dynamicProto() with classes that don't have any
    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.
    DomContentHandler.__ieDyn=1;

    return DomContentHandler;
}());
export { DomContentHandler };
//# sourceMappingURL=DomContentHandler.js.map