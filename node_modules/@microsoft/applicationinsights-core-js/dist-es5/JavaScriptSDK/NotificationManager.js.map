{"version":3,"file":"NotificationManager.js.map","sources":["NotificationManager.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT License.\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { createAllPromise, createPromise, doAwaitResponse } from \"@nevware21/ts-async\";\r\nimport { arrForEach, arrIndexOf, objDefine, safe, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { createDynamicConfig } from \"../Config/DynamicConfig\";\r\nimport { _DYN_ADD_NOTIFICATION_LIS1, _DYN_CANCEL, _DYN_DATA, _DYN_IS_ASYNC, _DYN_IS_CHILD_EVT, _DYN_LENGTH, _DYN_PUSH, _DYN_REMOVE_NOTIFICATION_0, _DYN_SPLICE, _DYN_UNLOAD, _DYN_WATCH } from \"../__DynamicConstants\";\r\nimport { STR_EVENTS_DISCARDED, STR_EVENTS_SEND_REQUEST, STR_EVENTS_SENT, STR_OFFLINE_DROP, STR_OFFLINE_SENT, STR_OFFLINE_STORE, STR_PERF_EVENT } from \"./InternalConstants\";\r\nvar defaultValues = {\r\n    perfEvtsSendAll: false\r\n};\r\nfunction _runScheduledListeners(asyncNotifications) {\r\n    asyncNotifications.h = null;\r\n    var callbacks = asyncNotifications.cb;\r\n    asyncNotifications.cb = [];\r\n    arrForEach(callbacks, function (cb) {\r\n        // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running\r\n        safe(cb.fn, [cb.arg]);\r\n    });\r\n}\r\n// This function is used to combine the logic of running the listeners and handling the async notifications so that they don't\r\n// create multiple timers if there are multiple async listeners.\r\nfunction _runListeners(listeners, name, asyncNotifications, callback) {\r\n    arrForEach(listeners, function (listener) {\r\n        if (listener && listener[name]) {\r\n            if (asyncNotifications) {\r\n                // Schedule the callback to be called after the current call stack has cleared.\r\n                asyncNotifications.cb[_DYN_PUSH /* @min:%2epush */]({\r\n                    fn: callback,\r\n                    arg: listener\r\n                });\r\n                asyncNotifications.h = asyncNotifications.h || scheduleTimeout(_runScheduledListeners, 0, asyncNotifications);\r\n            }\r\n            else {\r\n                // Run the listener in a try-catch to ensure that a single listener failing doesn't prevent the others from running\r\n                safe(callback, [listener]);\r\n            }\r\n        }\r\n    });\r\n}\r\n/**\r\n * Class to manage sending notifications to all the listeners.\r\n */\r\nvar NotificationManager = /** @class */ (function () {\r\n    function NotificationManager(config) {\r\n        this.listeners = [];\r\n        var perfEvtsSendAll;\r\n        var unloadHandler;\r\n        var _listeners = [];\r\n        var _asyncNotifications = {\r\n            h: null,\r\n            cb: []\r\n        };\r\n        var cfgHandler = createDynamicConfig(config, defaultValues);\r\n        unloadHandler = cfgHandler[_DYN_WATCH /* @min:%2ewatch */](function (details) {\r\n            perfEvtsSendAll = !!details.cfg.perfEvtsSendAll;\r\n        });\r\n        dynamicProto(NotificationManager, this, function (_self) {\r\n            objDefine(_self, \"listeners\", {\r\n                g: function () { return _listeners; }\r\n            });\r\n            _self[_DYN_ADD_NOTIFICATION_LIS1 /* @min:%2eaddNotificationListener */] = function (listener) {\r\n                _listeners[_DYN_PUSH /* @min:%2epush */](listener);\r\n            };\r\n            /**\r\n             * Removes all instances of the listener.\r\n             * @param listener - AWTNotificationListener to remove.\r\n             */\r\n            _self[_DYN_REMOVE_NOTIFICATION_0 /* @min:%2eremoveNotificationListener */] = function (listener) {\r\n                var index = arrIndexOf(_listeners, listener);\r\n                while (index > -1) {\r\n                    _listeners[_DYN_SPLICE /* @min:%2esplice */](index, 1);\r\n                    index = arrIndexOf(_listeners, listener);\r\n                }\r\n            };\r\n            /**\r\n             * Notification for events sent.\r\n             * @param events - The array of events that have been sent.\r\n             */\r\n            _self[STR_EVENTS_SENT /* @min:%2eeventsSent */] = function (events) {\r\n                _runListeners(_listeners, STR_EVENTS_SENT, _asyncNotifications, function (listener) {\r\n                    listener[STR_EVENTS_SENT /* @min:%2eeventsSent */](events);\r\n                });\r\n            };\r\n            /**\r\n             * Notification for events being discarded.\r\n             * @param events - The array of events that have been discarded by the SDK.\r\n             * @param reason - The reason for which the SDK discarded the events. The EventsDiscardedReason\r\n             * constant should be used to check the different values.\r\n             */\r\n            _self[STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */] = function (events, reason) {\r\n                _runListeners(_listeners, STR_EVENTS_DISCARDED, _asyncNotifications, function (listener) {\r\n                    listener[STR_EVENTS_DISCARDED /* @min:%2eeventsDiscarded */](events, reason);\r\n                });\r\n            };\r\n            /**\r\n             * [Optional] A function called when the events have been requested to be sent to the sever.\r\n             * @param sendReason - The reason why the event batch is being sent.\r\n             * @param isAsync - A flag which identifies whether the requests are being sent in an async or sync manner.\r\n             */\r\n            _self[STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */] = function (sendReason, isAsync) {\r\n                _runListeners(_listeners, STR_EVENTS_SEND_REQUEST, isAsync ? _asyncNotifications : null, function (listener) {\r\n                    listener[STR_EVENTS_SEND_REQUEST /* @min:%2eeventsSendRequest */](sendReason, isAsync);\r\n                });\r\n            };\r\n            _self[STR_PERF_EVENT /* @min:%2eperfEvent */] = function (perfEvent) {\r\n                if (perfEvent) {\r\n                    // Send all events or only parent events\r\n                    if (perfEvtsSendAll || !perfEvent[_DYN_IS_CHILD_EVT /* @min:%2eisChildEvt */]()) {\r\n                        _runListeners(_listeners, STR_PERF_EVENT, null, function (listener) {\r\n                            if (perfEvent[_DYN_IS_ASYNC /* @min:%2eisAsync */]) {\r\n                                scheduleTimeout(function () { return listener[STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent); }, 0);\r\n                            }\r\n                            else {\r\n                                listener[STR_PERF_EVENT /* @min:%2eperfEvent */](perfEvent);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n            _self[STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */] = function (events) {\r\n                if (events && events[_DYN_LENGTH /* @min:%2elength */]) {\r\n                    _runListeners(_listeners, STR_OFFLINE_STORE, _asyncNotifications, function (listener) {\r\n                        listener[STR_OFFLINE_STORE /* @min:%2eofflineEventsStored */](events);\r\n                    });\r\n                }\r\n            };\r\n            _self[STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */] = function (batch) {\r\n                if (batch && batch[_DYN_DATA /* @min:%2edata */]) {\r\n                    _runListeners(_listeners, STR_OFFLINE_SENT, _asyncNotifications, function (listener) {\r\n                        listener[STR_OFFLINE_SENT /* @min:%2eofflineBatchSent */](batch);\r\n                    });\r\n                }\r\n            };\r\n            _self[STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */] = function (cnt, reason) {\r\n                if (cnt > 0) {\r\n                    var rn_1 = reason || 0; // default is unknown\r\n                    _runListeners(_listeners, STR_OFFLINE_DROP, _asyncNotifications, function (listener) {\r\n                        listener[STR_OFFLINE_DROP /* @min:%2eofflineBatchDrop */](cnt, rn_1);\r\n                    });\r\n                }\r\n            };\r\n            _self[_DYN_UNLOAD /* @min:%2eunload */] = function (isAsync) {\r\n                var _finishUnload = function () {\r\n                    unloadHandler && unloadHandler.rm();\r\n                    unloadHandler = null;\r\n                    _listeners = [];\r\n                    // Clear any async listener\r\n                    _asyncNotifications.h && _asyncNotifications.h[_DYN_CANCEL /* @min:%2ecancel */]();\r\n                    _asyncNotifications.h = null;\r\n                    _asyncNotifications.cb = [];\r\n                };\r\n                var waiting;\r\n                _runListeners(_listeners, \"unload\", null, function (listener) {\r\n                    var asyncUnload = listener[_DYN_UNLOAD /* @min:%2eunload */](isAsync);\r\n                    if (asyncUnload) {\r\n                        if (!waiting) {\r\n                            waiting = [];\r\n                        }\r\n                        waiting[_DYN_PUSH /* @min:%2epush */](asyncUnload);\r\n                    }\r\n                });\r\n                if (waiting) {\r\n                    return createPromise(function (resolve) {\r\n                        return doAwaitResponse(createAllPromise(waiting), function () {\r\n                            _finishUnload();\r\n                            resolve();\r\n                        });\r\n                    });\r\n                }\r\n                else {\r\n                    _finishUnload();\r\n                }\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Adds a notification listener.\r\n     * @param listener - The notification listener to be added.\r\n     */\r\n    NotificationManager.prototype.addNotificationListener = function (listener) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Removes all instances of the listener.\r\n     * @param listener - AWTNotificationListener to remove.\r\n     */\r\n    NotificationManager.prototype.removeNotificationListener = function (listener) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Notification for events sent.\r\n     * @param events - The array of events that have been sent.\r\n     */\r\n    NotificationManager.prototype.eventsSent = function (events) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Notification for events being discarded.\r\n     * @param events - The array of events that have been discarded by the SDK.\r\n     * @param reason - The reason for which the SDK discarded the events. The EventsDiscardedReason\r\n     * constant should be used to check the different values.\r\n     */\r\n    NotificationManager.prototype.eventsDiscarded = function (events, reason) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] A function called when the events have been requested to be sent to the sever.\r\n     * @param sendReason - The reason why the event batch is being sent.\r\n     * @param isAsync - A flag which identifies whether the requests are being sent in an async or sync manner.\r\n     */\r\n    NotificationManager.prototype.eventsSendRequest = function (sendReason, isAsync) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] This event is sent if you have enabled perf events, they are primarily used to track internal performance testing and debugging\r\n     * the event can be displayed via the debug plugin extension.\r\n     * @param perfEvent\r\n     */\r\n    NotificationManager.prototype.perfEvent = function (perfEvent) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * Unload and remove any state that this INotificationManager may be holding, this is generally called when the\r\n     * owning SDK is being unloaded.\r\n     * @param isAsync - Can the unload be performed asynchronously (default)\r\n     * @return If the unload occurs synchronously then nothing should be returned, if happening asynchronously then\r\n     * the function should return an [IPromise](https://nevware21.github.io/ts-async/typedoc/interfaces/IPromise.html)\r\n     * / Promise to allow any listeners to wait for the operation to complete.\r\n     */\r\n    NotificationManager.prototype.unload = function (isAsync) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] A function called when the offline events have been stored to the persistent storage\r\n     * @param events - events that are stored in the persistent storage\r\n     */\r\n    NotificationManager.prototype.offlineEventsStored = function (events) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] A function called when the offline events have been sent from the persistent storage\r\n     * @param batch - payload data that is sent from the persistent storage\r\n     */\r\n    NotificationManager.prototype.offlineBatchSent = function (batch) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    /**\r\n     * [Optional] A function called when the offline events have been dropped from the persistent storage\r\n     * @param cnt - count of batches dropped\r\n     * @param reason - the reason why the batches is dropped\r\n     * @since v3.1.1\r\n     */\r\n    NotificationManager.prototype.offlineBatchDrop = function (cnt, reason) {\r\n        // @DynamicProtoStub -- DO NOT add any code as this will be removed during packaging\r\n    };\r\n    return NotificationManager;\r\n}());\r\nexport { NotificationManager };\r\n//# sourceMappingURL=NotificationManager.js.map"],"names":[],"mappings":";;;;AAA4D;AAC1B;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;mEA+EM,CAAC;;;;;+BACwB;AAC/B;AACA;AACA"}