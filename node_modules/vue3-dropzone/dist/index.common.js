'use strict';

var vue = require('vue');
var fileSelector = require('file-selector');
var accepts = require('attr-accept');

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol */


var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function isIe(userAgent) {
    return userAgent.includes('MSIE') || userAgent.includes('Trident/');
}
function isEdge(userAgent) {
    return userAgent.includes('Edge/');
}
function isIeOrEdge(userAgent) {
    if (userAgent === void 0) { userAgent = window.navigator.userAgent; }
    return isIe(userAgent) || isEdge(userAgent);
}
function onDocumentDragOver(event) {
    event.preventDefault();
}
function isEvtWithFiles(event) {
    if (!event.dataTransfer) {
        return !!event.target && !!event.target.files;
    }
    return Array.prototype.some.call(event.dataTransfer.types, function (type) { return type === 'Files' || type === 'application/x-moz-file'; });
}
function isPropagationStopped(event) {
    if (typeof event.isPropagationStopped === 'function') {
        return event.isPropagationStopped();
    }
    if (typeof event.cancelBubble !== 'undefined') {
        return event.cancelBubble;
    }
    return false;
}
var FILE_INVALID_TYPE = 'file-invalid-type';
var FILE_TOO_LARGE = 'file-too-large';
var FILE_TOO_SMALL = 'file-too-small';
var TOO_MANY_FILES = 'too-many-files';
var TOO_MANY_FILES_REJECTION = {
    code: TOO_MANY_FILES,
    message: 'Too many files',
};
var getInvalidTypeRejectionErr = function (accept) {
    accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
    var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(', ')) : accept;
    return {
        code: FILE_INVALID_TYPE,
        message: "File type must be ".concat(messageSuffix),
    };
};
function isDefined(value) {
    return value !== undefined && value !== null;
}
var acceptsDefault = accepts.default;
var acceptsFn = acceptsDefault || accepts;
function fileAccepted(file, accept) {
    var isAcceptable = file.type === 'application/x-moz-file' || acceptsFn(file, accept);
    return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
}
var getTooLargeRejectionErr = function (maxSize) { return ({
    code: FILE_TOO_LARGE,
    message: "File is larger than ".concat(maxSize, " bytes"),
}); };
var getTooSmallRejectionErr = function (minSize) { return ({
    code: FILE_TOO_SMALL,
    message: "File is smaller than ".concat(minSize, " bytes"),
}); };
function fileMatchSize(file, minSize, maxSize) {
    if (isDefined(file.size) && file.size) {
        if (isDefined(minSize) && isDefined(maxSize)) {
            if (file.size > maxSize)
                return [false, getTooLargeRejectionErr(maxSize)];
            if (file.size < minSize)
                return [false, getTooSmallRejectionErr(minSize)];
        }
        else if (isDefined(minSize) && file.size < minSize) {
            return [false, getTooSmallRejectionErr(minSize)];
        }
        else if (isDefined(maxSize) && file.size > maxSize) {
            return [false, getTooLargeRejectionErr(maxSize)];
        }
    }
    return [true, null];
}
function composeEventHandlers() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return fns.some(function (fn) {
            if (!isPropagationStopped(event) && fn) {
                fn.apply(void 0, __spreadArray([event], args, false));
            }
            return isPropagationStopped(event);
        });
    };
}
function allFilesAccepted(_a) {
    var files = _a.files, accept = _a.accept, minSize = _a.minSize, maxSize = _a.maxSize, multiple = _a.multiple, maxFiles = _a.maxFiles;
    if ((!multiple && files.length > 1) || (multiple && maxFiles >= 1 && files.length > maxFiles)) {
        return false;
    }
    return files.every(function (file) {
        var accepted = fileAccepted(file, accept)[0];
        var sizeMatch = fileMatchSize(file, minSize, maxSize)[0];
        return accepted && sizeMatch;
    });
}
var defaultProps = {
    disabled: false,
    getFilesFromEvent: fileSelector.fromEvent,
    maxSize: Infinity,
    minSize: 0,
    multiple: true,
    maxFiles: 0,
    preventDropOnDocument: true,
    noClick: false,
    noKeyboard: false,
    noDrag: false,
    noDragEventsBubbling: false,
};
function useDropzone(options) {
    if (options === void 0) { options = {}; }
    var optionsRef = vue.ref(__assign(__assign({}, defaultProps), options));
    vue.watch(function () { return (__assign({}, options)); }, function (value) {
        optionsRef.value = __assign(__assign({}, optionsRef.value), value);
    });
    var rootRef = vue.ref();
    var inputRef = vue.ref();
    var state = vue.reactive({
        isFocused: false,
        isFileDialogActive: false,
        isDragActive: false,
        isDragAccept: false,
        isDragReject: false,
        draggedFiles: [],
        acceptedFiles: [],
        fileRejections: [],
    });
    var openFileDialog = function () {
        if (inputRef.value) {
            state.isFileDialogActive = true;
            inputRef.value.value = '';
            inputRef.value.click();
        }
    };
    var onWindowFocus = function () {
        var onFileDialogCancel = optionsRef.value.onFileDialogCancel;
        if (state.isFileDialogActive) {
            setTimeout(function () {
                if (inputRef.value) {
                    var files = inputRef.value.files;
                    if (files && !files.length) {
                        state.isFileDialogActive = false;
                        if (typeof onFileDialogCancel === 'function') {
                            onFileDialogCancel();
                        }
                    }
                }
            }, 300);
        }
    };
    function onFocusCb() {
        state.isFocused = true;
    }
    function onBlurCb() {
        state.isFocused = false;
    }
    function onClickCb() {
        var noClick = optionsRef.value.noClick;
        if (noClick) {
            return;
        }
        if (isIeOrEdge()) {
            setTimeout(openFileDialog, 0);
        }
        else {
            openFileDialog();
        }
    }
    var dragTargetsRef = vue.ref([]);
    var onDocumentDrop = function (event) {
        if (!rootRef.value) {
            return;
        }
        var rootElm = rootRef.value.$el || rootRef.value;
        if (rootElm.contains(event.target)) {
            return;
        }
        event.preventDefault();
        dragTargetsRef.value = [];
    };
    vue.onMounted(function () {
        window.addEventListener('focus', onWindowFocus, false);
        var preventDropOnDocument = optionsRef.value.preventDropOnDocument;
        if (preventDropOnDocument) {
            document.addEventListener('dragover', onDocumentDragOver, false);
            document.addEventListener('drop', onDocumentDrop, false);
        }
    });
    vue.onUnmounted(function () {
        window.removeEventListener('focus', onWindowFocus, false);
        var preventDropOnDocument = optionsRef.value.preventDropOnDocument;
        if (preventDropOnDocument) {
            document.removeEventListener('dragover', onDocumentDragOver);
            document.removeEventListener('drop', onDocumentDrop);
        }
    });
    function stopPropagation(event) {
        var noDragEventsBubbling = optionsRef.value.noDragEventsBubbling;
        if (noDragEventsBubbling) {
            event.stopPropagation();
        }
    }
    function onDragEnterCb(event) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, getFilesFromEvent, noDragEventsBubbling, onDragEnter, draggedFilesRes;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = optionsRef.value, getFilesFromEvent = _a.getFilesFromEvent, noDragEventsBubbling = _a.noDragEventsBubbling, onDragEnter = _a.onDragEnter;
                        event.preventDefault();
                        stopPropagation(event);
                        dragTargetsRef.value = __spreadArray(__spreadArray([], dragTargetsRef.value, true), [event.target], false);
                        if (!isEvtWithFiles(event)) return [3, 2];
                        if (!getFilesFromEvent) {
                            return [2];
                        }
                        return [4, getFilesFromEvent(event)];
                    case 1:
                        draggedFilesRes = _b.sent();
                        if (!draggedFilesRes) {
                            draggedFilesRes = [];
                        }
                        if (isPropagationStopped(event) && !noDragEventsBubbling) {
                            return [2];
                        }
                        state.draggedFiles = draggedFilesRes;
                        state.isDragActive = true;
                        if (onDragEnter) {
                            onDragEnter(event);
                        }
                        _b.label = 2;
                    case 2: return [2];
                }
            });
        });
    }
    function onDragOverCb(event) {
        var onDragOver = optionsRef.value.onDragOver;
        event.preventDefault();
        stopPropagation(event);
        if (event.dataTransfer) {
            try {
                event.dataTransfer.dropEffect = 'copy';
            }
            catch (_a) {
            }
        }
        if (isEvtWithFiles(event) && onDragOver) {
            onDragOver(event);
        }
        return false;
    }
    function onDragLeaveCb(event) {
        event.preventDefault();
        stopPropagation(event);
        var targets = dragTargetsRef.value.filter(function (target) {
            if (!rootRef.value) {
                return false;
            }
            var rootElm = rootRef.value.$el || rootRef.value;
            return rootElm.contains(target);
        });
        var targetIdx = targets.indexOf(event.target);
        if (targetIdx !== -1) {
            targets.splice(targetIdx, 1);
        }
        dragTargetsRef.value = targets;
        if (targets.length > 0) {
            return;
        }
        state.draggedFiles = [];
        state.isDragActive = false;
        var onDragLeave = optionsRef.value.onDragLeave;
        if (isEvtWithFiles(event) && onDragLeave) {
            onDragLeave(event);
        }
    }
    function onDropCb(event) {
        event.preventDefault();
        stopPropagation(event);
        dragTargetsRef.value = [];
        var _a = optionsRef.value, getFilesFromEvent = _a.getFilesFromEvent, noDragEventsBubbling = _a.noDragEventsBubbling, accept = _a.accept, minSize = _a.minSize, maxSize = _a.maxSize, multiple = _a.multiple, maxFiles = _a.maxFiles, onDrop = _a.onDrop, onDropRejected = _a.onDropRejected, onDropAccepted = _a.onDropAccepted;
        if (isEvtWithFiles(event)) {
            if (!getFilesFromEvent) {
                return;
            }
            Promise.resolve(getFilesFromEvent(event)).then(function (files) {
                if (isPropagationStopped(event) && !noDragEventsBubbling) {
                    return;
                }
                var acceptedFiles = [];
                var fileRejections = [];
                files.forEach(function (file) {
                    var _a = fileAccepted(file, accept), accepted = _a[0], acceptError = _a[1];
                    var _b = fileMatchSize(file, minSize, maxSize), sizeMatch = _b[0], sizeError = _b[1];
                    if (accepted && sizeMatch) {
                        acceptedFiles.push(file);
                    }
                    else {
                        var errors = [acceptError, sizeError].filter(function (e) { return e; });
                        fileRejections.push({ file: file, errors: errors });
                    }
                });
                if ((!multiple && acceptedFiles.length > 1) || (multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles)) {
                    acceptedFiles.forEach(function (file) {
                        fileRejections.push({ file: file, errors: [TOO_MANY_FILES_REJECTION] });
                    });
                    acceptedFiles.splice(0);
                }
                state.acceptedFiles = acceptedFiles;
                state.fileRejections = fileRejections;
                if (onDrop) {
                    onDrop(acceptedFiles, fileRejections, event);
                }
                if (fileRejections.length > 0 && onDropRejected) {
                    onDropRejected(fileRejections, event);
                }
                if (acceptedFiles.length > 0 && onDropAccepted) {
                    onDropAccepted(acceptedFiles, event);
                }
            });
        }
        state.isFileDialogActive = false;
        state.isDragActive = false;
        state.draggedFiles = [];
        state.acceptedFiles = [];
        state.fileRejections = [];
    }
    var composeHandler = function (fn) { return (optionsRef.value.disabled ? undefined : fn); };
    var composeKeyboardHandler = function (fn) { return (optionsRef.value.noKeyboard ? undefined : composeHandler(fn)); };
    var composeDragHandler = function (fn) { return (optionsRef.value.noDrag ? undefined : composeHandler(fn)); };
    var getRootProps = function (_a) {
        if (_a === void 0) { _a = {}; }
        var onFocus = _a.onFocus, onBlur = _a.onBlur, onClick = _a.onClick, onDragEnter = _a.onDragEnter, onDragenter = _a.onDragenter, onDragOver = _a.onDragOver, onDragover = _a.onDragover, onDragLeave = _a.onDragLeave, onDragleave = _a.onDragleave, onDrop = _a.onDrop, rest = __rest(_a, ["onFocus", "onBlur", "onClick", "onDragEnter", "onDragenter", "onDragOver", "onDragover", "onDragLeave", "onDragleave", "onDrop"]);
        return (__assign(__assign({ onFocus: composeKeyboardHandler(composeEventHandlers(onFocus, onFocusCb)), onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)), onClick: composeHandler(composeEventHandlers(onClick, onClickCb)), onDragenter: composeDragHandler(composeEventHandlers(onDragEnter, onDragenter, onDragEnterCb)), onDragover: composeDragHandler(composeEventHandlers(onDragOver, onDragover, onDragOverCb)), onDragleave: composeDragHandler(composeEventHandlers(onDragLeave, onDragleave, onDragLeaveCb)), onDrop: composeDragHandler(composeEventHandlers(onDrop, onDropCb)), ref: rootRef }, (!optionsRef.value.disabled && !optionsRef.value.noKeyboard ? { tabIndex: 0 } : {})), rest));
    };
    var onInputElementClick = function (event) {
        event.stopPropagation();
    };
    function getInputProps(_a) {
        if (_a === void 0) { _a = {}; }
        var onChange = _a.onChange, onClick = _a.onClick, rest = __rest(_a, ["onChange", "onClick"]);
        var inputProps = {
            accept: optionsRef.value.accept,
            multiple: optionsRef.value.multiple,
            style: 'display: none',
            type: 'file',
            onChange: composeHandler(composeEventHandlers(onChange, onDropCb)),
            onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
            autoComplete: 'off',
            tabIndex: -1,
            ref: inputRef,
        };
        return __assign(__assign({}, inputProps), rest);
    }
    var fileCount = vue.computed(function () { return (state.draggedFiles ? state.draggedFiles.length : 0); });
    var isDragAccept = vue.computed(function () { return fileCount.value > 0 && allFilesAccepted({
        files: state.draggedFiles,
        accept: optionsRef.value.accept,
        minSize: optionsRef.value.minSize,
        maxSize: optionsRef.value.maxSize,
        multiple: optionsRef.value.multiple,
        maxFiles: optionsRef.value.maxFiles,
    }); });
    var isDragReject = vue.computed(function () { return fileCount.value > 0 && !isDragAccept.value; });
    return __assign(__assign({}, vue.toRefs(state)), { isDragAccept: isDragAccept, isDragReject: isDragReject, isFocused: vue.computed(function () { return state.isFocused && !optionsRef.value.disabled; }), getRootProps: getRootProps, getInputProps: getInputProps, rootRef: rootRef, inputRef: inputRef, open: composeHandler(openFileDialog) });
}

exports.useDropzone = useDropzone;
