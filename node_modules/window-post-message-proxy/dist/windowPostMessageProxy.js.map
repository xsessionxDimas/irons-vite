{"version":3,"file":"windowPostMessageProxy.js","mappings":"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","sources":["webpack://window-post-message-proxy/webpack/universalModuleDefinition","webpack://window-post-message-proxy/./src/windowPostMessageProxy.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"window-post-message-proxy\"] = factory();\n\telse\n\t\troot[\"window-post-message-proxy\"] = factory();\n})(self, () => {\nreturn ","declare global {\r\n  interface Window {\r\n    msCrypto: Crypto;\r\n  }\r\n}\r\n\r\ninterface IDeferred {\r\n  resolve: <T>(value?: T | Promise<T>) => void;\r\n  reject: <T>(error: T) => void;\r\n  promise: Promise<any>;\r\n}\r\n\r\ninterface IDeferredCache {\r\n  [messageId: string]: IDeferred;\r\n}\r\n\r\nexport interface ITrackingProperties {\r\n  id: string;\r\n}\r\n\r\nexport interface IAddTrackingProperties {\r\n  <T>(message: T, trackingProperties: ITrackingProperties): T;\r\n}\r\n\r\nexport interface IGetTrackingProperties {\r\n  (message: any): ITrackingProperties;\r\n}\r\n\r\nexport interface IProcessTrackingProperties {\r\n  addTrackingProperties: IAddTrackingProperties;\r\n  getTrackingProperties: IGetTrackingProperties;\r\n}\r\n\r\nexport interface IIsErrorMessage {\r\n  (message: any): boolean;\r\n}\r\n\r\nexport interface IMessageHandler {\r\n  test(message: any): boolean;\r\n  handle(message: any): any;\r\n}\r\n\r\nexport interface IWindowPostMessageProxyOptions {\r\n  receiveWindow?: Window;\r\n  processTrackingProperties?: IProcessTrackingProperties;\r\n  isErrorMessage?: IIsErrorMessage;\r\n  name?: string;\r\n  logMessages?: boolean;\r\n  eventSourceOverrideWindow?: Window;\r\n  suppressWarnings?: boolean;\r\n}\r\n\r\nexport class WindowPostMessageProxy {\r\n  // Static\r\n  static defaultAddTrackingProperties<T>(message: T, trackingProperties: ITrackingProperties): T {\r\n    (<any>message)[WindowPostMessageProxy.messagePropertyName] = trackingProperties;\r\n    return message;\r\n  }\r\n  static defaultGetTrackingProperties(message: any): ITrackingProperties {\r\n    return message[WindowPostMessageProxy.messagePropertyName];\r\n  }\r\n\r\n  static defaultIsErrorMessage(message: any): boolean {\r\n    return !!message.error;\r\n  }\r\n\r\n  private static messagePropertyName = \"windowPostMessageProxy\";\r\n  /**\r\n   * Utility to create a deferred object.\r\n   */\r\n  // TODO: Look to use RSVP library instead of doing this manually.\r\n  // From what I searched RSVP would work better because it has .finally and .deferred; however, it doesn't have Typings information.\r\n  private static createDeferred(): IDeferred {\r\n    const deferred: IDeferred = {\r\n      resolve: null,\r\n      reject: null,\r\n      promise: null\r\n    };\r\n\r\n    const promise = new Promise((resolve: (value: any) => void, reject: () => void) => {\r\n      deferred.resolve = resolve;\r\n      deferred.reject = reject;\r\n    });\r\n\r\n    deferred.promise = promise;\r\n\r\n    return deferred;\r\n  }\r\n\r\n  /**\r\n   * Utility to generate random sequence of characters used as tracking id for promises.\r\n   */\r\n  private static createRandomString(): string {\r\n\r\n    \t// window.msCrypto for IE\r\n    let cryptoObj = window.crypto || window.msCrypto;\r\n    let randomValueArray = new Uint32Array(1);\r\n    cryptoObj.getRandomValues(randomValueArray);\r\n\r\n    return randomValueArray[0].toString(36).substring(1);\r\n  }\r\n\r\n  // Private\r\n  private logMessages: boolean;\r\n  private name: string;\r\n  private addTrackingProperties: IAddTrackingProperties;\r\n  private getTrackingProperties: IGetTrackingProperties;\r\n  private isErrorMessage: IIsErrorMessage;\r\n  private receiveWindow: Window;\r\n  private pendingRequestPromises: IDeferredCache = {};\r\n  private handlers: IMessageHandler[];\r\n  private windowMessageHandler: (e: MessageEvent) => any;\r\n  private eventSourceOverrideWindow: Window;\r\n  private suppressWarnings: boolean;\r\n\r\n  constructor(\r\n    options: IWindowPostMessageProxyOptions = {\r\n      processTrackingProperties: {\r\n        addTrackingProperties: WindowPostMessageProxy.defaultAddTrackingProperties,\r\n        getTrackingProperties: WindowPostMessageProxy.defaultGetTrackingProperties\r\n      },\r\n      isErrorMessage: WindowPostMessageProxy.defaultIsErrorMessage,\r\n      receiveWindow: window,\r\n      name: WindowPostMessageProxy.createRandomString()\r\n    }) {\r\n\r\n    // save options with defaults\r\n    this.addTrackingProperties = (options.processTrackingProperties && options.processTrackingProperties.addTrackingProperties) || WindowPostMessageProxy.defaultAddTrackingProperties;\r\n    this.getTrackingProperties = (options.processTrackingProperties && options.processTrackingProperties.getTrackingProperties) || WindowPostMessageProxy.defaultGetTrackingProperties;\r\n    this.isErrorMessage = options.isErrorMessage || WindowPostMessageProxy.defaultIsErrorMessage;\r\n    this.receiveWindow = options.receiveWindow || window;\r\n    this.name = options.name || WindowPostMessageProxy.createRandomString();\r\n    this.logMessages = options.logMessages || false;\r\n    this.eventSourceOverrideWindow = options.eventSourceOverrideWindow;\r\n    this.suppressWarnings = options.suppressWarnings || false;\r\n\r\n    if (this.logMessages) {\r\n      console.log(`new WindowPostMessageProxy created with name: ${this.name} receiving on window: ${this.receiveWindow.document.title}`);\r\n    }\r\n\r\n    // Initialize\r\n    this.handlers = [];\r\n    this.windowMessageHandler = (event: MessageEvent) => this.onMessageReceived(event);\r\n    this.start();\r\n  }\r\n\r\n  /**\r\n   * Adds handler.\r\n   * If the first handler whose test method returns true will handle the message and provide a response.\r\n   */\r\n  addHandler(handler: IMessageHandler) {\r\n    this.handlers.push(handler);\r\n  }\r\n  /**\r\n   * Removes handler.\r\n   * The reference must match the original object that was provided when adding the handler.\r\n   */\r\n  removeHandler(handler: IMessageHandler) {\r\n    const handlerIndex = this.handlers.indexOf(handler);\r\n    if (handlerIndex === -1) {\r\n      throw new Error(`You attempted to remove a handler but no matching handler was found.`);\r\n    }\r\n\r\n    this.handlers.splice(handlerIndex, 1);\r\n  }\r\n\r\n  /**\r\n   * Start listening to message events.\r\n   */\r\n  start() {\r\n    this.receiveWindow.addEventListener('message', this.windowMessageHandler);\r\n  }\r\n\r\n  /**\r\n   * Stops listening to message events.\r\n   */\r\n  stop() {\r\n    this.receiveWindow.removeEventListener('message', this.windowMessageHandler);\r\n  }\r\n\r\n  /**\r\n   * Post message to target window with tracking properties added and save deferred object referenced by tracking id.\r\n   */\r\n  postMessage<T>(targetWindow: Window, message: any): Promise<T> {\r\n    // Add tracking properties to indicate message came from this proxy\r\n    const trackingProperties: ITrackingProperties = { id: WindowPostMessageProxy.createRandomString() };\r\n    this.addTrackingProperties(message, trackingProperties);\r\n\r\n    if (this.logMessages) {\r\n      console.log(`${this.name} Posting message:`);\r\n      console.log(JSON.stringify(message, null, '  '));\r\n    }\r\n\r\n    targetWindow.postMessage(message, \"*\");\r\n    const deferred = WindowPostMessageProxy.createDeferred();\r\n    this.pendingRequestPromises[trackingProperties.id] = deferred;\r\n\r\n    return deferred.promise;\r\n  }\r\n\r\n  /**\r\n   * Send response message to target window.\r\n   * Response messages re-use tracking properties from a previous request message.\r\n   */\r\n  private sendResponse(targetWindow: Window, message: any, trackingProperties: ITrackingProperties): void {\r\n    this.addTrackingProperties(message, trackingProperties);\r\n\r\n    if (this.logMessages) {\r\n      console.log(`${this.name} Sending response:`);\r\n      console.log(JSON.stringify(message, null, '  '));\r\n    }\r\n\r\n    targetWindow.postMessage(message, \"*\");\r\n  }\r\n\r\n  /**\r\n   * Message handler.\r\n   */\r\n  private onMessageReceived(event: MessageEvent) {\r\n    if (this.logMessages) {\r\n      console.log(`${this.name} Received message:`);\r\n      console.log(`type: ${event.type}`);\r\n      console.log(JSON.stringify(event.data, null, '  '));\r\n    }\r\n\r\n    let sendingWindow = this.eventSourceOverrideWindow || event.source as Window;\r\n    if (!sendingWindow) {\r\n      return;\r\n    }\r\n\r\n    let message: any = event.data;\r\n\r\n    if (typeof message !== \"object\") {\r\n      if (!this.suppressWarnings) {\r\n        console.warn(`Proxy(${this.name}): Received message that was not an object. Discarding message`);\r\n      }\r\n      return;\r\n    }\r\n\r\n    let trackingProperties: ITrackingProperties;\r\n    try {\r\n      trackingProperties = this.getTrackingProperties(message);\r\n    }\r\n    catch (e) {\r\n      if (!this.suppressWarnings) {\r\n        console.warn(`Proxy(${this.name}): Error occurred when attempting to get tracking properties from incoming message:`, JSON.stringify(message, null, '  '), \"Error: \", e);\r\n      }\r\n    }\r\n\r\n    let deferred: IDeferred;\r\n    if (trackingProperties) {\r\n      deferred = this.pendingRequestPromises[trackingProperties.id];\r\n    }\r\n\r\n    // If message does not have a known ID, treat it as a request\r\n    // Otherwise, treat message as response\r\n    if (!deferred) {\r\n      const handled = this.handlers.some(handler => {\r\n        let canMessageBeHandled = false;\r\n        try {\r\n          canMessageBeHandled = handler.test(message);\r\n        }\r\n        catch (e) {\r\n          if (!this.suppressWarnings) {\r\n            console.warn(`Proxy(${this.name}): Error occurred when handler was testing incoming message:`, JSON.stringify(message, null, '  '), \"Error: \", e);\r\n          }\r\n        }\r\n\r\n        if (canMessageBeHandled) {\r\n          let responseMessagePromise: Promise<any>;\r\n\r\n          try {\r\n            responseMessagePromise = Promise.resolve(handler.handle(message));\r\n          }\r\n          catch (e) {\r\n            if (!this.suppressWarnings) {\r\n              console.warn(`Proxy(${this.name}): Error occurred when handler was processing incoming message:`, JSON.stringify(message, null, '  '), \"Error: \", e);\r\n            }\r\n            responseMessagePromise = Promise.resolve();\r\n          }\r\n\r\n          responseMessagePromise\r\n            .then(responseMessage => {\r\n              if (!responseMessage) {\r\n                const warningMessage = `Handler for message: ${JSON.stringify(message, null, '  ')} did not return a response message. The default response message will be returned instead.`;\r\n                if (!this.suppressWarnings) {\r\n                  console.warn(`Proxy(${this.name}): ${warningMessage}`);\r\n                }\r\n                responseMessage = {\r\n                  warning: warningMessage\r\n                };\r\n              }\r\n              this.sendResponse(sendingWindow, responseMessage, trackingProperties);\r\n            });\r\n\r\n          return true;\r\n        }\r\n      });\r\n\r\n      /**\r\n       * TODO: Consider returning an error message if nothing handled the message.\r\n       * In the case of the Report receiving messages all of them should be handled,\r\n       * however, in the case of the SDK receiving messages it's likely it won't register handlers\r\n       * for all events. Perhaps make this an option at construction time.\r\n       */\r\n      if (!handled && !this.suppressWarnings) {\r\n        console.warn(`Proxy(${this.name}) did not handle message. Handlers: ${this.handlers.length}  Message: ${JSON.stringify(message, null, '')}.`);\r\n        // this.sendResponse({ notHandled: true }, trackingProperties);\r\n      }\r\n    }\r\n    else {\r\n      /**\r\n       * If error message reject promise,\r\n       * Otherwise, resolve promise\r\n       */\r\n      let isErrorMessage = true;\r\n      try {\r\n        isErrorMessage = this.isErrorMessage(message);\r\n      }\r\n      catch (e) {\r\n        console.warn(`Proxy(${this.name}) Error occurred when trying to determine if message is consider an error response. Message: `, JSON.stringify(message, null, ''), 'Error: ', e);\r\n      }\r\n\r\n      if (isErrorMessage) {\r\n        deferred.reject(message);\r\n      }\r\n      else {\r\n        deferred.resolve(message);\r\n      }\r\n\r\n      // TODO: Move to .finally clause up where promise is created for better maitenance like original proxy code.\r\n      delete this.pendingRequestPromises[trackingProperties.id];\r\n    }\r\n  }\r\n}\r\n"],"names":["root","factory","exports","module","define","amd","self","options","processTrackingProperties","addTrackingProperties","WindowPostMessageProxy","defaultAddTrackingProperties","getTrackingProperties","defaultGetTrackingProperties","isErrorMessage","defaultIsErrorMessage","receiveWindow","window","name","createRandomString","pendingRequestPromises","this","logMessages","eventSourceOverrideWindow","suppressWarnings","console","log","document","title","handlers","windowMessageHandler","event","onMessageReceived","start","message","trackingProperties","messagePropertyName","error","createDeferred","deferred","resolve","reject","promise","Promise","cryptoObj","crypto","msCrypto","randomValueArray","Uint32Array","getRandomValues","toString","substring","addHandler","handler","push","removeHandler","handlerIndex","indexOf","Error","splice","addEventListener","stop","removeEventListener","postMessage","targetWindow","id","JSON","stringify","sendResponse","type","data","sendingWindow","source","e","warn","some","canMessageBeHandled","test","responseMessagePromise","handle","then","responseMessage","warningMessage","warning","length"],"sourceRoot":""}