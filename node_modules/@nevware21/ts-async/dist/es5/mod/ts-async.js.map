{"version":3,"file":"ts-async.js","sources":["../../../build/es5/mod/internal/constants.js","../../../build/es5/mod/promise/await.js","../../../build/es5/mod/promise/debug.js","../../../build/es5/mod/internal/state.js","../../../build/es5/mod/promise/event.js","../../../build/es5/mod/promise/base.js","../../../build/es5/mod/promise/itemProcessor.js","../../../build/es5/mod/promise/asyncPromise.js","../../../build/es5/mod/promise/nativePromise.js","../../../build/es5/mod/promise/syncPromise.js","../../../build/es5/mod/promise/idlePromise.js","../../../build/es5/mod/promise/promise.js","../../../build/es5/mod/promise/timeoutPromise.js","../../../build/es5/mod/helpers/doWhileAsync.js","../../../build/es5/mod/helpers/arrForEachAsync.js","../../../build/es5/mod/helpers/iterForOfAsync.js","../../../build/es5/mod/scheduler/taskScheduler.js","../../../build/es5/mod/polyfills/promise.js"],"sourcesContent":["/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nexport var STR_PROMISE = \"Promise\";\r\nexport var DONE = \"done\";\r\nexport var VALUE = \"value\";\r\nexport var ITERATOR = \"iterator\";\r\nexport var RETURN = \"return\";\r\nexport var REJECTED = \"rejected\";\r\n//# sourceMappingURL=constants.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { REJECTED } from \"../internal/constants\";\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait to be resolved or rejected.\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse(value, cb) {\r\n    return doAwait(value, function (value) {\r\n        return cb ? cb({\r\n            status: \"fulfilled\",\r\n            rejected: false,\r\n            value: value\r\n        }) : value;\r\n    }, function (reason) {\r\n        return cb ? cb({\r\n            status: REJECTED,\r\n            rejected: true,\r\n            reason: reason\r\n        }) : reason;\r\n    });\r\n}\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait(value, resolveFn, rejectFn, finallyFn) {\r\n    var result = value;\r\n    try {\r\n        if (isPromiseLike(value)) {\r\n            if (resolveFn || rejectFn) {\r\n                result = value.then(resolveFn, rejectFn);\r\n            }\r\n        }\r\n        else {\r\n            try {\r\n                if (resolveFn) {\r\n                    result = resolveFn(value);\r\n                }\r\n            }\r\n            catch (err) {\r\n                if (rejectFn) {\r\n                    result = rejectFn(err);\r\n                }\r\n                else {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        if (finallyFn) {\r\n            doFinally(result, finallyFn);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally(value, finallyFn) {\r\n    var result = value;\r\n    if (finallyFn) {\r\n        if (isPromiseLike(value)) {\r\n            if (value.finally) {\r\n                result = value.finally(finallyFn);\r\n            }\r\n            else {\r\n                // Simulate finally if not available\r\n                result = value.then(function (value) {\r\n                    finallyFn();\r\n                    return value;\r\n                }, function (reason) {\r\n                    finallyFn();\r\n                    throw reason;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            finallyFn();\r\n        }\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=await.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { objDefineProperties } from \"@nevware21/ts-utils\";\r\nvar _debugState;\r\nvar _debugResult;\r\nvar _debugHandled;\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nexport var _promiseDebugEnabled = false;\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) let _theLogger: (id: string, message: string) => void = null;\r\n//#endif\r\n/**\r\n * @internal\r\n * @ignore Internal function enable logging the internal state of the promise during execution, this code and references are\r\n * removed from the production artifacts\r\n */\r\nexport var _debugLog = /*#__PURE__*/ function (id, message) {\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) if (_theLogger) {\r\n    //#:(!DEBUG)     _theLogger(id, message);\r\n    //#:(!DEBUG) }\r\n    //#endif\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function to add the debug state to the promise so that it provides simular visibility as you would\r\n * see from native promises\r\n * @param thePromise - The Promise implementation\r\n * @param stateFn - The function to return the state of the promise\r\n * @param resultFn - The function to return the result (settled value) of the promise\r\n * @param handledFn - The function to return whether the promise has been handled (used for throwing\r\n * unhandled rejection events)\r\n */\r\nexport function _addDebugState(thePromise, stateFn, resultFn, handledFn) {\r\n    // While the IPromise implementations provide a `state` property, keeping the `[[PromiseState]]`\r\n    // as native promises also have a non-enumerable property of the same name\r\n    _debugState = _debugState || { toString: function () { return \"[[PromiseState]]\"; } };\r\n    _debugResult = _debugResult || { toString: function () { return \"[[PromiseResult]]\"; } };\r\n    _debugHandled = _debugHandled || { toString: function () { return \"[[PromiseIsHandled]]\"; } };\r\n    var props = {};\r\n    props[_debugState] = { get: stateFn };\r\n    props[_debugResult] = { get: resultFn };\r\n    props[_debugHandled] = { get: handledFn };\r\n    objDefineProperties(thePromise, props);\r\n}\r\n/**\r\n * Debug helper to enable internal debugging of the promise implementations. Disabled by default.\r\n * For the generated packages included in the npm package the `logger` will not be called as the\r\n * `_debugLog` function that uses this logger is removed during packaging.\r\n *\r\n * It is available directly from the repository for unit testing.\r\n *\r\n * @group Debug\r\n * @param enabled - Should debugging be enabled (defaults `false`, when `true` promises will have\r\n * additional debug properties and the `toString` will include extra details.\r\n * @param logger - Optional logger that will log internal state changes, only called in debug\r\n * builds as the calling function is removed is the production artifacts.\r\n * @example\r\n * ```ts\r\n * // The Id is the id of the promise\r\n * // The message is the internal debug message\r\n * function promiseDebugLogger(id: string, message: string) {\r\n *     if (console && console.log) {\r\n *         console.log(id, message);\r\n *     }\r\n * }\r\n *\r\n * setPromiseDebugState(true, promiseDebugLogger);\r\n *\r\n * // While the logger will not be called for the production packages\r\n * // Setting the `enabled` flag to tru will cause each promise to have\r\n * // the following additional properties added\r\n * // [[PromiseState]]; => Same as the `state` property\r\n * // [[PromiseResult]]; => The settled value\r\n * // [[PromiseIsHandled]] => Identifies if the promise has been handled\r\n * // It will also cause the `toString` for the promise to include additional\r\n * // debugging information\r\n * ```\r\n */\r\nexport function setPromiseDebugState(enabled, logger) {\r\n    _promiseDebugEnabled = enabled;\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _theLogger = logger;\r\n    //#endif\r\n}\r\n//# sourceMappingURL=debug.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { REJECTED } from \"./constants\";\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport var STRING_STATES = /*#__PURE__*/ [\r\n    \"pending\", \"resolving\", \"resolved\", REJECTED\r\n];\r\n//# sourceMappingURL=state.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { dumpObj, getDocument, getInst, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nvar DISPATCH_EVENT = \"dispatchEvent\";\r\nvar _hasInitEvent;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function to determine if the document has the `initEvent` function\r\n * @param doc - The document to check\r\n * @returns\r\n */\r\nfunction _hasInitEventFn(doc) {\r\n    var evt;\r\n    if (doc && doc.createEvent) {\r\n        evt = doc.createEvent(\"Event\");\r\n    }\r\n    return (!!evt && evt.initEvent);\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param target\r\n * @param evtName\r\n * @param populateEvent\r\n * @param useNewEvent\r\n */\r\nexport function emitEvent(target, evtName, populateEvent, useNewEvent) {\r\n    var doc = getDocument();\r\n    !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [doc]).v));\r\n    var theEvt = _hasInitEvent.v ? doc.createEvent(\"Event\") : (useNewEvent ? new Event(evtName) : {});\r\n    populateEvent && populateEvent(theEvt);\r\n    if (_hasInitEvent.v) {\r\n        theEvt.initEvent(evtName, false, true);\r\n    }\r\n    if (theEvt && target[DISPATCH_EVENT]) {\r\n        target[DISPATCH_EVENT](theEvt);\r\n    }\r\n    else {\r\n        var handler = target[\"on\" + evtName];\r\n        if (handler) {\r\n            handler(theEvt);\r\n        }\r\n        else {\r\n            var theConsole = getInst(\"console\");\r\n            theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, dumpObj(theEvt));\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=event.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined, throwTypeError, objToString, scheduleTimeout, getWindow, isNode, getGlobal, objDefine, objDefineProp, iterForOf, isIterable, isArray, arrForEach, createCachedValue, safe, getInst, createCustomError } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"./await\";\r\nimport { _addDebugState, _promiseDebugEnabled } from \"./debug\";\r\nimport { STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { REJECTED, STR_PROMISE } from \"../internal/constants\";\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"./debug\";\r\n//#endif\r\nvar NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nvar UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\nvar _currentPromiseId = [];\r\nvar _uniquePromiseId = 0;\r\nvar _unhandledRejectionTimeout = 10;\r\nvar _aggregationError;\r\nvar _hasPromiseRejectionEvent;\r\nfunction dumpFnObj(value) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n    return dumpObj(value);\r\n}\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) function _getCaller(prefix: string, start: number) {\r\n//#:(!DEBUG)     let stack = new Error().stack;\r\n//#:(!DEBUG)     if (stack) {\r\n//#:(!DEBUG)         let lines = stack.split(\"\\n\");\r\n//#:(!DEBUG)         if (lines.length > start) {\r\n//#:(!DEBUG)             return prefix + \":\" + arrSlice(lines, start, start + 5).join(\"\\n\") + \"\\n...\";\r\n//#:(!DEBUG)         }\r\n//#:(!DEBUG)     }\r\n//#:(!DEBUG)     return null;\r\n//#:(!DEBUG) }\r\n//#endif\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createAggregationError(values) {\r\n    !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, [\"AggregationError\"]).v || createCustomError(\"AggregationError\", function (self, args) {\r\n        self.errors = args[0];\r\n    })));\r\n    return new _aggregationError.v(values);\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise(newPromise, processor, executor) {\r\n    var additionalArgs = arrSlice(arguments, 3);\r\n    var _state = 0 /* ePromiseState.Pending */;\r\n    var _hasResolved = false;\r\n    var _settledValue;\r\n    var _queue = [];\r\n    var _id = _uniquePromiseId++;\r\n    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    var _handled = false;\r\n    var _unHandledRejectionHandler = null;\r\n    var _thePromise;\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    function _then(onResolved, onRejected) {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            var thenPromise = newPromise(function (resolve, reject) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _getCaller(\"_then\", 7));\r\n                //#endif\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        var handler = _state === 2 /* ePromiseState.Resolved */ ? onResolved : onRejected;\r\n                        var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve, reject);\r\n                        }\r\n                        else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value);\r\n                        }\r\n                        else if (_state === 3 /* ePromiseState.Rejected */) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        }\r\n                        else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n            return thenPromise;\r\n        }\r\n        finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    }\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    function _catch(onRejected) {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    }\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    function _finally(onFinally) {\r\n        var thenFinally = onFinally;\r\n        var catchFinally = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function (value) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            };\r\n            catchFinally = function (reason) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            };\r\n        }\r\n        return _then(thenFinally, catchFinally);\r\n    }\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n    function _processQueue() {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            var pending = _queue.slice();\r\n            _queue = [];\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n        }\r\n        else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    }\r\n    function _createSettleIfFn(newState, allowState) {\r\n        return function (theValue) {\r\n            if (_state === allowState) {\r\n                if (newState === 2 /* ePromiseState.Resolved */ && isPromiseLike(theValue)) {\r\n                    _state = 1 /* ePromiseState.Resolving */;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(_createSettleIfFn(2 /* ePromiseState.Resolved */, 1 /* ePromiseState.Resolving */), _createSettleIfFn(3 /* ePromiseState.Rejected */, 1 /* ePromiseState.Resolving */));\r\n                    return;\r\n                }\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === 3 /* ePromiseState.Rejected */ && !_unHandledRejectionHandler) {\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Setting up unhandled rejection\");\r\n                    //#endif\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);\r\n                }\r\n            }\r\n            else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    }\r\n    function _notifyUnhandledRejection() {\r\n        if (!_handled) {\r\n            // Mark as handled so we don't keep notifying\r\n            _handled = true;\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            }\r\n            else {\r\n                var gbl = getWindow() || getGlobal();\r\n                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe((getInst), [STR_PROMISE + \"RejectionEvent\"]).v));\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {\r\n                    objDefine(theEvt, \"promise\", { g: function () { return _thePromise; } });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    }\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    };\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, function () { return objToString(_settledValue); }, function () { return _handled; });\r\n    }\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol(11 /* WellKnownSymbols.toStringTag */)] = \"IPromise\";\r\n    }\r\n    var createStack;\r\n    //#if DEBUG\r\n    //#:(!{DEBUG}) createStack = _getCaller(\"Created\", 5);\r\n    //#endif\r\n    function _toString() {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\") + (createStack ? \" @ \" + createStack : \"\");\r\n    }\r\n    _thePromise.toString = _toString;\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n        var _rejectFn = _createSettleIfFn(3 /* ePromiseState.Rejected */, 0 /* ePromiseState.Pending */);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(_thePromise, _createSettleIfFn(2 /* ePromiseState.Resolved */, 0 /* ePromiseState.Pending */), _rejectFn);\r\n        }\r\n        catch (e) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Exception thrown: \" + dumpFnObj(e));\r\n            //#endif\r\n            _rejectFn(e);\r\n        }\r\n        //#ifdef DEBUG\r\n        //#:(!DEBUG) _debugLog(_toString(), \"~Executing\");\r\n        //#endif\r\n    })();\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllPromise(newPromise) {\r\n    return function (input) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            try {\r\n                var values_1 = [];\r\n                var pending_1 = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n                iterForOf(input, function (item, idx) {\r\n                    if (item) {\r\n                        pending_1++;\r\n                        doAwait(item, function (value) {\r\n                            // Set the result values\r\n                            values_1[idx] = value;\r\n                            if (--pending_1 === 0) {\r\n                                resolve(values_1);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n                // Now decrement the pending so that we finish correctly\r\n                pending_1--;\r\n                if (pending_1 === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values_1);\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createResolvedPromise(newPromise) {\r\n    return function (value) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike(value)) {\r\n            return value;\r\n        }\r\n        return newPromise(function (resolve) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Resolving Promise\");\r\n            //#endif\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRejectedPromise(newPromise) {\r\n    return function (reason) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (_resolve, reject) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Rejecting Promise\");\r\n            //#endif\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function which when called will return a new Promise object that resolves to an array of\r\n * IPromiseResults from the input promises. The returned promise will resolve when all of the inputs'\r\n * promises have resolved or rejected, or if the input contains no promises. It will resolve only after\r\n * all input promises have been fulfilled (resolve or rejected).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllSettledPromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var values = [];\r\n            var pending = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n            function processItem(item, idx) {\r\n                pending++;\r\n                doAwaitResponse(item, function (value) {\r\n                    if (value.rejected) {\r\n                        values[idx] = {\r\n                            status: REJECTED,\r\n                            reason: value.reason\r\n                        };\r\n                    }\r\n                    else {\r\n                        values[idx] = {\r\n                            status: \"fulfilled\",\r\n                            value: value.value\r\n                        };\r\n                    }\r\n                    if (--pending === 0) {\r\n                        resolve(values);\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise settles with the eventual state of the first promise that settles.\r\n * @description The returned promise is one of the promise concurrency methods. It's useful when you want\r\n * the first async task to complete, but do not care about its eventual state (i.e. it can either succeed\r\n * or fail).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the first promise to settle is fulfilled,\r\n * and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises,\r\n * the returned promise is still settled.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRacePromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var isDone = false;\r\n            function processItem(item) {\r\n                doAwaitResponse(item, function (value) {\r\n                    if (!isDone) {\r\n                        isDone = true;\r\n                        if (value.rejected) {\r\n                            reject(value.reason);\r\n                        }\r\n                        else {\r\n                            resolve(value.value);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment\r\n * value. It rejects when all of the input's promises reject (including when an empty iterable is passed),\r\n * with an AggregateError containing an array of rejection reasons.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the any of the input's promises fulfills,\r\n * with this first fulfillment value. It rejects when all of the input's promises reject (including when\r\n * an empty iterable is passed), with an AggregateError containing an array of rejection reasons.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAnyPromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var theErros = [];\r\n            var pending = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n            var isDone = false;\r\n            function processItem(item, idx) {\r\n                pending++;\r\n                doAwaitResponse(item, function (value) {\r\n                    if (!value.rejected) {\r\n                        isDone = true;\r\n                        resolve(value.value);\r\n                        return;\r\n                    }\r\n                    else {\r\n                        theErros[idx] = value.reason;\r\n                    }\r\n                    if (--pending === 0 && !isDone) {\r\n                        reject(_createAggregationError(theErros));\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0 && !isDone) {\r\n                    // All promises were either resolved or where not a promise\r\n                    reject(_createAggregationError(theErros));\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n//# sourceMappingURL=base.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrForEach, isNumber, scheduleIdleCallback, scheduleTimeout } from \"@nevware21/ts-utils\";\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items synchronously\r\n * @return An item processor\r\n */\r\nexport function syncItemProcessor(pending) {\r\n    arrForEach(pending, function (fn) {\r\n        try {\r\n            fn();\r\n        }\r\n        catch (e) {\r\n            // Don't let 1 failing handler break all others\r\n            // TODO: Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n        }\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items asynchronously using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function timeoutItemProcessor(timeout) {\r\n    var callbackTimeout = isNumber(timeout) ? timeout : 0;\r\n    return function (pending) {\r\n        scheduleTimeout(function () {\r\n            syncItemProcessor(pending);\r\n        }, callbackTimeout);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items using an idle callback (if available) or based on\r\n * a timeout (when `requestIdenCallback` is not supported) using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function idleItemProcessor(timeout) {\r\n    var options;\r\n    if (timeout >= 0) {\r\n        options = {\r\n            timeout: +timeout\r\n        };\r\n    }\r\n    return function (pending) {\r\n        scheduleIdleCallback(function (deadline) {\r\n            syncItemProcessor(pending);\r\n        }, options);\r\n    };\r\n}\r\n//# sourceMappingURL=itemProcessor.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { timeoutItemProcessor } from \"./itemProcessor\";\r\nvar _allAsyncSettledCreator;\r\nvar _raceAsyncCreator;\r\nvar _anyAsyncCreator;\r\n/**\r\n * Creates an asynchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the optional provided timeout value to schedule when the chained items will be ececuted.\r\n * @group Async\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createAsyncPromise(executor, timeout) {\r\n    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createAsyncAllPromise = /*#__PURE__*/ _createAllPromise(createAsyncPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createAsyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createAsyncPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createAsyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createAsyncPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise Aasynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise(input, timeout) {\r\n    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));\r\n    return _allAsyncSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function createAsyncRacePromise(values, timeout) {\r\n    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));\r\n    return _raceAsyncCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createAsyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise(values, timeout) {\r\n    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));\r\n    return _anyAsyncCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=asyncPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createAsyncPromise } from \"./asyncPromise\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { STRING_STATES } from \"../internal/state\";\r\nimport { dumpObj, isFunction, objDefineProp, throwTypeError, getInst, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\n/**\r\n * @internal\r\n * @ignore\r\n * Flag to determine if the native Promise class should be used if available, used for testing purposes.\r\n */\r\nvar _useNative = true;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the native Promise class\r\n */\r\nvar _promiseCls;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.all` method\r\n */\r\nvar _allCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.allSettled` method\r\n */\r\nvar _allNativeSettledCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.race` method\r\n */\r\nvar _raceNativeCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.any` method\r\n */\r\nvar _anyNativeCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Test Hook function to clear the cached values and set whether to use the native Promise class\r\n * @param useNative\r\n */\r\nexport function _clearPromiseCache(useNative) {\r\n    //#ifdef _DEBUG\r\n    //#:(!_DEBUG)     _useNative = !!useNative;\r\n    //#:(!_DEBUG)     _promiseCls = null as any;\r\n    //#:(!_DEBUG)     _allCreator = null as any;\r\n    //#:(!_DEBUG)     _allNativeSettledCreator = null as any;\r\n    //#:(!_DEBUG)     _raceNativeCreator = null as any;\r\n    //#:(!_DEBUG)     _anyNativeCreator = null as any;\r\n    //#endif\r\n}\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createNativePromiseHelper(name, func) {\r\n    !_promiseCls && (_promiseCls = createCachedValue((_useNative && safe(getInst, [STR_PROMISE]).v) || null));\r\n    if (_promiseCls.v && _promiseCls.v[name]) {\r\n        return createCachedValue(function (input, timeout) {\r\n            return createNativePromise(function (resolve, reject) {\r\n                _promiseCls.v[name](input).then(resolve, reject);\r\n            });\r\n        });\r\n    }\r\n    return func();\r\n}\r\n/**\r\n * Creates a Promise instance that when resolved or rejected will execute it's pending chained operations using the\r\n * available native Promise implementation.\r\n * If runtime does not support native `Promise` class (or no polyfill is available) this function will fallback to using\r\n * `createAsyncPromise` which will resolve them __asynchronously__ using the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * @group Alias\r\n * @group Promise\r\n * @group Native\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createNativePromise(executor, timeout) {\r\n    !_promiseCls && (_promiseCls = createCachedValue((_useNative && safe(getInst, [STR_PROMISE]).v) || null));\r\n    var PrmCls = _promiseCls.v;\r\n    if (!PrmCls) {\r\n        return createAsyncPromise(executor);\r\n    }\r\n    if (!isFunction(executor)) {\r\n        throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpObj(executor));\r\n    }\r\n    var _state = 0 /* ePromiseState.Pending */;\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n    var thePromise = new PrmCls(function (resolve, reject) {\r\n        function _resolve(value) {\r\n            _state = 2 /* ePromiseState.Resolved */;\r\n            resolve(value);\r\n        }\r\n        function _reject(reason) {\r\n            _state = 3 /* ePromiseState.Rejected */;\r\n            reject(reason);\r\n        }\r\n        executor(_resolve, _reject);\r\n    });\r\n    objDefineProp(thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n    return thePromise;\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @group Native\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport function createNativeAllPromise(input, timeout) {\r\n    !_allCreator && (_allCreator = _createNativePromiseHelper(\"all\", function () { return createCachedValue(_createAllPromise(createNativePromise)); }));\r\n    return _allCreator.v(input, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @group Native\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createNativeResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createNativePromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @group Native\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createNativeRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createNativePromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise(input, timeout) {\r\n    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper(\"allSettled\", function () { return _createAllSettledPromise(createNativePromise); }));\r\n    return _allNativeSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function createNativeRacePromise(values, timeout) {\r\n    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper(\"race\", function () { return _createRacePromise(createNativePromise); }));\r\n    return _raceNativeCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createNativeAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise(values, timeout) {\r\n    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper(\"any\", function () { return _createAnyPromise(createNativePromise); }));\r\n    return _anyNativeCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=nativePromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { syncItemProcessor } from \"./itemProcessor\";\r\nvar _allSyncSettledCreator;\r\nvar _raceSyncCreator;\r\nvar _anySyncCreator;\r\n/**\r\n * Creates a synchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __synchronously__ in the same execution cycle as the operation that calls the `executors`, `resolve` or `reject` functions.\r\n *\r\n * @group Synchronous\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n */\r\nexport function createSyncPromise(executor) {\r\n    return _createPromise(createSyncPromise, syncItemProcessor, executor);\r\n}\r\n/**\r\n * Returns a single synchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __synchronously__ in the same\r\n * execution cycle as the final operation pending promises have resolved, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __synchronously__ at the point of\r\n * being added (eg. `then()`; `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createSyncAllPromise = /*#__PURE__*/ _createAllPromise(createSyncPromise);\r\n/**\r\n * Returns a single synchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new synchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __synchronously__ at the point of being\r\n * added (calling `then()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n */\r\nexport var createSyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createSyncPromise);\r\n/**\r\n * Returns a single synchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __synchronously__ at the point of being added (eg. `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n */\r\nexport var createSyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createSyncPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createSyncPromise synchronous} promise implementation. Any chained operations will execute\r\n * __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createSyncAllSettledPromise(input, timeout) {\r\n    !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));\r\n    return _allSyncSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createSyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createSyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * synchronously.\r\n */\r\nexport function createSyncRacePromise(values, timeout) {\r\n    !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));\r\n    return _raceSyncCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createSyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createSyncAnyPromise(values, timeout) {\r\n    !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));\r\n    return _anySyncCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=syncPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isUndefined } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { idleItemProcessor } from \"./itemProcessor\";\r\nvar _defaultIdleTimeout;\r\nvar _allIdleSettledCreator;\r\nvar _raceIdleCreator;\r\nvar _anyIdleCreator;\r\n/**\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport function setDefaultIdlePromiseTimeout(idleDeadline) {\r\n    _defaultIdleTimeout = idleDeadline;\r\n}\r\n/**\r\n * @deprecated Use `setDefaultIdlePromiseTimeout` instead\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport var setDefaultIdleTimeout = ( /*#__PURE__*/setDefaultIdlePromiseTimeout);\r\n/**\r\n * Creates an idle Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed. When `requestIdleCallback` is not available this becomes the same as\r\n * `createAsyncPromise` which uses `setTimeout` to schedule executions.\r\n * @group Idle\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional deadline timeout to wait before processing the items, defaults to undefined. If the number of\r\n * milliseconds represented by this parameter has elapsed and the callback has not already been called, then a task to execute\r\n * the callback is queued in the event loop (even if doing so risks causing a negative performance impact). timeout must be a\r\n * positive value or it is ignored.\r\n */\r\nexport function createIdlePromise(executor, timeout) {\r\n    var theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;\r\n    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);\r\n}\r\n/**\r\n * Returns an idle Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__\r\n * using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using\r\n * the `requestIdleCallback` API (if available) with the optional provided timeout value to schedule\r\n * when the chained items will be executed. (eg. `then()`; `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createIdleAllPromise = /*#__PURE__*/ _createAllPromise(createIdlePromise);\r\n/**\r\n * Returns an idle Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the\r\n * `requestIdleCallback` API (if available) with the optional provided timeout value to schedule when\r\n * the chained items will be executed. (eg. `then()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createIdleResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createIdlePromise);\r\n/**\r\n * Returns an idle Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the o`requestIdleCallback` API\r\n * (if available) with the optional provided timeout value to schedule when the chained items will\r\n * be executed. (eg. `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createIdleRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createIdlePromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createIdlePromise idle} promise implementation. Any chained operations will execute\r\n * __asynchronously__ when the environment is idle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createIdleAllSettledPromise(input, timeout) {\r\n    !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));\r\n    return _allIdleSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createIdleRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createIdleRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously when the system detects that the runtime is idle.\r\n */\r\nexport function createIdleRacePromise(values, timeout) {\r\n    !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));\r\n    return _raceIdleCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createIdleAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createIdleAnyPromise(values, timeout) {\r\n    !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));\r\n    return _anyIdleCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=idlePromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createCachedValue } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { createNativePromise } from \"./nativePromise\";\r\nvar _promiseCreator;\r\nvar _allSettledCreator;\r\nvar _raceCreator;\r\nvar _anyCreator;\r\n/**\r\n * Set the default promise implementation to use when calling `createPromise`; `createAllPromise`; `createResolvedPromise`\r\n * and `createRejectedPromise`. This is effective a global value and changing this will affect ALL callers of these\r\n * functions, as such these functions should only be used when switching implementations would have not unexpected\r\n * consequences like switching from a `createSyncPromise` to `createIdlePromise` where idle promises have a possibility\r\n * of never getting called during application shutdown or during an expected timeframe.\r\n * @group Alias\r\n * @group Promise\r\n * @param creator - The creator function to call when a new promise is required.\r\n */\r\nexport function setCreatePromiseImpl(creator) {\r\n    _promiseCreator = creator ? createCachedValue(creator) : null;\r\n}\r\n/**\r\n * Creates a Promise instance using the current default promise creator that when resolved or rejected will execute\r\n * it's pending chained operations.\r\n * @group Alias\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - [Optional] timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createPromise(executor, timeout) {\r\n    !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));\r\n    return _promiseCreator.v.call(this, executor, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createAllPromise = /*#__PURE__*/ _createAllPromise(createPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the current\r\n * promise implementation. If the current implementation is synchronous then the chained operations will\r\n * execute __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. If the current implementation is asynchronous then the chained\r\n * operations will execute __asynchronously__ using the optional provided timeout value to schedule when the\r\n * chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAllSettledPromise(input, timeout) {\r\n    !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));\r\n    return _allSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * based on the current promise implementation.\r\n */\r\nexport function createRacePromise(values, timeout) {\r\n    !_raceCreator && (_raceCreator = _createRacePromise(createPromise));\r\n    return _raceCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAnyPromise(values, timeout) {\r\n    !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));\r\n    return _anyCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=promise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isUndefined, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { createPromise } from \"./promise\";\r\n/**\r\n * Creates a Promise instance that resolve or reject after the specified timeout.\r\n * @since 0.5.0\r\n * @group Timeout\r\n * @group Promise\r\n * @param timeout - The timeout in milliseconds to wait before resolving or rejecting the promise.\r\n * @param resolveReject - [Optional] If true the promise will resolve, otherwise it will reject.\r\n * @param message - [Optional] The message to use when rejecting the promise, if not supplied (or\r\n * undefined) the default message will be used.\r\n * @returns A promise that will resolve or reject after the specified timeout.\r\n * @example\r\n * ```ts\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100);\r\n * // Throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100, false);\r\n * // throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, false, \"Hello\");\r\n * // throws an Error: Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, true, \"Hello\");\r\n * console.log(result); // Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, true, \"Hello\"), (result) => {\r\n *  console.log(result); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   // Not called\r\n * }, (err) => {\r\n *   console.log(err); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwaitResult(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   console.log(result.rejected); // true\r\n *   console.log(result.reason); // Hello\r\n * });\r\n * ```\r\n */\r\nexport function createTimeoutPromise(timeout, resolveReject, message) {\r\n    return createPromise(function (resolve, reject) {\r\n        scheduleTimeout(function () {\r\n            (resolveReject ? resolve : reject)(!isUndefined(message) ? message : \"Timeout of \" + timeout + \"ms exceeded\");\r\n        }, timeout);\r\n    });\r\n}\r\n//# sourceMappingURL=timeoutPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isFunction, isPromiseLike, utcNow } from \"@nevware21/ts-utils\";\r\nimport { createPromise } from \"../promise/promise\";\r\nimport { doAwait } from \"../promise/await\";\r\nfunction _doneChk(isDone, state, value, thisArg) {\r\n    var result = isDone;\r\n    state.res = value;\r\n    if (!result) {\r\n        if (state.isDone && isFunction(state.isDone)) {\r\n            // Handle synchronous or asynchronous isDone function\r\n            return doAwait(state.isDone.call(thisArg, state), function (done) {\r\n                state.iter++;\r\n                return !!done;\r\n            });\r\n        }\r\n        else {\r\n            result = !!state.isDone;\r\n        }\r\n    }\r\n    state.iter++;\r\n    return result;\r\n}\r\n/**\r\n * Performs a while loop, calling the provided `callbackFn` function until the `state.isDone`\r\n * property is set to `true` or the optional `isDOneFn` returns `true`. The callback function will\r\n * receive a single {@link IWhileState state} argument and may return either a value or a promise,\r\n * if a promise is returned the while loop will wait until the promise is resolved before calling\r\n * the callback function again. If the callback function never returns a promise the while loop\r\n * will be executed synchronous and last value returned by the callback will be returned, if the\r\n * callback function returns a promise the while loop will be asynchronous and an {@link IPromise}\r\n * will be returned and resolved with the last value returned by the callback or rejected if the\r\n * callback promise rejects or throws an error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @typeParam T - Identifies the element type returned by the callback function.\r\n * @param callbackFn A function that will be called until the `state.isDone` flag is set to `true`\r\n * the function will receive a single {@link IWhileState state} argument. The callback function\r\n * may return either a value or a promise, if a promise is returned the while loop will wait\r\n * until the promise is resolved before calling the callback function again.\r\n * @param isDoneFn An optional function that will be called after the callback function is called,\r\n * that can be used to stop the while loop. The function will receive a single {@link IWhileState state}\r\n * argument. If the function returns `true` the while loop will stop, otherwise the while loop will continue.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n * If thisArg is omitted, null or undefined the array will be used as the this value.\r\n * @remarks\r\n * - If an `isDoneFn` is provided the `state.isDone` property will be set to the provided value and\r\n * is accessible withing the callback function. The callbackFn may overwrite the value of the\r\n * `state.isDone` property within the callback function with a boolean value or another function that\r\n * returns a boolean value.\r\n * - The callback function is called until until the `state.isDone` property is set to `true` or if\r\n * `state.isDone` is a function until the function returns `true.\r\n * - The callback function will receive a single {@link IWhileState state} argument that contains\r\n * the following properties:\r\n *  - `iter` - The zero-based iteration count, which is incremented after each call to the `callbackFn`\r\n * and any `isDone` function (if provided), the `iter` property is accessible withing the callback\r\n * function and may be overwritten within the callback function.\r\n * - `res` - The last resolved result value returned by the `callbackFn` function.\r\n * - `isDone` - A boolean value or a callback function that will be called to check if the while loop\r\n * should stop, the `isDone` property is accessible withing the callback function and may be\r\n * overwritten within the callback function.\r\n * - The callback function may return either a value or a promise, if a promise is returned the while\r\n * loop will wait until the promise is resolved before calling the callback function again.\r\n * - If the callback function throws an error when executing `synchronously` the exception will\r\n * also be thrown `synchronously` otherwise the returned promise will be rejected with the error.\r\n * @example\r\n * ```ts\r\n * // Synchronous example\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     return \"Hello\";\r\n *  }\r\n * });\r\n *\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Synchronous example with isDoneFn\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     return \"Hello\";\r\n *  }\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Asynchronous examples\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   state.isDone = true;\r\n *   return createResolvedPromise(\"Darkness\");\r\n * });\r\n * console.log(result); // Darkness\r\n *\r\n * // Asynchronous example with isDoneFn\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   return createResolvedPromise(\"Darkness\");\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Darkness after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Combination Synchronous and Asynchronous example\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await\r\n * const result = await doWhileAsync(async (state) => {\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await and dynamically setting the isDone function\r\n * const result = await doWhileAsync(async (state) => {\r\n *   // dynamically set the isDone function\r\n *   if (state.idx < 10) {\r\n *     state.isDone = () => return false;\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = () => return true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n * ```\r\n */\r\nexport function doWhileAsync(callbackFn, isDoneFn, thisArg) {\r\n    var promise;\r\n    var resolve;\r\n    var reject = function (reason) {\r\n        isDone = true;\r\n        throw reason;\r\n    };\r\n    var isDone = false;\r\n    var state = {\r\n        st: utcNow(),\r\n        iter: 0,\r\n        isDone: isDoneFn || false\r\n    };\r\n    if (callbackFn) {\r\n        var _createPromise_1 = function () {\r\n            return createPromise(function (res, rej) {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n        };\r\n        var _handleAsyncDone_1 = function (done) {\r\n            isDone = !!done;\r\n            if (!isDone) {\r\n                _processNext_1();\r\n            }\r\n            else {\r\n                resolve(state.res);\r\n            }\r\n        };\r\n        var _processNext_1 = function () {\r\n            // Attempt to process the next item synchronously if possible (for performance -- to reduce the number of promises created)\r\n            while (!isDone) {\r\n                try {\r\n                    var cbResult = callbackFn.call(thisArg, state);\r\n                    if (isPromiseLike(cbResult)) {\r\n                        promise = promise || _createPromise_1();\r\n                        doAwait(cbResult, function (res) {\r\n                            try {\r\n                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone_1, reject);\r\n                            }\r\n                            catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        }, reject);\r\n                        // Break out of synchronous loop and wait for promise to resolve\r\n                        return promise;\r\n                    }\r\n                    else {\r\n                        var dnRes = _doneChk(isDone, state, cbResult, thisArg);\r\n                        if (isPromiseLike(dnRes)) {\r\n                            promise = promise || _createPromise_1();\r\n                            doAwait(dnRes, _handleAsyncDone_1, reject);\r\n                            // Break out of synchronous loop and wait for promise to resolve\r\n                            return promise;\r\n                        }\r\n                        else {\r\n                            isDone = !!dnRes;\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                    return promise;\r\n                }\r\n            }\r\n            if (isDone && resolve) {\r\n                resolve(state.res);\r\n            }\r\n            return promise || state.res;\r\n        };\r\n        return _processNext_1();\r\n    }\r\n}\r\n//# sourceMappingURL=doWhileAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { getLength } from \"@nevware21/ts-utils\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in an array (or ArratLike) instance in ascending index order. It is not invoked\r\n * for index properties that have been deleted or are uninitialized. And unlike the ES6 forEach() this supports async functions and you CAN stop\r\n * or break the iteration  by returning -1 from the `callbackFn` function.\r\n *\r\n * The range (number of elements) processed by arrForEach() is set before the first call to the `callbackFn`. Any elements added beyond the range\r\n * or elements which as assigned to indexes already processed will not be visited by the `callbackFn`.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise` then the next iteration will not be\r\n * called until the promise is resolved. If the `callbackFn` returns a `Promise` that is rejected then the iteration will stop and the promise\r\n * returned by arrForEachAsync will be rejected with the same error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the element type of the array\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A `asynchronous` or `synchronous` function that accepts up to three arguments. arrForEach calls the callbackfn function one\r\n * time for each element in the array.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the array will be used as the this value.\r\n * @remarks\r\n * arrForEachAsync supports either a `synchronous` or `asynchronous` (returns a `Promise`) callback function. If the callback function returns\r\n * a `Promise` then the next iteration will not be called until the promise is resolved. If the callback function returns a `Promise` that is\r\n * rejected then the iteration will stop and the promise returned by arrForEachAsync will be rejected with the same error.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * arrForEachASync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * // Also supports input as an array like object\r\n * const items = { length: 3, 0: 'item1', 1: 'item2', 2: 'item3' };\r\n *\r\n * // Asynchronous examples using await\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * await arrForEachASync(items, (value, index) => { // Note: DO NOT use async here unless you use await within the function\r\n *   if (index < 5) {\r\n *     // Logs each iteration index\r\n *     // Logs each value\r\n *     console.log(value);\r\n *     // Returning a promise will cause `arrForEachAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true);\r\n *   }\r\n *\r\n *   return -1; // Stop the iteration\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * ```\r\n */\r\nexport function arrForEachAsync(theArray, callbackFn, thisArg) {\r\n    if (theArray) {\r\n        var len_1 = getLength(theArray);\r\n        if (len_1) {\r\n            var isDone = function (state) {\r\n                if (state.iter >= len_1 || state.res === -1) {\r\n                    return true;\r\n                }\r\n            };\r\n            return doWhileAsync(function (state) {\r\n                var idx = state.iter;\r\n                if (idx in theArray) {\r\n                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);\r\n                }\r\n            }, isDone);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=arrForEachAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createCachedValue, fnCall, getKnownSymbol, isIterator, isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { DONE, RETURN, VALUE } from \"../internal/constants\";\r\nimport { doAwait, doFinally } from \"../promise/await\";\r\nvar _iterSymbol;\r\nvar _iterAsyncSymbol;\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in the iterator or iterator returned by\r\n * the iterable and processed in the same order as returned by the iterator. As with the {@link arrForEachAsync}\r\n * you CAN stop or break the iteration by returning -1 from the `callbackFn` function.\r\n *\r\n * The order of processing is not reset if you add or remove elemenets to the iterator, the actual behavior will\r\n * depend on the iterator implementation.\r\n *\r\n * if the passed `iter` is both an Iterable<T> and Iterator<T> the Iterator<T> interface takes precedence. And if\r\n * an iterable and does not have a `Symbol.iterator` property then the `iter` will be used as the iterator.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise`\r\n * then the next iteration will not be called until the promise is resolved. If the `callbackFn` returns a `Promise`\r\n * that is rejected then the iteration will stop and the promise returned by iterForEachAsync will be rejected with\r\n * the same error.\r\n * @remarks\r\n * If Symbols are NOT supported then the iterable MUST be using the same polyFill for the well know symbols, as used\r\n * by the library. If the iterable is using a different polyFill then the `iter` MUST be an Iterator<T> and not an\r\n * Iterable<T>.\r\n * If you are targetting a mixed environment you SHOULD either\r\n * - only use the polyfill Symbol's provided by this library\r\n * - ensure that you add any symbol polyfills BEFORE these utilities\r\n * iterForOfAsync\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the iterator\r\n * @param iter - The iterator or iterable of elements to be searched.\r\n * @param callbackFn - A `asynchronous` or `synchronous` function that accepts up to three arguments. iterForEach\r\n * calls the callbackfn function one time for each element in the iterator.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted,\r\n * null or undefined the iterator will be used as the this value.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * // using async / await\r\n * let result = await iterForOfAsync(items, async (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   await createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  })\r\n *\r\n * console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *\r\n * // using doAwait\r\n * doAwait(iterForOfAsync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   return createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  }), (result) => {\r\n *    console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *  });\r\n */\r\nexport function iterForOfAsync(iter, callbackFn, thisArg) {\r\n    var err;\r\n    var iterResult;\r\n    var theIter = iter;\r\n    function onFailed(failed) {\r\n        err = { e: failed };\r\n        if (theIter.throw) {\r\n            iterResult = null;\r\n            theIter.throw(err);\r\n        }\r\n        throw failed;\r\n    }\r\n    function onFinally() {\r\n        try {\r\n            if (iterResult && !iterResult[DONE]) {\r\n                theIter[RETURN] && theIter[RETURN](iterResult);\r\n            }\r\n        }\r\n        finally {\r\n            if (err) {\r\n                // eslint-disable-next-line no-unsafe-finally\r\n                throw err.e;\r\n            }\r\n        }\r\n    }\r\n    if (iter) {\r\n        if (!isIterator(iter)) {\r\n            // Get the asyncIterator from the iterable\r\n            !_iterAsyncSymbol && (_iterAsyncSymbol = createCachedValue(getKnownSymbol(0 /* WellKnownSymbols.asyncIterator */)));\r\n            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;\r\n            if (!theIter) {\r\n                // Get the iterator from the iterable\r\n                !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(3 /* WellKnownSymbols.iterator */)));\r\n                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\r\n            }\r\n        }\r\n        if (theIter && isIterator(theIter)) {\r\n            var result = void 0;\r\n            try {\r\n                result = doWhileAsync(function (state) {\r\n                    return doAwait(theIter.next(), function (res) {\r\n                        iterResult = res;\r\n                        if (!res[DONE]) {\r\n                            return fnCall(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);\r\n                        }\r\n                    }, function (reason) {\r\n                        state.isDone = true;\r\n                        onFailed(reason);\r\n                    });\r\n                }, function (state) {\r\n                    if (!iterResult || iterResult[DONE] || state.res === -1) {\r\n                        onFinally();\r\n                        return true;\r\n                    }\r\n                }, thisArg || theIter);\r\n                if (isPromiseLike(result)) {\r\n                    result = doFinally(result.catch(onFailed), onFinally);\r\n                }\r\n                return result;\r\n            }\r\n            catch (failed) {\r\n                onFailed(failed);\r\n            }\r\n            finally {\r\n                if (result && !isPromiseLike(result)) {\r\n                    onFinally();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=iterForOfAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrForEach, arrIndexOf, createCustomError, getLength, isPromiseLike, objDefine, objDefineProp, scheduleTimeout, utcNow } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"../promise/await\";\r\nimport { createPromise } from \"../promise/promise\";\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"../promise/debug\";\r\n//#endif\r\nvar REJECT = \"reject\";\r\nvar REJECTED_ERROR = \"Rejected\";\r\nvar _schedulerId = 0;\r\nvar _debugName;\r\nvar _debugIntState;\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nvar _customErrors = {};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Empty reject function to avoid trying to re-reject\r\n */\r\nfunction _rejectDone() {\r\n    // A Do nothing function\r\n}\r\nfunction _createError(type, evt, message) {\r\n    // Lazily create the class\r\n    !_customErrors[type] && (_customErrors[type] = createCustomError(type));\r\n    var now = utcNow();\r\n    return new (_customErrors[type])(\"Task [\".concat(evt.id, \"] \").concat(message || \"\", \"- \").concat((evt.st ? \"Running\" : \"Waiting\"), \": \").concat(_calcTime(now, evt.st || evt.cr)));\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function used for displaying the time in milliseconds (during debugging)\r\n * @param now - The current time\r\n * @param start - The start time to subtract\r\n * @returns A string representation of the time difference\r\n */\r\nfunction _calcTime(now, start) {\r\n    return ((now - start) || \"0\") + \" ms\";\r\n}\r\n/**\r\n * Abort any stale tasks in the provided task Queue\r\n * @param taskQueue - The Task Queue to search\r\n * @param staleTimeoutPeriod - The maxumum stale timeout period\r\n */\r\nfunction _abortStaleTasks(taskQueue, staleTimeoutPeriod) {\r\n    var now = utcNow();\r\n    var expired = now - staleTimeoutPeriod;\r\n    arrForEach(taskQueue, function (evt) {\r\n        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {\r\n            evt && evt[REJECT](evt.rj || _createError(\"Aborted\", evt, \"Stale \"));\r\n        }\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Remove the `taskDetail` from the `queue` if present\r\n * @param queue - The Task Queue\r\n * @param taskDetail - The Task detail to be removed\r\n */\r\nfunction _removeTask(queue, taskDetail) {\r\n    var idx = arrIndexOf(queue, taskDetail);\r\n    if (idx !== -1) {\r\n        queue.splice(idx, 1);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n * @ignore Internal function to add the debug state to the promise, this code is removed from the production artifacts\r\n * @param theScheduler - The scheduler instance to add the debug accessors to.\r\n * @param nameFn - The function to return then name of this scheduler\r\n * @param stateFn - The function to return the internal state of the scheduler\r\n */\r\nfunction _addDebugState(theScheduler, nameFn, stateFn) {\r\n    _debugName = _debugName || { toString: function () { return \"[[SchedulerName]]\"; } };\r\n    _debugIntState = _debugIntState || { toString: function () { return \"[[SchedulerState]]\"; } };\r\n    objDefineProp(theScheduler, _debugName, { get: nameFn });\r\n    objDefineProp(theScheduler, _debugIntState, { get: stateFn });\r\n}\r\n/**\r\n * Create a Task Scheduler using the optional promise implementation and scheduler name.\r\n * The newPromise can be any value promise creation function, where the execution of the\r\n * queued tasks will be processed based on how the promise implementation processes it's\r\n * chained promises (asynchrounsly; synchronously; idle processing, etc)\r\n *\r\n * The functions used to start each task my return a result (synchronous execution) or an\r\n * {@link IPromise}, `PromiseLike` or `Promise` result (asynchronous execution).\r\n *\r\n * Each task is executed in the order that it was queued and the provided `startTask` function\r\n * will not be called until all previous tasks have completed (whther they resolve or reject).\r\n * The result from any previous task does not affect and is not passed to any later scheduled\r\n * task, if you need this capability then your `startTask` functions will need to co-operate to\r\n * share any common context.\r\n *\r\n * By default, queued tasks which have either been \"waiting\" to run or have been running longer\r\n * then 10 minutes will be Auto-Rejected to try and free up resources. If a task is running when\r\n * it rejected then it will continue to \"run\" based on whatever operation it's `startTask` is\r\n * performing. If a task has not yet had it's `startTask` function called it will never get called.\r\n * In both cases the `IPromise` returned by the call to {@link ITaskScheduler.queue | queue} the\r\n * task will be `rejected`. You can change this default time, including disabling completly via\r\n * the {@link ITaskScheduler.setStaleTimeout | setStaleTimeout}\r\n * function.\r\n * @since 0.2.0\r\n * @group Scheduler\r\n * @param newPromise - The function to use for creating a new promise when required, if not\r\n * provided this will default to {@link createPromise} which will use the default registered\r\n * promise creation function which defaults to runtime native promises or async Promise if not\r\n * supported by the runtime.\r\n * @param name - The name you want to associated with this scheduler, mostly useful for debugging\r\n * @returns A new ITaskScheduler instance\r\n * @example\r\n * ```ts\r\n * let scheduler = createTaskScheduler();\r\n *\r\n * // Schedule a task using the ts-async helper promise functions\r\n * scheduler.queue(() => {\r\n *     return createPromise((resolve, reject) => {\r\n *         scheduleTimeout(() => {\r\n *             // Do something after a delay\r\n *         }, 100);\r\n *     });\r\n * });\r\n *\r\n * // Schedule an asynchronous task which uses async/await\r\n * scheduler.queue(async () => {\r\n *     // This task will only execute after the previous task has completed\r\n *     await performAnotherAsyncTask();\r\n * });\r\n *\r\n * // Schedule a synchronous task that executes and completes immediately\r\n * scheduled.queue(() => {\r\n *     // Do some synchronous task\r\n *     return 42;\r\n * });\r\n *\r\n * // Schedule an asynchronous task which returns a promise\r\n * scheduled.queue(() => {\r\n *     return doAwait(fetch(\"https://github.com/nevware21/ts-async/blob/main/README.md\"), (response) => {\r\n *         let theReadMe = response.text();\r\n *         // Do something with the readme\r\n *     });\r\n * });\r\n * ```\r\n */\r\nexport function createTaskScheduler(newPromise, name) {\r\n    var _theTask;\r\n    var _running = [];\r\n    var _waiting = [];\r\n    var _staleTimeoutPeriod = 600000; // 10 Minutes\r\n    var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10; // 1 Minute\r\n    var _taskCount = 0;\r\n    var _schedulerName = (name ? (name + \".\") : \"\") + _schedulerId++;\r\n    var _blockedTimer;\r\n    // Make sure that a promise creator has been assigned\r\n    newPromise = newPromise || createPromise;\r\n    var _startBlockedTimer = function () {\r\n        var hasTasks = (getLength(_running) + getLength(_waiting)) > 0;\r\n        if (_staleTimeoutPeriod > 0) {\r\n            if (!_blockedTimer) {\r\n                // Only attempt to drop stale / blocked tasks if the timeout period is defined\r\n                _blockedTimer = scheduleTimeout(function () {\r\n                    _abortStaleTasks(_running, _staleTimeoutPeriod);\r\n                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);\r\n                    _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));\r\n                }, _staleTimeoutCheckPeriod);\r\n                _blockedTimer.unref();\r\n            }\r\n            _blockedTimer && (_blockedTimer.enabled = hasTasks);\r\n        }\r\n        else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"Stale Timer disabled\");\r\n            //#endif\r\n        }\r\n    };\r\n    var _queueTask = function (startAction, taskName, timeout) {\r\n        var _a;\r\n        var taskId = _schedulerName + \".\" + _taskCount++;\r\n        if (taskName) {\r\n            taskId += \"-(\" + taskName + \")\";\r\n        }\r\n        var newTask = (_a = {\r\n                id: taskId,\r\n                cr: utcNow(),\r\n                to: timeout\r\n            },\r\n            _a[REJECT] = function (reason) {\r\n                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);\r\n                newTask[REJECT] = _rejectDone;\r\n            },\r\n            _a);\r\n        if (!_theTask) {\r\n            // We don't have any currently running task, so just start the next task\r\n            newTask.p = newPromise(_runTask(newTask, startAction));\r\n        }\r\n        else {\r\n            // Start a new promise which will wait until all current active tasks are completed before starting\r\n            // the new task, it does not resolve this scheduled task until after the new task is resolve to\r\n            // ensure that all scheduled tasks are completed in the correct order\r\n            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);\r\n        }\r\n        // Set this new task as the last one, so that any future tasks will wait for this one\r\n        _theTask = newTask;\r\n        return newTask.p;\r\n    };\r\n    var _runTask = function (taskDetail, startAction) {\r\n        taskDetail.st = utcNow();\r\n        // There should only ever be a single \"running\" task, but using an array\r\n        // for code reuse.\r\n        _running.push(taskDetail);\r\n        _startBlockedTimer();\r\n        // Create and return the promise executor for this action\r\n        return function (onTaskResolve, onTaskReject) {\r\n            var _promiseReject = function (reason) {\r\n                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);\r\n                taskDetail[REJECT] = _rejectDone;\r\n                _doCleanup(taskDetail);\r\n                onTaskResolve = null;\r\n                onTaskReject && onTaskReject(reason);\r\n                onTaskReject = null;\r\n            };\r\n            var taskId = taskDetail.id;\r\n            if (taskDetail.rj) {\r\n                // Already aborted / pre-rejected\r\n                _promiseReject(taskDetail.rj);\r\n            }\r\n            else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_schedulerName, \"Task [\" + taskId + \"] Started after \" + _calcTime(taskDetail.st, taskDetail.cr));\r\n                //#endif\r\n                taskDetail[REJECT] = _promiseReject;\r\n                try {\r\n                    var startResult = startAction(taskId);\r\n                    if (taskDetail.to && isPromiseLike(startResult)) {\r\n                        taskDetail.t = scheduleTimeout(function () {\r\n                            _promiseReject(_createError(\"Timeout\", taskDetail));\r\n                        }, taskDetail.to);\r\n                    }\r\n                    doAwait(startResult, function (theResult) {\r\n                        _doCleanup(taskDetail);\r\n                        try {\r\n                            onTaskResolve && onTaskResolve(theResult);\r\n                        }\r\n                        catch (e) {\r\n                            onTaskReject && onTaskReject(e);\r\n                        }\r\n                        onTaskReject = null;\r\n                        onTaskResolve = null;\r\n                    }, _promiseReject);\r\n                }\r\n                catch (e) {\r\n                    _promiseReject(e);\r\n                }\r\n            }\r\n        };\r\n    };\r\n    var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {\r\n        _waiting.push(taskDetail);\r\n        _startBlockedTimer();\r\n        return newPromise(function (onWaitResolve, onWaitReject) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) let taskId = taskDetail.id;\r\n            //#:(!DEBUG) let prevTaskId = prevTask.id;\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"[\" + taskId + \"] is waiting for [\" + prevTaskId + \"] to complete before starting -- [\" + _waiting.length + \"] waiting\");\r\n            //#endif\r\n            // Wait for the previous tasks to complete before starting this one.\r\n            // This ensures the queue execution order and avoids removing tasks that\r\n            // have not yet been started.\r\n            doAwaitResponse(prevTask.p, function () {\r\n                _removeTask(_waiting, taskDetail);\r\n                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);\r\n            });\r\n        });\r\n    };\r\n    var _doCleanup = function (taskDetail) {\r\n        _removeTask(_running, taskDetail);\r\n        // If there was a timeout stop and clear\r\n        taskDetail.t && taskDetail.t.cancel();\r\n        taskDetail.t = null;\r\n        // Clear the matching current task now that it's complete\r\n        if (_theTask && _theTask === taskDetail) {\r\n            _theTask = null;\r\n            if (getLength(_running) + getLength(_waiting) === 0) {\r\n                _blockedTimer && _blockedTimer.cancel();\r\n                _blockedTimer = null;\r\n            }\r\n        }\r\n    };\r\n    var theScheduler = {\r\n        idle: true,\r\n        queue: _queueTask,\r\n        setStaleTimeout: function (staleTimeout, staleCheckPeriod) {\r\n            _blockedTimer && _blockedTimer.cancel();\r\n            _blockedTimer = null;\r\n            _staleTimeoutPeriod = staleTimeout;\r\n            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;\r\n            _startBlockedTimer();\r\n        }\r\n    };\r\n    // Change the idle property to dynamic\r\n    objDefine(theScheduler, \"idle\", {\r\n        g: function () {\r\n            return getLength(_running) + getLength(_waiting) === 0;\r\n        }\r\n    });\r\n    _addDebugState(theScheduler, function () { return _schedulerName; }, function () {\r\n        return {\r\n            l: _theTask,\r\n            r: _running,\r\n            w: _waiting\r\n        };\r\n    });\r\n    return theScheduler;\r\n}\r\n//# sourceMappingURL=taskScheduler.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { getKnownSymbol, objDefineProp } from \"@nevware21/ts-utils\";\r\nimport { createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncAnyPromise, createAsyncPromise, createAsyncRacePromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"../promise/asyncPromise\";\r\nvar toStringTagSymbol = getKnownSymbol(11 /* WellKnownSymbols.toStringTag */);\r\n/**\r\n * A full polyfill for the Promise class.\r\n * Represents the completion of an asynchronous operation, and its resulting value.\r\n * @since 0.5.0\r\n * @class\r\n * @group Polyfill\r\n * @group Promise\r\n */\r\nexport var PolyPromise = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    function PolyPromiseImpl(executor) {\r\n        this._$ = createAsyncPromise(executor);\r\n        if (toStringTagSymbol) {\r\n            this[toStringTagSymbol] = \"Promise\";\r\n        }\r\n        // Re-Expose the state of the underlying promise\r\n        objDefineProp(this, \"state\", {\r\n            get: function () {\r\n                return this._$.state;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     */\r\n    PolyPromiseImpl.all = createAsyncAllPromise;\r\n    PolyPromiseImpl.race = createAsyncRacePromise;\r\n    PolyPromiseImpl.any = createAsyncAnyPromise;\r\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\r\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\r\n    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\r\n    var theProto = PolyPromiseImpl.prototype;\r\n    theProto.then = function (onResolved, onRejected) {\r\n        return this._$.then(onResolved, onRejected);\r\n    };\r\n    theProto.catch = function (onRejected) {\r\n        return this._$.catch(onRejected);\r\n    };\r\n    theProto.finally = function (onfinally) {\r\n        return this._$.finally(onfinally);\r\n    };\r\n    return PolyPromiseImpl;\r\n}());\r\n//# sourceMappingURL=promise.js.map"],"names":["_addDebugState"],"mappings":"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"}