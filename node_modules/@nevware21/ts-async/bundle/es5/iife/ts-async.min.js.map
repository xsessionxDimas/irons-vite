{"version":3,"file":"ts-async.min.js","sources":["../../../../common/temp/node_modules/@nevware21/ts-utils/dist/es5/mod/ts-utils.js","../../../build/es5/mod/promise/await.js","../../../build/es5/mod/promise/event.js","../../../build/es5/mod/promise/base.js","../../../build/es5/mod/promise/debug.js","../../../build/es5/mod/promise/itemProcessor.js","../../../build/es5/mod/promise/asyncPromise.js","../../../build/es5/mod/promise/nativePromise.js","../../../build/es5/mod/promise/syncPromise.js","../../../build/es5/mod/promise/idlePromise.js","../../../build/es5/mod/promise/promise.js","../../../build/es5/mod/helpers/doWhileAsync.js","../../../build/es5/mod/scheduler/taskScheduler.js","../../../build/es5/mod/internal/constants.js","../../../build/es5/mod/internal/state.js","../../../build/es5/mod/helpers/iterForOfAsync.js","../../../build/es5/mod/polyfills/promise.js","../../../build/es5/mod/helpers/arrForEachAsync.js","../../../build/es5/mod/promise/timeoutPromise.js"],"sourcesContent":["/*! https://github.com/nevware21/ts-utils v0.11.3 */\n/*\n * Copyright (c) NevWare21 Solutions LLC and contributors. All rights reserved.\n * Licensed under the MIT license.\n */\n/*#__NO_SIDE_EFFECTS__*/\nfunction _pureAssign(func1, func2) {\n    return func1 || func2;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _pureRef(value, name) {\n    return value[name];\n}\n\nvar UNDEF_VALUE = undefined;\nvar NULL_VALUE = null;\nvar EMPTY = \"\";\nvar FUNCTION = \"function\";\nvar OBJECT = \"object\";\nvar PROTOTYPE = \"prototype\";\nvar __PROTO__ = \"__proto__\";\nvar UNDEFINED = \"undefined\";\nvar CONSTRUCTOR = \"constructor\";\nvar SYMBOL = \"Symbol\";\nvar POLYFILL_TAG = \"_polyfill\";\nvar LENGTH = \"length\";\nvar NAME = \"name\";\nvar CALL = \"call\";\nvar TO_STRING = \"toString\";\nvar ObjClass = ( /*#__PURE__*/_pureAssign(Object));\nvar ObjProto = ( /*#__PURE__*/_pureRef(ObjClass, PROTOTYPE));\nvar StrCls = ( /*#__PURE__*/_pureAssign(String));\nvar StrProto = ( /*#__PURE__*/_pureRef(StrCls, PROTOTYPE));\nvar MathCls = ( /*#__PURE__*/_pureAssign(Math));\nvar ArrCls = ( /*#__PURE__*/_pureAssign(Array));\nvar ArrProto = ( /*#__PURE__*/_pureRef(ArrCls, PROTOTYPE));\nvar ArrSlice = ( /*#__PURE__*/_pureRef(ArrProto, \"slice\"));\n\nfunction safe(func, argArray) {\n    try {\n        return {\n            v: func.apply(this, argArray)\n        };\n    }\n    catch (e) {\n        return { e: e };\n    }\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction safeGet(cb, defValue) {\n    var result = safe(cb);\n    return result.e ? defValue : result.v;\n}\n\nvar _primitiveTypes;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createIs(theType) {\n    return function (value) {\n        return typeof value === theType;\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createObjIs(theName) {\n    var theType = \"[object \" + theName + \"]\";\n    return function (value) {\n        return !!(value && objToString(value) === theType);\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction objToString(value) {\n    return ObjProto[TO_STRING].call(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isTypeof(value, theType) {\n    return typeof value === theType;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isUndefined(value) {\n    return typeof value === UNDEFINED || value === UNDEFINED;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isStrictUndefined(arg) {\n    return !isDefined(arg);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isNullOrUndefined(value) {\n    return value === NULL_VALUE || isUndefined(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isStrictNullOrUndefined(value) {\n    return value === NULL_VALUE || !isDefined(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isDefined(arg) {\n    return !!arg || arg !== UNDEF_VALUE;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPrimitive(value) {\n    return value === NULL_VALUE || isPrimitiveType(typeof value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPrimitiveType(theType) {\n    !_primitiveTypes && (_primitiveTypes = [\"string\", \"number\", \"boolean\", UNDEFINED, \"symbol\", \"bigint\"]);\n    return theType !== OBJECT && _primitiveTypes.indexOf(theType) !== -1;\n}\nvar isString = ( /*#__PURE__*/_createIs(\"string\"));\nvar isFunction = ( /*#__PURE__*/_createIs(FUNCTION));\n/*#__NO_SIDE_EFFECTS__*/\nfunction isObject(value) {\n    if (!value && isNullOrUndefined(value)) {\n        return false;\n    }\n    return !!value && typeof value === OBJECT;\n}\nvar isArray = ( /* #__PURE__*/_pureRef(ArrCls, \"isArray\"));\nvar isDate = ( /*#__PURE__*/_createObjIs(\"Date\"));\nvar isNumber = ( /*#__PURE__*/_createIs(\"number\"));\nvar isBoolean = ( /*#__PURE__*/_createIs(\"boolean\"));\nvar isRegExp = ( /*#__PURE__*/_createObjIs(\"RegExp\"));\nvar isFile = ( /*#__PURE__*/_createObjIs(\"File\"));\nvar isFormData = ( /*#__PURE__*/_createObjIs(\"FormData\"));\nvar isBlob = ( /*#__PURE__*/_createObjIs(\"Blob\"));\nvar isArrayBuffer = ( /*#__PURE__*/_createObjIs(\"ArrayBuffer\"));\nvar isError = ( /*#__PURE__*/_createObjIs(\"Error\"));\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPromiseLike(value) {\n    return !!(value && value.then && isFunction(value.then));\n}\nvar isThenable = isPromiseLike;\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPromise(value) {\n    return !!(value && value.then && value.catch && isFunction(value.then) && isFunction(value.catch));\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isNotTruthy(value) {\n    return !value || !isTruthy(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isTruthy(value) {\n    return !(!value || safeGet(function () { return !(value && (0 + value)); }, !value));\n}\n\nvar objGetOwnPropertyDescriptor = ( /* #__PURE__ */_pureRef(ObjClass, \"getOwnPropertyDescriptor\"));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction objHasOwnProperty(obj, prop) {\n    return !!obj && ObjProto.hasOwnProperty[CALL](obj, prop);\n}\n\nvar objHasOwn = ( /*#__PURE__*/_pureAssign(( /* #__PURE__ */_pureRef(ObjClass, \"hasOwn\")), polyObjHasOwn));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjHasOwn(obj, prop) {\n    return objHasOwnProperty(obj, prop) || !!objGetOwnPropertyDescriptor(obj, prop);\n}\n\nfunction objForEachKey(theObject, callbackfn, thisArg) {\n    if (theObject && isObject(theObject)) {\n        for (var prop in theObject) {\n            if (objHasOwn(theObject, prop)) {\n                if (callbackfn[CALL](thisArg || theObject, prop, theObject[prop]) === -1) {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvar propMap = {\n    e: \"enumerable\",\n    c: \"configurable\",\n    v: \"value\",\n    w: \"writable\",\n    g: \"get\",\n    s: \"set\"\n};\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createProp(value) {\n    var prop = {};\n    prop[propMap[\"c\"]] = true;\n    prop[propMap[\"e\"]] = true;\n    if (value.l) {\n        prop.get = function () { return value.l.v; };\n        var desc = objGetOwnPropertyDescriptor(value.l, \"v\");\n        if (desc && desc.set) {\n            prop.set = function (newValue) {\n                value.l.v = newValue;\n            };\n        }\n    }\n    objForEachKey(value, function (key, value) {\n        prop[propMap[key]] = isUndefined(value) ? prop[propMap[key]] : value;\n    });\n    return prop;\n}\nvar objDefineProp = ( /*#__PURE__*/_pureRef(ObjClass, \"defineProperty\"));\nvar objDefineProperties = ( /*#__PURE__*/_pureRef(ObjClass, \"defineProperties\"));\nfunction objDefineGet(target, key, value, configurable, enumerable) {\n    var _a;\n    return objDefineProp(target, key, _createProp((_a = {\n            e: enumerable,\n            c: configurable\n        },\n        _a[isFunction(value) ? \"g\" : \"v\"] = value,\n        _a)));\n}\nfunction objDefineAccessors(target, prop, getProp, setProp, configurable, enumerable) {\n    var desc = {\n        e: enumerable,\n        c: configurable\n    };\n    if (getProp) {\n        desc.g = getProp;\n    }\n    if (setProp) {\n        desc.s = setProp;\n    }\n    return objDefineProp(target, prop, _createProp(desc));\n}\nfunction objDefine(target, key, propDesc) {\n    return objDefineProp(target, key, _createProp(propDesc));\n}\nfunction objDefineProps(target, propDescMap) {\n    var props = {};\n    objForEachKey(propDescMap, function (key, value) {\n        props[key] = _createProp(value);\n    });\n    return objDefineProperties(target, props);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createKeyValueMap(values, keyType, valueType, completeFn, writable) {\n    var theMap = {};\n    objForEachKey(values, function (key, value) {\n        _assignMapValue(theMap, key, keyType ? value : key, writable);\n        _assignMapValue(theMap, value, valueType ? value : key, writable);\n    });\n    return completeFn ? completeFn(theMap) : theMap;\n}\nfunction _assignMapValue(theMap, key, value, writable) {\n    objDefineProp(theMap, key, {\n        value: value,\n        enumerable: true,\n        writable: !!writable\n    });\n}\n\nvar asString = ( /* #__PURE__ */_pureAssign(StrCls));\n\nvar ERROR_TYPE = \"[object Error]\";\n/*#__NO_SIDE_EFFECTS__*/\nfunction dumpObj(object, format) {\n    var propertyValueDump = EMPTY;\n    var objType = ObjProto[TO_STRING][CALL](object);\n    if (objType === ERROR_TYPE) {\n        object = { stack: asString(object.stack), message: asString(object.message), name: asString(object.name) };\n    }\n    try {\n        propertyValueDump = JSON.stringify(object, NULL_VALUE, format ? ((typeof format === \"number\") ? format : 4) : UNDEF_VALUE);\n        propertyValueDump = (propertyValueDump && propertyValueDump.replace(/\"(\\w+)\"\\s*:\\s{0,1}/g, \"$1: \")) || asString(object);\n    }\n    catch (e) {\n        propertyValueDump = \" - \" + dumpObj(e, format);\n    }\n    return objType + \": \" + propertyValueDump;\n}\n\nfunction throwError(message) {\n    throw new Error(message);\n}\nfunction throwTypeError(message) {\n    throw new TypeError(message);\n}\nfunction throwRangeError(message) {\n    throw new RangeError(message);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjKeys(obj) {\n    if (!isObject(obj) || obj === NULL_VALUE) {\n        throwTypeError(\"non-object \" + dumpObj(obj));\n    }\n    var result = [];\n    for (var prop in obj) {\n        if (objHasOwn(obj, prop)) {\n            result.push(prop);\n        }\n    }\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjEntries(value) {\n    var result = [];\n    objForEachKey(value, function (key, value) {\n        result.push([key, value]);\n    });\n    return result;\n}\n\nvar _objFreeze = ( /* #__PURE__ */_pureRef(ObjClass, \"freeze\"));\nfunction _doNothing(value) {\n    return value;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _getProto(value) {\n    return value[__PROTO__] || NULL_VALUE;\n}\nvar objAssign = ( /*#__PURE__*/_pureRef(ObjClass, \"assign\"));\nvar objKeys = ( /*#__PURE__*/_pureRef(ObjClass, \"keys\"));\nfunction objDeepFreeze(value) {\n    if (_objFreeze) {\n        objForEachKey(value, function (key, value) {\n            if (isArray(value) || isObject(value)) {\n                objDeepFreeze(value);\n            }\n        });\n    }\n    return objFreeze(value);\n}\nvar objFreeze = ( /* #__PURE__*/_pureAssign(_objFreeze, _doNothing));\nvar objSeal = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, \"seal\")), _doNothing));\nvar objGetPrototypeOf = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, \"getPrototypeOf\")), _getProto));\nvar objEntries = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, \"entries\")), polyObjEntries));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createEnum(values) {\n    return _createKeyValueMap(values, 1 , 0 , objFreeze);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createEnumKeyMap(values) {\n    return _createKeyValueMap(values, 0 , 0 , objFreeze);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createEnumValueMap(values) {\n    return _createKeyValueMap(values, 1 , 1 , objFreeze);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createSimpleMap(values) {\n    var mapClass = {};\n    objForEachKey(values, function (key, value) {\n        _assignMapValue(mapClass, key, value[1]);\n        _assignMapValue(mapClass, value[0], value[1]);\n    });\n    return objFreeze(mapClass);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createTypeMap(values) {\n    return createSimpleMap(values);\n}\n\nvar _wellKnownSymbolMap = /*#__PURE__*/ createEnumKeyMap({\n    asyncIterator: 0 ,\n    hasInstance: 1 ,\n    isConcatSpreadable: 2 ,\n    iterator: 3 ,\n    match: 4 ,\n    matchAll: 5 ,\n    replace: 6 ,\n    search: 7 ,\n    species: 8 ,\n    split: 9 ,\n    toPrimitive: 10 ,\n    toStringTag: 11 ,\n    unscopables: 12\n});\n\nvar GLOBAL_CONFIG_KEY = \"__tsUtils$gblCfg\";\nvar _globalCfg;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _getGlobalValue() {\n    var result;\n    if (typeof globalThis !== UNDEFINED) {\n        result = globalThis;\n    }\n    if (!result && typeof self !== UNDEFINED) {\n        result = self;\n    }\n    if (!result && typeof window !== UNDEFINED) {\n        result = window;\n    }\n    if (!result && typeof global !== UNDEFINED) {\n        result = global;\n    }\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _getGlobalConfig() {\n    if (!_globalCfg) {\n        var gbl = safe(_getGlobalValue).v || {};\n        _globalCfg = gbl[GLOBAL_CONFIG_KEY] = gbl[GLOBAL_CONFIG_KEY] || {};\n    }\n    return _globalCfg;\n}\n\nvar _unwrapFunction = ( _unwrapFunctionWithPoly);\n/*#__NO_SIDE_EFFECTS__*/\nfunction _unwrapFunctionWithPoly(funcName, clsProto, polyFunc) {\n    var clsFn = clsProto && clsProto[funcName];\n    return function (thisArg) {\n        var theFunc = (thisArg && thisArg[funcName]) || clsFn;\n        if (theFunc || polyFunc) {\n            var theArgs = arguments;\n            return (theFunc || polyFunc).apply(thisArg, theFunc ? ArrSlice[CALL](theArgs, 1) : theArgs);\n        }\n        throwTypeError(\"\\\"\" + asString(funcName) + \"\\\" not defined for \" + dumpObj(thisArg));\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _unwrapProp(propName) {\n    return function (thisArg) {\n        return thisArg[propName];\n    };\n}\n\nvar mathMin = ( /*#__PURE__*/_pureRef(MathCls, \"min\"));\nvar mathMax = ( /*#__PURE__*/_pureRef(MathCls, \"max\"));\n\nvar strSlice = ( /*#__PURE__*/_unwrapFunction(\"slice\", StrProto));\n\nvar strSubstring = ( /*#__PURE__*/_unwrapFunction(\"substring\", StrProto));\nvar strSubstr = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"substr\", StrProto, polyStrSubstr));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrSubstr(value, start, length) {\n    if (isNullOrUndefined(value)) {\n        throwTypeError(\"Invalid \" + dumpObj(value));\n    }\n    if (length < 0) {\n        return EMPTY;\n    }\n    start = start || 0;\n    if (start < 0) {\n        start = mathMax(start + value[LENGTH], 0);\n    }\n    if (isUndefined(length)) {\n        return strSlice(value, start);\n    }\n    return strSlice(value, start, start + length);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strLeft(value, count) {\n    return strSubstring(value, 0, count);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strRight(value, count) {\n    return count <= 0 ? EMPTY : (value[LENGTH] > count ? strSlice(value, -count) : value);\n}\n\nvar UNIQUE_REGISTRY_ID = \"_urid\";\nvar _polySymbols;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _globalSymbolRegistry() {\n    if (!_polySymbols) {\n        var gblCfg = _getGlobalConfig();\n        _polySymbols = gblCfg.gblSym = gblCfg.gblSym || { k: {}, s: {} };\n    }\n    return _polySymbols;\n}\nvar _wellKnownSymbolCache;\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyNewSymbol(description) {\n    var theSymbol = {\n        description: asString(description),\n        toString: function () { return SYMBOL + \"(\" + description + \")\"; }\n    };\n    theSymbol[POLYFILL_TAG] = true;\n    return theSymbol;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polySymbolFor(key) {\n    var registry = _globalSymbolRegistry();\n    if (!objHasOwn(registry.k, key)) {\n        var newSymbol_1 = polyNewSymbol(key);\n        var regId_1 = objKeys(registry.s).length;\n        newSymbol_1[UNIQUE_REGISTRY_ID] = function () { return regId_1 + \"_\" + newSymbol_1[TO_STRING](); };\n        registry.k[key] = newSymbol_1;\n        registry.s[newSymbol_1[UNIQUE_REGISTRY_ID]()] = asString(key);\n    }\n    return registry.k[key];\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polySymbolKeyFor(sym) {\n    if (!sym || !sym[TO_STRING] || strSubstring(sym[TO_STRING](), 0, 6) != SYMBOL) {\n        throwTypeError(sym + \" is not a symbol\");\n    }\n    var regId = sym[POLYFILL_TAG] && sym[UNIQUE_REGISTRY_ID] && sym[UNIQUE_REGISTRY_ID]();\n    return regId ? _globalSymbolRegistry().s[regId] : undefined;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyGetKnownSymbol(name) {\n    !_wellKnownSymbolCache && (_wellKnownSymbolCache = {});\n    var result;\n    var knownName = _wellKnownSymbolMap[name];\n    if (knownName) {\n        result = _wellKnownSymbolCache[knownName] = _wellKnownSymbolCache[knownName] || polyNewSymbol(SYMBOL + \".\" + knownName);\n    }\n    return result;\n}\n\nvar _globalLazyTestHooks;\nfunction _initTestHooks() {\n    _globalLazyTestHooks = _getGlobalConfig();\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getLazy(cb) {\n    var lazyValue = {};\n    !_globalLazyTestHooks && _initTestHooks();\n    lazyValue.b = _globalLazyTestHooks.lzy;\n    objDefineProp(lazyValue, \"v\", {\n        configurable: true,\n        get: function () {\n            var result = cb();\n            if (!_globalLazyTestHooks.lzy) {\n                objDefineProp(lazyValue, \"v\", {\n                    value: result\n                });\n            }\n            lazyValue.b = _globalLazyTestHooks.lzy;\n            return result;\n        }\n    });\n    return lazyValue;\n}\nfunction setBypassLazyCache(newValue) {\n    !_globalLazyTestHooks && _initTestHooks();\n    _globalLazyTestHooks.lzy = newValue;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createCachedValue(value) {\n    return objDefineProp({\n        toJSON: function () { return value; }\n    }, \"v\", { value: value });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createDeferredCachedValue(cb) {\n    var theValue = {\n        toJSON: function () { return theValue.v; }\n    };\n    return objDefineProp(theValue, \"v\", {\n        get: function () {\n            var result = cb();\n            cb = NULL_VALUE;\n            objDefineProp(theValue, \"v\", { value: result });\n            return result;\n        },\n        configurable: true\n    });\n}\n\nvar WINDOW = \"window\";\nvar _cachedGlobal;\nfunction _getGlobalInstFn(getFn, theArgs) {\n    var cachedValue;\n    return function () {\n        !_globalLazyTestHooks && _initTestHooks();\n        (!cachedValue || _globalLazyTestHooks.lzy) && (cachedValue = createCachedValue(safe(getFn, theArgs).v));\n        return cachedValue.v;\n    };\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction lazySafeGetInst(name) {\n    return getLazy(function () { return safe((getInst), [name]).v || UNDEF_VALUE; });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getGlobal(useCached) {\n    !_globalLazyTestHooks && _initTestHooks();\n    (!_cachedGlobal || useCached === false || _globalLazyTestHooks.lzy) && (_cachedGlobal = createCachedValue(safe(_getGlobalValue).v || NULL_VALUE));\n    return _cachedGlobal.v;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getInst(name, useCached) {\n    var gbl = (!_cachedGlobal || useCached === false) ? getGlobal(useCached) : _cachedGlobal.v;\n    if (gbl && gbl[name]) {\n        return gbl[name];\n    }\n    if (name === WINDOW) {\n        return getWindow();\n    }\n    return NULL_VALUE;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasDocument() {\n    return !!( /*#__PURE__*/getDocument());\n}\nvar getDocument = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"document\"]));\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasWindow() {\n    return !!( /*#__PURE__*/getWindow());\n}\nvar getWindow = ( /*#__PURE__*/_getGlobalInstFn(getInst, [WINDOW]));\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasNavigator() {\n    return !!( /*#__PURE__*/getNavigator());\n}\nvar getNavigator = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"navigator\"]));\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasHistory() {\n    return !!( /*#__PURE__*/getHistory());\n}\nvar getHistory = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"history\"]));\nvar isNode = ( /*#__PURE__*/_getGlobalInstFn(function () {\n    return !!( /*#__PURE__*/safe(function () { return (process && (process.versions || {}).node); }).v);\n}));\nvar isWebWorker = ( /*#__PURE__*/_getGlobalInstFn(function () {\n    return !!( /*#__PURE__*/safe(function () { return self && self instanceof WorkerGlobalScope; }).v);\n}));\n\nvar _symbol;\nvar _symbolFor;\nvar _symbolKeyFor;\n/*#__NO_SIDE_EFFECTS__*/\nfunction _initSymbol() {\n    _symbol = ( /*#__PURE__*/createCachedValue(safe((getInst), [SYMBOL]).v));\n    return _symbol;\n}\nfunction _getSymbolKey(key) {\n    var gblSym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\n    return (gblSym.v ? gblSym.v[key] : UNDEF_VALUE);\n}\nvar isSymbol = ( /*#__PURE__*/_createIs(\"symbol\"));\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasSymbol() {\n    return !!( /*#__PURE__*/getSymbol());\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getSymbol() {\n    !_globalLazyTestHooks && _initTestHooks();\n    return ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol()).v;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getKnownSymbol(name, noPoly) {\n    var knownName = _wellKnownSymbolMap[name];\n    !_globalLazyTestHooks && _initTestHooks();\n    var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\n    return sym.v ? sym.v[knownName || name] : (!noPoly ? polyGetKnownSymbol(name) : UNDEF_VALUE);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction newSymbol(description, noPoly) {\n    !_globalLazyTestHooks && _initTestHooks();\n    var sym = ((!_globalLazyTestHooks.lzy ? _symbol : 0) || _initSymbol());\n    return sym.v ? sym.v(description) : (!noPoly ? polyNewSymbol(description) : NULL_VALUE);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction symbolFor(key) {\n    !_globalLazyTestHooks && _initTestHooks();\n    _symbolFor = ((!_globalLazyTestHooks.lzy ? _symbolFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), [\"for\"]).v)));\n    return (_symbolFor.v || polySymbolFor)(key);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction symbolKeyFor(sym) {\n    !_globalLazyTestHooks && _initTestHooks();\n    _symbolKeyFor = ((!_globalLazyTestHooks.lzy ? _symbolKeyFor : 0) || ( /*#__PURE__*/createCachedValue(safe((_getSymbolKey), [\"keyFor\"]).v)));\n    return (_symbolKeyFor.v || polySymbolKeyFor)(sym);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction isIterator(value) {\n    return !!value && isFunction(value.next);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction isIterable(value) {\n    return !isStrictNullOrUndefined(value) && isFunction(value[getKnownSymbol(3 )]);\n}\n\nvar _iterSymbol$1;\nfunction iterForOf(iter, callbackfn, thisArg) {\n    if (iter) {\n        if (!isIterator(iter)) {\n            !_iterSymbol$1 && (_iterSymbol$1 = createCachedValue(getKnownSymbol(3 )));\n            iter = iter[_iterSymbol$1.v] ? iter[_iterSymbol$1.v]() : null;\n        }\n        if (isIterator(iter)) {\n            var err = UNDEF_VALUE;\n            var iterResult = UNDEF_VALUE;\n            try {\n                var count = 0;\n                while (!(iterResult = iter.next()).done) {\n                    if (callbackfn[CALL](thisArg || iter, iterResult.value, count, iter) === -1) {\n                        break;\n                    }\n                    count++;\n                }\n            }\n            catch (failed) {\n                err = { e: failed };\n                if (iter.throw) {\n                    iterResult = NULL_VALUE;\n                    iter.throw(err);\n                }\n            }\n            finally {\n                try {\n                    if (iterResult && !iterResult.done) {\n                        iter.return && iter.return(iterResult);\n                    }\n                }\n                finally {\n                    if (err) {\n                        // eslint-disable-next-line no-unsafe-finally\n                        throw err.e;\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction fnApply(fn, thisArg, argArray) {\n    return fn.apply(thisArg, argArray);\n}\nfunction fnCall(fn, thisArg) {\n    return fn.apply(thisArg, ArrSlice[CALL](arguments, 2));\n}\nfunction fnBind(fn, thisArg) {\n    return fn.bind.apply(fn, ArrSlice[CALL](arguments, 1));\n}\n\nfunction arrAppend(target, elms) {\n    if (!isUndefined(elms) && target) {\n        if (isArray(elms)) {\n            fnApply(target.push, target, elms);\n        }\n        else if (isIterator(elms) || isIterable(elms)) {\n            iterForOf(elms, function (elm) {\n                target.push(elm);\n            });\n        }\n        else {\n            target.push(elms);\n        }\n    }\n    return target;\n}\n\nvar arrEvery = /*#__PURE__*/ _unwrapFunction(\"every\", ArrProto);\nvar arrFilter = /*#__PURE__*/ _unwrapFunction(\"filter\", ArrProto);\n\nfunction arrForEach(theArray, callbackfn, thisArg) {\n    if (theArray) {\n        var len = theArray[LENGTH] >>> 0;\n        for (var idx = 0; idx < len; idx++) {\n            if (idx in theArray) {\n                if (callbackfn[CALL](thisArg || theArray, theArray[idx], idx, theArray) === -1) {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nvar arrIndexOf = ( /*#__PURE__*/_unwrapFunction(\"indexOf\", ArrProto));\nvar arrLastIndexOf = ( /*#__PURE__*/_unwrapFunction(\"lastIndexOf\", ArrProto));\n\nvar arrMap = ( /*#__PURE__*/_unwrapFunction(\"map\", ArrProto));\n\nfunction arrSlice(theArray, start, end) {\n    return ((theArray && theArray[\"slice\"]) || ArrSlice).apply(theArray, ArrSlice[CALL](arguments, 1));\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyIsArray(value) {\n    if (isNullOrUndefined(value)) {\n        return false;\n    }\n    return objToString(value) === \"[object Array]\";\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyArrIncludes(theArray, searchElement, fromIndex) {\n    return arrIndexOf(theArray, searchElement, fromIndex) !== -1;\n}\nfunction polyArrFind(theArray, callbackFn, thisArg) {\n    var result;\n    var idx = polyArrFindIndex(theArray, callbackFn, thisArg);\n    return idx !== -1 ? theArray[idx] : result;\n}\nfunction polyArrFindIndex(theArray, callbackFn, thisArg) {\n    var result = -1;\n    arrForEach(theArray, function (value, index) {\n        if (callbackFn[CALL](thisArg | theArray, value, index, theArray)) {\n            result = index;\n            return -1;\n        }\n    });\n    return result;\n}\nfunction polyArrFindLast(theArray, callbackFn, thisArg) {\n    var result;\n    var idx = polyArrFindLastIndex(theArray, callbackFn, thisArg);\n    return idx !== -1 ? theArray[idx] : result;\n}\nfunction polyArrFindLastIndex(theArray, callbackFn, thisArg) {\n    var result = -1;\n    var len = theArray[LENGTH] >>> 0;\n    for (var idx = len - 1; idx >= 0; idx--) {\n        if (idx in theArray && callbackFn[CALL](thisArg | theArray, theArray[idx], idx, theArray)) {\n            result = idx;\n            break;\n        }\n    }\n    return result;\n}\nfunction polyArrFrom(theValue, mapFn, thisArg) {\n    if (isArray(theValue)) {\n        var result_1 = arrSlice(theValue);\n        return mapFn ? arrMap(result_1, mapFn, thisArg) : result_1;\n    }\n    var result = [];\n    iterForOf(theValue, function (value, cnt) {\n        return result.push(mapFn ? mapFn[CALL](thisArg, value, cnt) : value);\n    });\n    return result;\n}\n\nvar arrFind = /*#__PURE__*/ _unwrapFunctionWithPoly(\"find\", ArrProto, polyArrFind);\nvar arrFindIndex = /*#__PURE__*/ _unwrapFunctionWithPoly(\"findIndex\", ArrProto, polyArrFindIndex);\nvar arrFindLast = /*#__PURE__*/ _unwrapFunctionWithPoly(\"findLast\", ArrProto, polyArrFindLast);\nvar arrFindLastIndex = /*#__PURE__*/ _unwrapFunctionWithPoly(\"findLastIndex\", ArrProto, polyArrFindLastIndex);\n\nvar arrFrom = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ArrCls, \"from\")), polyArrFrom));\n\nvar arrIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"includes\", ArrProto, polyArrIncludes));\nvar arrContains = arrIncludes;\n\nvar arrReduce = ( /*#__PURE__*/_unwrapFunction(\"reduce\", ArrProto));\n\nvar arrSome = ( /*#__PURE__*/_unwrapFunction(\"some\", ArrProto));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createFnDeferredProxy(hostFn, funcName) {\n    return function () {\n        var theArgs = ArrSlice[CALL](arguments);\n        var theHost = hostFn();\n        return fnApply(theHost[funcName], theHost, theArgs);\n    };\n}\nfunction createProxyFuncs(target, host, funcDefs) {\n    if (target && host && isArray(funcDefs)) {\n        var isDeferred_1 = isFunction(host);\n        arrForEach(funcDefs, function (funcDef) {\n            var targetName = (funcDef.as || funcDef.n);\n            if (funcDef.rp === false && target[targetName]) {\n                return;\n            }\n            target[targetName] = isDeferred_1 ?\n                createFnDeferredProxy(host, funcDef.n) :\n                fnBind(host[funcDef.n], host);\n        });\n    }\n    return target;\n}\n\nvar _iterSymbol;\n/*#__NO_SIDE_EFFECTS__*/\nfunction readArgs(theArgs, start, end) {\n    if (!objHasOwn(theArgs, LENGTH)) {\n        !_iterSymbol && (_iterSymbol = createCachedValue(hasSymbol() && getKnownSymbol(3 )));\n        var iterFn = _iterSymbol.v && theArgs[_iterSymbol.v];\n        if (iterFn) {\n            var values_1 = [];\n            var from_1 = (start === UNDEF_VALUE || start < 0) ? 0 : start;\n            var to_1 = end < 0 || start < 0 ? UNDEF_VALUE : end;\n            iterForOf(iterFn[CALL](theArgs), function (value, cnt) {\n                if (to_1 !== UNDEF_VALUE && cnt >= to_1) {\n                    return -1;\n                }\n                if (cnt >= from_1) {\n                    values_1.push(value);\n                }\n            });\n            if ((start === UNDEF_VALUE || start >= 0) && (end === UNDEF_VALUE || end >= 0)) {\n                return values_1;\n            }\n            theArgs = values_1;\n        }\n    }\n    return arrSlice(theArgs, start, end);\n}\n\nvar objCreate = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(ObjClass, \"create\")), polyObjCreate));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyObjCreate(obj) {\n    if (!obj) {\n        return {};\n    }\n    var type = typeof obj;\n    if (type !== OBJECT && type !== FUNCTION) {\n        throwTypeError(\"Prototype must be an Object or function: \" + dumpObj(obj));\n    }\n    function tempFunc() { }\n    tempFunc[PROTOTYPE] = obj;\n    return new tempFunc();\n}\n\nvar _isProtoArray;\nfunction objSetPrototypeOf(obj, proto) {\n    var fn = ObjClass[\"setPrototypeOf\"] ||\n        function (d, b) {\n            var _a;\n            !_isProtoArray && (_isProtoArray = createCachedValue((_a = {}, _a[__PROTO__] = [], _a) instanceof Array));\n            _isProtoArray.v ? d[__PROTO__] = b : objForEachKey(b, function (key, value) { return d[key] = value; });\n        };\n    return fn(obj, proto);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createCustomError(name, d, b) {\n    safe(objDefine, [d, NAME, { v: name, c: true, e: false }]);\n    d = objSetPrototypeOf(d, b);\n    function __() {\n        this[CONSTRUCTOR] = d;\n        safe(objDefine, [this, NAME, { v: name, c: true, e: false }]);\n    }\n    d[PROTOTYPE] = b === NULL_VALUE ? objCreate(b) : (__[PROTOTYPE] = b[PROTOTYPE], new __());\n    return d;\n}\nfunction _setName(baseClass, name) {\n    name && (baseClass[NAME] = name);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createCustomError(name, constructCb, errorBase) {\n    var theBaseClass = errorBase || Error;\n    var orgName = theBaseClass[PROTOTYPE][NAME];\n    var captureFn = Error.captureStackTrace;\n    return _createCustomError(name, function () {\n        var _this = this;\n        var theArgs = arguments;\n        try {\n            safe(_setName, [theBaseClass, name]);\n            var _self = fnApply(theBaseClass, _this, ArrSlice[CALL](theArgs)) || _this;\n            if (_self !== _this) {\n                var orgProto = objGetPrototypeOf(_this);\n                if (orgProto !== objGetPrototypeOf(_self)) {\n                    objSetPrototypeOf(_self, orgProto);\n                }\n            }\n            captureFn && captureFn(_self, _this[CONSTRUCTOR]);\n            constructCb && constructCb(_self, theArgs);\n            return _self;\n        }\n        finally {\n            safe(_setName, [theBaseClass, orgName]);\n        }\n    }, theBaseClass);\n}\nvar _unsupportedError;\nfunction throwUnsupported(message) {\n    if (!_unsupportedError) {\n        _unsupportedError = createCustomError(\"UnsupportedError\");\n    }\n    throw new _unsupportedError(message);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction utcNow() {\n    return (Date.now || polyUtcNow)();\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyUtcNow() {\n    return new Date().getTime();\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createTrimFn(exp) {\n    return function _doTrim(value) {\n        if (isNullOrUndefined(value)) {\n            throwTypeError(\"strTrim called [\" + dumpObj(value) + \"]\");\n        }\n        if (value && value.replace) {\n            value = value.replace(exp, EMPTY);\n        }\n        return value;\n    };\n}\nvar polyStrTrim = ( /*#__PURE__*/_createTrimFn(/^\\s+|(?=\\s)\\s+$/g));\nvar polyStrTrimStart = ( /*#__PURE__*/_createTrimFn(/^\\s+/g));\nvar polyStrTrimEnd = ( /*#__PURE__*/_createTrimFn(/(?=\\s)\\s+$/g));\n\nvar strTrim = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"trim\", StrProto, polyStrTrim));\nvar strTrimStart = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"trimStart\", StrProto, polyStrTrimStart));\nvar strTrimLeft = ( /*#__PURE__*/_pureAssign(strTrimStart));\nvar strTrimEnd = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"trimEnd\", StrProto, polyStrTrimEnd));\nvar strTrimRight = ( /*#__PURE__*/_pureAssign(strTrimEnd));\n\nvar strUpper = ( /*#__PURE__*/_unwrapFunction(\"toUpperCase\", StrProto));\nvar strLower = ( /*#__PURE__*/_unwrapFunction(\"toLowerCase\", StrProto));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _convertCase(value, newPrefix, upperWord) {\n    return strTrim(asString(value)).replace(/((_|\\W)+(\\w){0,1}|([a-z])([A-Z]))/g, function (_match, _g1, _g2, wordStart, upperPrefix, upperLetter) {\n        var convertMatch = wordStart || upperLetter || EMPTY;\n        if (upperWord) {\n            convertMatch = strUpper(convertMatch);\n        }\n        return (upperPrefix || EMPTY) + newPrefix + convertMatch;\n    });\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strLetterCase(value) {\n    return asString(value).replace(/(_|\\b)\\w/g, strUpper);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strCamelCase(value, upperFirst) {\n    var result = _convertCase(value, \"\", true);\n    return result.replace(/^\\w/, upperFirst ? strUpper : strLower);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strKebabCase(value, scream) {\n    var result = _convertCase(value, \"-\");\n    return (scream ? strUpper : strLower)(result);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strSnakeCase(value, scream) {\n    var result = _convertCase(value, \"_\");\n    return (scream ? strUpper : strLower)(result);\n}\n\nvar mathFloor = ( /*#__PURE__*/_pureRef(MathCls, \"floor\"));\nvar mathCeil = ( /*#__PURE__*/_pureRef(MathCls, \"ceil\"));\n\nvar mathTrunc = ( /* #__PURE__*/_pureAssign(( /* #__PURE__*/_pureRef(MathCls, \"trunc\")), polyMathTrunc));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyMathTrunc(value) {\n    var theValue = +value;\n    return (theValue > 0 ? mathFloor : mathCeil)(theValue);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction mathToInt(value, throwInfinity) {\n    var result = +value;\n    if (result == Infinity && throwInfinity) {\n        throwRangeError(\"invalid value [\" + dumpObj(value) + \"]\");\n    }\n    return result !== result || result === 0 ? 0 : mathTrunc(result);\n}\n\nvar strRepeat = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"repeat\", StrProto, polyStrRepeat));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrRepeat(value, count) {\n    if (isNullOrUndefined(value)) {\n        throwTypeError(\"can't convert [\" + dumpObj(value) + \"]\");\n    }\n    count = mathToInt(count, true);\n    if (count < 0) {\n        throwRangeError(\"invalid count must be >= 0 && < Infinity\");\n    }\n    var pad = isString(value) ? value : asString(value);\n    var result = EMPTY;\n    for (; count > 0; (count >>>= 1) && (pad += pad)) {\n        if (count & 1) {\n            result += pad;\n        }\n    }\n    return result;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _padValue(value, targetLength, padString) {\n    var result = EMPTY;\n    targetLength = mathToInt(targetLength, true);\n    targetLength >>= 0;\n    var len = value[LENGTH];\n    if (len < targetLength) {\n        result = isNullOrUndefined(padString) ? \" \" : asString(padString);\n        targetLength = targetLength - len;\n        if (targetLength > result[LENGTH]) {\n            result = strRepeat(result, mathCeil(targetLength / result[LENGTH]));\n        }\n        if (result[LENGTH] > targetLength) {\n            result = strSubstring(result, 0, targetLength);\n        }\n    }\n    return result;\n}\nvar strPadStart = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"padStart\", StrProto, polyStrPadStart));\nvar strPadEnd = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"padEnd\", StrProto, polyStrPadEnd));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrPadStart(value, targetLength, padString) {\n    return _padValue(value, targetLength, padString) + value;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrPadEnd(value, targetLength, padString) {\n    return value + _padValue(value, targetLength, padString);\n}\n\nvar DBL_QUOTE = \"\\\"\";\nvar INVALID_JS_NAME = /([^\\w\\d_$])/g;\nvar _htmlEntityCache;\n/*#__NO_SIDE_EFFECTS__*/\nfunction normalizeJsName(jsName, camelCase) {\n    var result = asString(jsName).replace(INVALID_JS_NAME, \"_\");\n    return !isUndefined(camelCase) ? strCamelCase(result, !camelCase) : result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction encodeAsJson(value, format) {\n    var result;\n    if (isString(value)) {\n        result = DBL_QUOTE + value.replace(/[^\\w .,\\-!@#$%\\^&*\\(\\)_+={}\\[\\]:;|<>?]/g, function (match) {\n            if (match === DBL_QUOTE || match === \"\\\\\") {\n                return \"\\\\\" + match;\n            }\n            var hex = match.charCodeAt(0)[TO_STRING](16);\n            return \"\\\\u\" + strPadStart(strUpper(hex), 4, \"0\");\n        }) + DBL_QUOTE;\n    }\n    else {\n        try {\n            result = JSON.stringify(value, NULL_VALUE, format ? (isNumber(format) ? format : 4) : UNDEF_VALUE);\n        }\n        catch (e) {\n            result = DBL_QUOTE + dumpObj(e) + DBL_QUOTE;\n        }\n    }\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction encodeAsHtml(value) {\n    !_htmlEntityCache && (_htmlEntityCache = {\n        \"&\": \"amp\",\n        \"<\": \"lt\",\n        \">\": \"gt\",\n        \"\\\"\": \"quot\",\n        \"'\": \"#39\"\n    });\n    return asString(value).replace(/[&<>\"']/g, function (match) { return \"&\" + _htmlEntityCache[match] + \";\"; });\n}\n\nvar _fnToString;\nvar _objCtrFnString;\nvar _gblWindow;\n/*#__NO_SIDE_EFFECTS__*/\nfunction isPlainObject(value) {\n    if (!value || typeof value !== OBJECT) {\n        return false;\n    }\n    if (!_gblWindow) {\n        _gblWindow = hasWindow() ? getWindow() : true;\n    }\n    var result = false;\n    if (value !== _gblWindow) {\n        if (!_objCtrFnString) {\n            _fnToString = Function[PROTOTYPE][TO_STRING];\n            _objCtrFnString = _fnToString[CALL](ObjClass);\n        }\n        try {\n            var proto = objGetPrototypeOf(value);\n            result = !proto;\n            if (!result) {\n                if (objHasOwnProperty(proto, CONSTRUCTOR)) {\n                    proto = proto[CONSTRUCTOR];\n                }\n                result = proto && typeof proto === FUNCTION && _fnToString[CALL](proto) === _objCtrFnString;\n            }\n        }\n        catch (ex) {\n        }\n    }\n    return result;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _defaultDeepCopyHandler(details) {\n    details.value && plainObjDeepCopyHandler(details);\n    return true;\n}\nvar defaultDeepCopyHandlers = [\n    arrayDeepCopyHandler,\n    plainObjDeepCopyHandler,\n    functionDeepCopyHandler,\n    dateDeepCopyHandler\n];\n/*#__NO_SIDE_EFFECTS__*/\nfunction _getSetVisited(visitMap, source, newPath, cb) {\n    var theEntry;\n    arrForEach(visitMap, function (entry) {\n        if (entry.k === source) {\n            theEntry = entry;\n            return -1;\n        }\n    });\n    if (!theEntry) {\n        theEntry = { k: source, v: source };\n        visitMap.push(theEntry);\n        cb(theEntry);\n    }\n    return theEntry.v;\n}\nfunction _deepCopy(visitMap, value, ctx, key) {\n    var userHandler = ctx.handler;\n    var newPath = ctx.path ? (key ? ctx.path.concat(key) : ctx.path) : [];\n    var newCtx = {\n        handler: ctx.handler,\n        src: ctx.src,\n        path: newPath\n    };\n    var theType = typeof value;\n    var isPlain = false;\n    var isPrim = false;\n    if (value && theType === OBJECT) {\n        isPlain = isPlainObject(value);\n    }\n    else {\n        isPrim = value === NULL_VALUE || isPrimitiveType(theType);\n    }\n    var details = {\n        type: theType,\n        isPrim: isPrim,\n        isPlain: isPlain,\n        value: value,\n        result: value,\n        path: newPath,\n        origin: ctx.src,\n        copy: function (source, newKey) {\n            return _deepCopy(visitMap, source, newKey ? newCtx : ctx, newKey);\n        },\n        copyTo: function (target, source) {\n            return _copyProps(visitMap, target, source, newCtx);\n        }\n    };\n    if (!details.isPrim) {\n        return _getSetVisited(visitMap, value, newPath, function (newEntry) {\n            objDefine(details, \"result\", {\n                g: function () {\n                    return newEntry.v;\n                },\n                s: function (newValue) {\n                    newEntry.v = newValue;\n                }\n            });\n            var idx = 0;\n            var handler = userHandler;\n            while (!(handler || (idx < defaultDeepCopyHandlers.length ? defaultDeepCopyHandlers[idx++] : _defaultDeepCopyHandler))[CALL](ctx, details)) {\n                handler = NULL_VALUE;\n            }\n        });\n    }\n    if (userHandler && userHandler[CALL](ctx, details)) {\n        return details.result;\n    }\n    return value;\n}\nfunction _copyProps(visitMap, target, source, ctx) {\n    if (!isNullOrUndefined(source)) {\n        for (var key in source) {\n            target[key] = _deepCopy(visitMap, source[key], ctx, key);\n        }\n    }\n    return target;\n}\nfunction objCopyProps(target, source, handler) {\n    var ctx = {\n        handler: handler,\n        src: source,\n        path: []\n    };\n    return _copyProps([], target, source, ctx);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction objDeepCopy(source, handler) {\n    var ctx = {\n        handler: handler,\n        src: source\n    };\n    return _deepCopy([], source, ctx);\n}\nfunction arrayDeepCopyHandler(details) {\n    var value = details.value;\n    if (isArray(value)) {\n        var target = details.result = [];\n        target.length = value.length;\n        details.copyTo(target, value);\n        return true;\n    }\n    return false;\n}\nfunction dateDeepCopyHandler(details) {\n    var value = details.value;\n    if (isDate(value)) {\n        details.result = new Date(value.getTime());\n        return true;\n    }\n    return false;\n}\nfunction functionDeepCopyHandler(details) {\n    if (details.type === FUNCTION) {\n        return true;\n    }\n    return false;\n}\nfunction plainObjDeepCopyHandler(details) {\n    var value = details.value;\n    if (value && details.isPlain) {\n        var target = details.result = {};\n        details.copyTo(target, value);\n        return true;\n    }\n    return false;\n}\n\nfunction _doExtend(target, theArgs) {\n    arrForEach(theArgs, function (theArg) {\n        objCopyProps(target, theArg);\n    });\n    return target;\n}\nfunction deepExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {\n    return _doExtend(objDeepCopy(target) || {}, ArrSlice[CALL](arguments));\n}\nfunction objExtend(target, obj1, obj2, obj3, obj4, obj5, obj6) {\n    return _doExtend(target || {}, ArrSlice[CALL](arguments));\n}\n\nvar getLength = ( /*#__PURE__*/_unwrapProp(LENGTH));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction getIntValue(value, defValue) {\n    if (!isNullOrUndefined(value)) {\n        if (isNumber(value)) {\n            return value;\n        }\n        var theValue = parseInt(value, 10);\n        return isNaN(theValue) ? defValue : theValue;\n    }\n    return defValue;\n}\n\nvar _perf;\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasPerformance() {\n    return !!getPerformance();\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getPerformance() {\n    !_globalLazyTestHooks && _initTestHooks();\n    (!_perf || _globalLazyTestHooks.lzy) && (_perf = createCachedValue(safe((getInst), [\"performance\"]).v));\n    return _perf.v;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction perfNow() {\n    var perf = getPerformance();\n    if (perf && perf.now) {\n        return perf.now();\n    }\n    return utcNow();\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction elapsedTime(startTime) {\n    return perfNow() - startTime;\n}\n\nvar MATCH_ANY = \"(.*)\";\nvar MATCH_SINGLE = \"(.)\";\nfunction _createRegExp(value, escapeRgx, replaceFn, ignoreCase, fullMatch) {\n    // eslint-disable-next-line security/detect-non-literal-regexp\n    return new RegExp((fullMatch ? \"^\" : EMPTY) + replaceFn(value.replace(escapeRgx, \"\\\\$1\")) + (fullMatch ? \"$\" : EMPTY), ignoreCase ? \"i\" : \"\");\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createWildcardRegex(value, ignoreCase, fullMatch) {\n    return _createRegExp(asString(value), /([-+|^$#.\\?{}()\\[\\]\\\\/\\\"\\'])/g, function (value) {\n        return value.replace(/\\*/g, MATCH_ANY);\n    }, !!ignoreCase, fullMatch);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createFilenameRegex(value, ignoreCase, fullMatch) {\n    return _createRegExp(asString(value), /([-+|^$#.{}()\\\\\\/\\[\\]\\\"\\'])/g, function (value) {\n        return value.replace(/(\\\\\\\\|\\\\\\/|\\*|\\?)/g, function (_all, g1) {\n            if (g1 == \"\\\\/\" || g1 == \"\\\\\\\\\") {\n                return \"[\\\\\\\\\\\\/]{1}\";\n            }\n            return g1 == \"*\" ? MATCH_ANY : MATCH_SINGLE;\n        });\n    }, !!ignoreCase, fullMatch);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction makeGlobRegex(value, ignoreCase, fullMatch) {\n    return _createRegExp(asString(value), /([-+|^$#.{}()\\\\\\/\\[\\]\\\"\\'])/g, function (value) {\n        return value.replace(/(\\*\\*\\\\[\\\\\\/]|\\\\\\\\|\\\\\\/|\\*\\*|\\*|\\?)/g, function (_all, g1) {\n            if (g1 == \"**\\\\/\" || g1 == \"**\\\\\\\\\") {\n                return \"(.*[\\\\\\\\\\\\/])*\";\n            }\n            if (g1 === \"\\\\/\" || g1 == \"\\\\\\\\\") {\n                return \"[\\\\\\\\\\\\/]{1}\";\n            }\n            if (g1 === \"**\") {\n                return MATCH_ANY;\n            }\n            return g1 === \"*\" ? \"([^\\\\\\\\\\\\/]*)\" : \"([^\\\\\\\\\\\\/]{1})\";\n        });\n    }, !!ignoreCase, fullMatch);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction safeGetLazy(cb, defValue) {\n    return getLazy(function () {\n        var result = safe(cb);\n        return result.e ? defValue : result.v;\n    });\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction _checkLength(value, props) {\n    var result;\n    arrForEach(props, function (prop) {\n        if (prop in value) {\n            var propValue = value[prop];\n            result = (isFunction(propValue) ? propValue() : propValue) > 0;\n            return -1;\n        }\n    });\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction _hasValue(value, depth) {\n    var result = value === false || value === 0;\n    if (!result && !isNullOrUndefined(value)) {\n        if (isArray(value)) {\n            result = value[LENGTH] > 0;\n        }\n        else if (isDate(value)) {\n            result = !isNaN(value.getTime());\n        }\n        else if (isBoolean(value)) {\n            return true;\n        }\n        else if (isObject(value)) {\n            try {\n                var chkValue = _checkLength(value, [LENGTH, \"byteLength\", \"size\", \"count\"]);\n                if (isBoolean(chkValue)) {\n                    return chkValue;\n                }\n                if (isFunction(value.valueOf) && depth < 5) {\n                    return _hasValue(value.valueOf(), ++depth);\n                }\n            }\n            catch (e) {\n            }\n            return !!objKeys(value)[LENGTH];\n        }\n        else {\n            result = isTruthy(value);\n        }\n    }\n    return result;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasValue(value) {\n    return _hasValue(value, 0);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createIterable(ctx) {\n    return makeIterable({}, ctx);\n}\nfunction makeIterable(target, ctx) {\n    var itSymbol = getKnownSymbol(3 );\n    function _createIterator() {\n        return createIterator(ctx);\n    }\n    target[itSymbol] = _createIterator;\n    return target;\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction createIterator(ctx) {\n    var isDone = false;\n    function _value() {\n        return ctx.v;\n    }\n    function _next() {\n        isDone = isDone || (ctx.n ? ctx.n(arguments) : true);\n        var result = {\n            done: isDone\n        };\n        if (!isDone) {\n            objDefine(result, \"value\", { g: _value });\n        }\n        return result;\n    }\n    function _return(value) {\n        isDone = true;\n        return {\n            done: true,\n            value: ctx.r && ctx.r(value)\n        };\n    }\n    function _throw(e) {\n        isDone = true;\n        return {\n            done: true,\n            value: ctx.t && ctx.t(e)\n        };\n    }\n    var theIterator = {\n        next: _next\n    };\n    if (ctx.r) {\n        theIterator.return = _return;\n    }\n    if (ctx.t) {\n        theIterator.throw = _throw;\n    }\n    return theIterator;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createArrayIterator(values) {\n    var idx = -1;\n    var theValues = values ? values.slice() : [];\n    var len = theValues[LENGTH];\n    function _value() {\n        if (idx >= 0 && idx < len) {\n            return theValues[idx];\n        }\n    }\n    function _getNext() {\n        idx++;\n        return idx >= len;\n    }\n    var ctx = {\n        n: _getNext\n    };\n    objDefine(ctx, \"v\", { g: _value });\n    return createIterator(ctx);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction createRangeIterator(start, end, step) {\n    var nextValue = start;\n    var theValue = UNDEF_VALUE;\n    if (isNullOrUndefined(end)) {\n        end = start;\n    }\n    var theStep = step || ((start <= end) ? 1 : -1);\n    function _value() {\n        return theValue;\n    }\n    function _getNext() {\n        var isDone = false;\n        if (theStep > 0) {\n            isDone = nextValue > end;\n        }\n        else {\n            isDone = nextValue < end;\n        }\n        if (!isDone) {\n            theValue = nextValue;\n            nextValue += theStep;\n        }\n        return isDone;\n    }\n    var ctx = {\n        n: _getNext\n    };\n    objDefine(ctx, \"v\", { g: _value });\n    return createIterator(ctx);\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrSymSplit(value, splitter, limit) {\n    var splitFn = splitter && splitter[getKnownSymbol(9 )];\n    return splitFn ? splitFn(value, limit) : [value];\n}\n\nvar strSplit = ( /*#__PURE__*/_unwrapFunction(\"split\", StrProto));\nvar strSymSplit = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"split\", StrProto, !hasSymbol() ? polyStrSymSplit : null));\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction getValueByKey(target, path, defValue) {\n    if (!path || !target) {\n        return defValue;\n    }\n    var parts = strSplit(path, \".\");\n    var cnt = parts.length;\n    for (var lp = 0; lp < cnt && !isNullOrUndefined(target); lp++) {\n        target = target[parts[lp]];\n    }\n    return (!isNullOrUndefined(target) ? target : defValue);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction getValueByIter(target, iter, defValue) {\n    if (!iter || !target) {\n        return defValue;\n    }\n    iterForOf(iter, function (value) {\n        if (isNullOrUndefined(target)) {\n            return -1;\n        }\n        target = target[value];\n    });\n    return (!isNullOrUndefined(target) ? target : defValue);\n}\nfunction setValueByKey(target, path, value) {\n    if (target && path) {\n        var parts = strSplit(path, \".\");\n        var lastKey = parts.pop();\n        arrForEach(parts, function (key) {\n            if (isNullOrUndefined(target[key])) {\n                target[key] = {};\n            }\n            target = target[key];\n        });\n        target[lastKey] = value;\n    }\n}\nfunction setValueByIter(target, iter, value) {\n    if (target && iter) {\n        var lastKey_1;\n        iterForOf(iter, function (key) {\n            if (lastKey_1) {\n                if (isNullOrUndefined(target[lastKey_1])) {\n                    target[lastKey_1] = {};\n                }\n                target = target[lastKey_1];\n            }\n            lastKey_1 = key;\n        });\n        target[lastKey_1] = value;\n    }\n}\n\nvar strEndsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"endsWith\", StrProto, polyStrEndsWith));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrEndsWith(value, searchString, length) {\n    if (!isString(value)) {\n        throwTypeError(\"'\" + dumpObj(value) + \"' is not a string\");\n    }\n    var searchValue = isString(searchString) ? searchString : asString(searchString);\n    var end = !isUndefined(length) && length < value[LENGTH] ? length : value[LENGTH];\n    return strSubstring(value, end - searchValue[LENGTH], end) === searchValue;\n}\n\nvar strIndexOf = ( /*#__PURE__*/_unwrapFunction(\"indexOf\", StrProto));\nvar strLastIndexOf = ( /*#__PURE__*/_unwrapFunction(\"lastIndexOf\", StrProto));\n\nvar strIncludes = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"includes\", StrProto, polyStrIncludes));\nvar strContains = ( /*#__PURE__*/_pureAssign(strIncludes));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrIncludes(value, searchString, position) {\n    if (isRegExp(searchString)) {\n        throwTypeError(\"'searchString' must not be a regular expression\" + dumpObj(searchString));\n    }\n    return strIndexOf(value, asString(searchString), position) !== -1;\n}\n\n/*#__NO_SIDE_EFFECTS__*/\nfunction strIsNullOrWhiteSpace(value) {\n    if (isString(value)) {\n        return value.replace(/[\\s\\t\\r\\n\\f]+/g, EMPTY) === EMPTY;\n    }\n    return isNullOrUndefined(value);\n}\n/*#__NO_SIDE_EFFECTS__*/\nfunction strIsNullOrEmpty(value) {\n    if (isString(value)) {\n        return value === EMPTY;\n    }\n    return isNullOrUndefined(value);\n}\n\nvar strStartsWith = ( /*#__PURE__*/_unwrapFunctionWithPoly(\"startsWith\", StrProto, polyStrStartsWith));\n/*#__NO_SIDE_EFFECTS__*/\nfunction polyStrStartsWith(value, searchString, position) {\n    if (!isString(value)) {\n        throwTypeError(\"'\" + dumpObj(value) + \"' is not a string\");\n    }\n    var searchValue = isString(searchString) ? searchString : asString(searchString);\n    var pos = position > 0 ? position : 0;\n    return strSubstring(value, pos, pos + searchValue[LENGTH]) === searchValue;\n}\n\nvar REF = \"ref\";\nvar UNREF = \"unref\";\nvar HAS_REF = \"hasRef\";\nvar ENABLED = \"enabled\";\n/*#__NO_SIDE_EFFECTS__*/\nfunction _createTimerHandler(startTimer, refreshFn, cancelFn) {\n    var ref = true;\n    var timerId = startTimer ? refreshFn(NULL_VALUE) : NULL_VALUE;\n    var theTimerHandler;\n    function _unref() {\n        ref = false;\n        timerId && timerId[UNREF] && timerId[UNREF]();\n        return theTimerHandler;\n    }\n    function _cancel() {\n        timerId && cancelFn(timerId);\n        timerId = NULL_VALUE;\n    }\n    function _refresh() {\n        timerId = refreshFn(timerId);\n        if (!ref) {\n            _unref();\n        }\n        return theTimerHandler;\n    }\n    function _setEnabled(value) {\n        !value && timerId && _cancel();\n        value && !timerId && _refresh();\n    }\n    theTimerHandler = {\n        cancel: _cancel,\n        refresh: _refresh\n    };\n    theTimerHandler[HAS_REF] = function () {\n        if (timerId && timerId[HAS_REF]) {\n            return timerId[HAS_REF]();\n        }\n        return ref;\n    };\n    theTimerHandler[REF] = function () {\n        ref = true;\n        timerId && timerId[REF] && timerId[REF]();\n        return theTimerHandler;\n    };\n    theTimerHandler[UNREF] = _unref;\n    theTimerHandler = objDefineProp(theTimerHandler, ENABLED, {\n        get: function () { return !!timerId; },\n        set: _setEnabled\n    });\n    return {\n        h: theTimerHandler,\n        dn: function () {\n            timerId = NULL_VALUE;\n        }\n    };\n}\n\nfunction _createTimeoutWith(startTimer, overrideFn, theArgs) {\n    var isArr = isArray(overrideFn);\n    var len = isArr ? overrideFn.length : 0;\n    var setFn = (len > 0 ? overrideFn[0] : (!isArr ? overrideFn : UNDEF_VALUE)) || setTimeout;\n    var clearFn = (len > 1 ? overrideFn[1] : UNDEF_VALUE) || clearTimeout;\n    var timerFn = theArgs[0];\n    theArgs[0] = function () {\n        handler.dn();\n        fnApply(timerFn, UNDEF_VALUE, ArrSlice[CALL](arguments));\n    };\n    var handler = _createTimerHandler(startTimer, function (timerId) {\n        if (timerId) {\n            if (timerId.refresh) {\n                timerId.refresh();\n                return timerId;\n            }\n            fnApply(clearFn, UNDEF_VALUE, [timerId]);\n        }\n        return fnApply(setFn, UNDEF_VALUE, theArgs);\n    }, function (timerId) {\n        fnApply(clearFn, UNDEF_VALUE, [timerId]);\n    });\n    return handler.h;\n}\nfunction scheduleTimeout(callback, timeout) {\n    return _createTimeoutWith(true, UNDEF_VALUE, ArrSlice[CALL](arguments));\n}\nfunction scheduleTimeoutWith(overrideFn, callback, timeout) {\n    return _createTimeoutWith(true, overrideFn, ArrSlice[CALL](arguments, 1));\n}\nfunction createTimeout(callback, timeout) {\n    return _createTimeoutWith(false, UNDEF_VALUE, ArrSlice[CALL](arguments));\n}\nfunction createTimeoutWith(overrideFn, callback, timeout) {\n    return _createTimeoutWith(false, overrideFn, ArrSlice[CALL](arguments, 1));\n}\n\nvar _defaultIdleTimeout = 100;\nvar _maxExecutionTime = 50;\n/*#__NO_SIDE_EFFECTS__*/\nfunction hasIdleCallback() {\n    return !!( /*#__PURE__*/getIdleCallback());\n}\nvar getIdleCallback = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"requestIdleCallback\"]));\nvar getCancelIdleCallback = ( /*#__PURE__*/_getGlobalInstFn(getInst, [\"cancelIdleCallback\"]));\nfunction setDefaultIdleTimeout(timeout) {\n    _defaultIdleTimeout = timeout;\n}\nfunction setDefaultMaxExecutionTime(maxTime) {\n    _maxExecutionTime = maxTime;\n}\nfunction scheduleIdleCallback(callback, options) {\n    function _createDeadline(timedOut) {\n        var startTime = perfNow();\n        return {\n            didTimeout: timedOut,\n            timeRemaining: function () {\n                return _maxExecutionTime - elapsedTime(startTime);\n            }\n        };\n    }\n    if (hasIdleCallback()) {\n        var handler_1 = _createTimerHandler(true, function (idleId) {\n            idleId && getCancelIdleCallback()(idleId);\n            return getIdleCallback()(function (deadline) {\n                handler_1.dn();\n                callback(deadline || _createDeadline(false));\n            }, options);\n        }, function (idleId) {\n            getCancelIdleCallback()(idleId);\n        });\n        return handler_1.h;\n    }\n    var timeout = (options || {}).timeout;\n    if (isUndefined(timeout)) {\n        timeout = _defaultIdleTimeout;\n    }\n    return scheduleTimeout(function () {\n        callback(_createDeadline(true));\n    }, timeout);\n}\n\nfunction scheduleInterval(callback, timeout) {\n    var theArguments = ArrSlice[CALL](arguments);\n    var handler = _createTimerHandler(true, function (intervalId) {\n        intervalId && clearInterval(intervalId);\n        return fnApply(setInterval, UNDEF_VALUE, theArguments);\n    }, function (intervalId) {\n        fnApply(clearInterval, UNDEF_VALUE, [intervalId]);\n    });\n    return handler.h;\n}\n\nexport { arrAppend, arrContains, arrEvery, arrFilter, arrFind, arrFindIndex, arrFindLast, arrFindLastIndex, arrForEach, arrFrom, arrIncludes, arrIndexOf, arrLastIndexOf, arrMap, arrReduce, arrSlice, arrSome, arrayDeepCopyHandler, asString, createArrayIterator, createCachedValue, createCustomError, createDeferredCachedValue, createEnum, createEnumKeyMap, createEnumValueMap, createFilenameRegex, createFnDeferredProxy, createIterable, createIterator, createProxyFuncs, createRangeIterator, createSimpleMap, createTimeout, createTimeoutWith, createTypeMap, createWildcardRegex, dateDeepCopyHandler, deepExtend, dumpObj, elapsedTime, encodeAsHtml, encodeAsJson, fnApply, fnBind, fnCall, functionDeepCopyHandler, getCancelIdleCallback, getDocument, getGlobal, getHistory, getIdleCallback, getInst, getIntValue, getKnownSymbol, getLazy, getLength, getNavigator, getPerformance, getSymbol, getValueByIter, getValueByKey, getWindow, hasDocument, hasHistory, hasIdleCallback, hasNavigator, hasPerformance, hasSymbol, hasValue, hasWindow, isArray, isArrayBuffer, isBlob, isBoolean, isDate, isDefined, isError, isFile, isFormData, isFunction, isIterable, isIterator, isNode, isNotTruthy, isNullOrUndefined, isNumber, isObject, isPlainObject, isPrimitive, isPrimitiveType, isPromise, isPromiseLike, isRegExp, isStrictNullOrUndefined, isStrictUndefined, isString, isSymbol, isThenable, isTruthy, isTypeof, isUndefined, isWebWorker, iterForOf, lazySafeGetInst, makeGlobRegex, makeIterable, mathCeil, mathFloor, mathMax, mathMin, mathToInt, mathTrunc, newSymbol, normalizeJsName, objAssign, objCopyProps, objCreate, objDeepCopy, objDeepFreeze, objDefine, objDefineAccessors, objDefineGet, objDefineProp, objDefineProperties, objDefineProps, objEntries, objExtend, objForEachKey, objFreeze, objGetOwnPropertyDescriptor, objGetPrototypeOf, objHasOwn, objHasOwnProperty, objKeys, objSeal, objSetPrototypeOf, objToString, perfNow, plainObjDeepCopyHandler, polyArrFind, polyArrFindIndex, polyArrFindLast, polyArrFindLastIndex, polyArrFrom, polyArrIncludes, polyGetKnownSymbol, polyIsArray, polyNewSymbol, polyObjEntries, polyObjHasOwn, polyObjKeys, polyStrIncludes, polyStrSubstr, polyStrSymSplit, polyStrTrim, polyStrTrimEnd, polyStrTrimStart, polySymbolFor, polySymbolKeyFor, polyUtcNow, readArgs, safe, safeGet, safeGetLazy, scheduleIdleCallback, scheduleInterval, scheduleTimeout, scheduleTimeoutWith, setBypassLazyCache, setDefaultIdleTimeout, setDefaultMaxExecutionTime, setValueByIter, setValueByKey, strCamelCase, strContains, strEndsWith, strIncludes, strIndexOf, strIsNullOrEmpty, strIsNullOrWhiteSpace, strKebabCase, strLastIndexOf, strLeft, strLetterCase, strLower, strPadEnd, strPadStart, strRepeat, strRight, strSlice, strSnakeCase, strSplit, strStartsWith, strSubstr, strSubstring, strSymSplit, strTrim, strTrimEnd, strTrimLeft, strTrimRight, strTrimStart, strUpper, symbolFor, symbolKeyFor, throwError, throwRangeError, throwTypeError, throwUnsupported, utcNow };\n//# sourceMappingURL=ts-utils.js.map\n","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { REJECTED } from \"../internal/constants\";\r\n/**\r\n * Helper to coallesce the promise resolved / reject into a single callback to simplify error handling.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait to be resolved or rejected.\r\n * @param cb - The callback function to call with the resulting value, if the value is not a\r\n * promise like value then the callback is called synchronously, if the value is a promise then\r\n * the callback will be called once the promise completes the resulting value will be passed as an\r\n * IAwaitResponse instance, it will be called whether any promise resolves or rejects.\r\n * @returns The value returned by the `cb` callback function, if the value is a promise then the return value\r\n * of the callback will be returned as a promise whether the callback returns a promise or not.\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via doAwaitResponse\r\n * doAwaitResponse(promise, (value) => {\r\n *     if (!value.rejected) {\r\n *          // Do something with the value\r\n *     } else {\r\n *         // Do something with the reason\r\n *     }\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwaitResponse(42, (value) => {\r\n *     if (!value.rejected) {\r\n *         // Do something with the value\r\n *     } else {\r\n *        // This will never be true as the value is not a promise\r\n *     }\r\n * });\r\n * ```\r\n */\r\nexport function doAwaitResponse(value, cb) {\r\n    return doAwait(value, function (value) {\r\n        return cb ? cb({\r\n            status: \"fulfilled\",\r\n            rejected: false,\r\n            value: value\r\n        }) : value;\r\n    }, function (reason) {\r\n        return cb ? cb({\r\n            status: REJECTED,\r\n            rejected: true,\r\n            reason: reason\r\n        }) : reason;\r\n    });\r\n}\r\n/**\r\n * Wait for the promise to resolve or reject, if resolved the callback function will be called with it's value and if\r\n * rejected the rejectFn will be called with the reason. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value.\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param resolveFn - The callback to call on the promise successful resolving.\r\n * @param rejectFn - The callback to call when the promise rejects\r\n * @returns The passed value, if it is a promise and there is either a resolve or reject handler\r\n * then it will return a chained promise with the value from the resolve or reject handler (depending\r\n * whether it resolve or rejects)\r\n * @example\r\n * ```ts\r\n * let promise = createPromise<number>((resolve, reject) => {\r\n *     resolve(42);\r\n * });\r\n *\r\n * // Handle via a chained promise\r\n * let chainedPromise = promise.then((value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // Handle via doAwait\r\n * doAwait(promise, (value) => {\r\n *     // Do something with the value\r\n * });\r\n *\r\n * // It can also handle the raw value, so you could process the result of either a\r\n * // synchrounous return of the value or a Promise\r\n * doAwait(42, (value) => {\r\n *     // Do something with the value\r\n * });\r\n * ```\r\n */\r\nexport function doAwait(value, resolveFn, rejectFn, finallyFn) {\r\n    var result = value;\r\n    try {\r\n        if (isPromiseLike(value)) {\r\n            if (resolveFn || rejectFn) {\r\n                result = value.then(resolveFn, rejectFn);\r\n            }\r\n        }\r\n        else {\r\n            try {\r\n                if (resolveFn) {\r\n                    result = resolveFn(value);\r\n                }\r\n            }\r\n            catch (err) {\r\n                if (rejectFn) {\r\n                    result = rejectFn(err);\r\n                }\r\n                else {\r\n                    throw err;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    finally {\r\n        if (finallyFn) {\r\n            doFinally(result, finallyFn);\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Wait for the promise to resolve or reject and then call the finallyFn. If the passed promise argument is not a promise the callback\r\n * will be called synchronously with the value. If the passed promise doesn't implement finally then a finally implementation will be\r\n * simulated using then(..., ...).\r\n * @group Await Helper\r\n * @param value - The value or promise like value to wait for\r\n * @param finallyFn - The finally function to call once the promise has resolved or rejected\r\n */\r\nexport function doFinally(value, finallyFn) {\r\n    var result = value;\r\n    if (finallyFn) {\r\n        if (isPromiseLike(value)) {\r\n            if (value.finally) {\r\n                result = value.finally(finallyFn);\r\n            }\r\n            else {\r\n                // Simulate finally if not available\r\n                result = value.then(function (value) {\r\n                    finallyFn();\r\n                    return value;\r\n                }, function (reason) {\r\n                    finallyFn();\r\n                    throw reason;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            finallyFn();\r\n        }\r\n    }\r\n    return result;\r\n}\r\n//# sourceMappingURL=await.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { dumpObj, getDocument, getInst, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nvar DISPATCH_EVENT = \"dispatchEvent\";\r\nvar _hasInitEvent;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Helper function to determine if the document has the `initEvent` function\r\n * @param doc - The document to check\r\n * @returns\r\n */\r\nfunction _hasInitEventFn(doc) {\r\n    var evt;\r\n    if (doc && doc.createEvent) {\r\n        evt = doc.createEvent(\"Event\");\r\n    }\r\n    return (!!evt && evt.initEvent);\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * @param target\r\n * @param evtName\r\n * @param populateEvent\r\n * @param useNewEvent\r\n */\r\nexport function emitEvent(target, evtName, populateEvent, useNewEvent) {\r\n    var doc = getDocument();\r\n    !_hasInitEvent && (_hasInitEvent = createCachedValue(!!safe(_hasInitEventFn, [doc]).v));\r\n    var theEvt = _hasInitEvent.v ? doc.createEvent(\"Event\") : (useNewEvent ? new Event(evtName) : {});\r\n    populateEvent && populateEvent(theEvt);\r\n    if (_hasInitEvent.v) {\r\n        theEvt.initEvent(evtName, false, true);\r\n    }\r\n    if (theEvt && target[DISPATCH_EVENT]) {\r\n        target[DISPATCH_EVENT](theEvt);\r\n    }\r\n    else {\r\n        var handler = target[\"on\" + evtName];\r\n        if (handler) {\r\n            handler(theEvt);\r\n        }\r\n        else {\r\n            var theConsole = getInst(\"console\");\r\n            theConsole && (theConsole[\"error\"] || theConsole[\"log\"])(evtName, dumpObj(theEvt));\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=event.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrSlice, dumpObj, getKnownSymbol, hasSymbol, isFunction, isPromiseLike, isUndefined, throwTypeError, objToString, scheduleTimeout, getWindow, isNode, getGlobal, objDefine, objDefineProp, iterForOf, isIterable, isArray, arrForEach, createCachedValue, safe, getInst, createCustomError } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"./await\";\r\nimport { _addDebugState, _promiseDebugEnabled } from \"./debug\";\r\nimport { STRING_STATES } from \"../internal/state\";\r\nimport { emitEvent } from \"./event\";\r\nimport { REJECTED, STR_PROMISE } from \"../internal/constants\";\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"./debug\";\r\n//#endif\r\nvar NODE_UNHANDLED_REJECTION = \"unhandledRejection\";\r\nvar UNHANDLED_REJECTION = NODE_UNHANDLED_REJECTION.toLowerCase();\r\nvar _currentPromiseId = [];\r\nvar _uniquePromiseId = 0;\r\nvar _unhandledRejectionTimeout = 10;\r\nvar _aggregationError;\r\nvar _hasPromiseRejectionEvent;\r\nfunction dumpFnObj(value) {\r\n    if (isFunction(value)) {\r\n        return value.toString();\r\n    }\r\n    return dumpObj(value);\r\n}\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) function _getCaller(prefix: string, start: number) {\r\n//#:(!DEBUG)     let stack = new Error().stack;\r\n//#:(!DEBUG)     if (stack) {\r\n//#:(!DEBUG)         let lines = stack.split(\"\\n\");\r\n//#:(!DEBUG)         if (lines.length > start) {\r\n//#:(!DEBUG)             return prefix + \":\" + arrSlice(lines, start, start + 5).join(\"\\n\") + \"\\n...\";\r\n//#:(!DEBUG)         }\r\n//#:(!DEBUG)     }\r\n//#:(!DEBUG)     return null;\r\n//#:(!DEBUG) }\r\n//#endif\r\n/*#__NO_SIDE_EFFECTS__*/\r\nfunction _createAggregationError(values) {\r\n    !_aggregationError && (_aggregationError = createCachedValue(safe(getInst, [\"AggregationError\"]).v || createCustomError(\"AggregationError\", function (self, args) {\r\n        self.errors = args[0];\r\n    })));\r\n    return new _aggregationError.v(values);\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n *\r\n * Implementing a simple synchronous promise interface for support within any environment that\r\n * doesn't support the Promise API\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param processor - The function to use to process the pending\r\n * @param executor - The resolve function\r\n * @param additionalArgs - [Optional] Additional arguments that will be passed to the PromiseCreatorFn\r\n */\r\nexport function _createPromise(newPromise, processor, executor) {\r\n    var additionalArgs = arrSlice(arguments, 3);\r\n    var _state = 0 /* ePromiseState.Pending */;\r\n    var _hasResolved = false;\r\n    var _settledValue;\r\n    var _queue = [];\r\n    var _id = _uniquePromiseId++;\r\n    var _parentId = _currentPromiseId.length > 0 ? _currentPromiseId[_currentPromiseId.length - 1] : undefined;\r\n    var _handled = false;\r\n    var _unHandledRejectionHandler = null;\r\n    var _thePromise;\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.then\r\n    function _then(onResolved, onRejected) {\r\n        try {\r\n            _currentPromiseId.push(_id);\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            var thenPromise = newPromise(function (resolve, reject) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _getCaller(\"_then\", 7));\r\n                //#endif\r\n                // Queue the new promise returned to be resolved or rejected\r\n                // when this promise settles.\r\n                _queue.push(function () {\r\n                    // https://tc39.es/ecma262/#sec-newpromisereactionjob\r\n                    //let value: any;\r\n                    try {\r\n                        // First call the onFulfilled or onRejected handler, on the settled value\r\n                        // of this promise. If the corresponding `handler` does not exist, simply\r\n                        // pass through the settled value.\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling settled value \" + dumpFnObj(_settledValue));\r\n                        //#endif\r\n                        var handler = _state === 2 /* ePromiseState.Resolved */ ? onResolved : onRejected;\r\n                        var value = isUndefined(handler) ? _settledValue : (isFunction(handler) ? handler(_settledValue) : handler);\r\n                        //#ifdef DEBUG\r\n                        //#:(!DEBUG) _debugLog(_toString(), \"Handling Result \" + dumpFnObj(value));\r\n                        //#endif\r\n                        if (isPromiseLike(value)) {\r\n                            // The called handlers returned a new promise, so the chained promise\r\n                            // will follow the state of this promise.\r\n                            value.then(resolve, reject);\r\n                        }\r\n                        else if (handler) {\r\n                            // If we have a handler then chained promises are always \"resolved\" with the result returned\r\n                            resolve(value);\r\n                        }\r\n                        else if (_state === 3 /* ePromiseState.Rejected */) {\r\n                            // If this promise is rejected then the chained promise should be rejected\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            reject(value);\r\n                        }\r\n                        else {\r\n                            // If this promise is fulfilled, then the chained promise is also fulfilled\r\n                            // with either the settled value of this promise or the return value of the handler.\r\n                            resolve(value);\r\n                        }\r\n                    }\r\n                    catch (e) {\r\n                        reject(e);\r\n                    }\r\n                });\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Added to Queue \" + _queue.length);\r\n                //#endif\r\n                // If this promise is already settled, then immediately process the callback we\r\n                // just added to the queue.\r\n                if (_hasResolved) {\r\n                    _processQueue();\r\n                }\r\n            }, additionalArgs);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Created -> \" + thenPromise.toString());\r\n            //#endif\r\n            return thenPromise;\r\n        }\r\n        finally {\r\n            _currentPromiseId.pop();\r\n        }\r\n    }\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.catch\r\n    function _catch(onRejected) {\r\n        // Reuse then onRejected to support rejection\r\n        return _then(undefined, onRejected);\r\n    }\r\n    // https://tc39.es/ecma262/#sec-promise.prototype.finally\r\n    function _finally(onFinally) {\r\n        var thenFinally = onFinally;\r\n        var catchFinally = onFinally;\r\n        if (isFunction(onFinally)) {\r\n            thenFinally = function (value) {\r\n                onFinally && onFinally();\r\n                return value;\r\n            };\r\n            catchFinally = function (reason) {\r\n                onFinally && onFinally();\r\n                throw reason;\r\n            };\r\n        }\r\n        return _then(thenFinally, catchFinally);\r\n    }\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n    function _processQueue() {\r\n        if (_queue.length > 0) {\r\n            // The onFulfilled and onRejected handlers must be called asynchronously. Thus,\r\n            // we make a copy of the queue and work on it once the current call stack unwinds.\r\n            var pending = _queue.slice();\r\n            _queue = [];\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing queue \" + pending.length);\r\n            //#endif\r\n            _handled = true;\r\n            _unHandledRejectionHandler && _unHandledRejectionHandler.cancel();\r\n            _unHandledRejectionHandler = null;\r\n            processor(pending);\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Processing done\");\r\n            //#endif\r\n        }\r\n        else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Empty Processing queue \");\r\n            //#endif\r\n        }\r\n    }\r\n    function _createSettleIfFn(newState, allowState) {\r\n        return function (theValue) {\r\n            if (_state === allowState) {\r\n                if (newState === 2 /* ePromiseState.Resolved */ && isPromiseLike(theValue)) {\r\n                    _state = 1 /* ePromiseState.Resolving */;\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Resolving\");\r\n                    //#endif\r\n                    theValue.then(_createSettleIfFn(2 /* ePromiseState.Resolved */, 1 /* ePromiseState.Resolving */), _createSettleIfFn(3 /* ePromiseState.Rejected */, 1 /* ePromiseState.Resolving */));\r\n                    return;\r\n                }\r\n                _state = newState;\r\n                _hasResolved = true;\r\n                _settledValue = theValue;\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), _strState());\r\n                //#endif\r\n                _processQueue();\r\n                if (!_handled && newState === 3 /* ePromiseState.Rejected */ && !_unHandledRejectionHandler) {\r\n                    //#ifdef DEBUG\r\n                    //#:(!DEBUG) _debugLog(_toString(), \"Setting up unhandled rejection\");\r\n                    //#endif\r\n                    _unHandledRejectionHandler = scheduleTimeout(_notifyUnhandledRejection, _unhandledRejectionTimeout);\r\n                }\r\n            }\r\n            else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Already \" + _strState());\r\n                //#endif\r\n            }\r\n        };\r\n    }\r\n    function _notifyUnhandledRejection() {\r\n        if (!_handled) {\r\n            // Mark as handled so we don't keep notifying\r\n            _handled = true;\r\n            if (isNode()) {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + NODE_UNHANDLED_REJECTION);\r\n                //#endif\r\n                process.emit(NODE_UNHANDLED_REJECTION, _settledValue, _thePromise);\r\n            }\r\n            else {\r\n                var gbl = getWindow() || getGlobal();\r\n                !_hasPromiseRejectionEvent && (_hasPromiseRejectionEvent = createCachedValue(safe((getInst), [STR_PROMISE + \"RejectionEvent\"]).v));\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_toString(), \"Emitting \" + UNHANDLED_REJECTION);\r\n                //#endif\r\n                emitEvent(gbl, UNHANDLED_REJECTION, function (theEvt) {\r\n                    objDefine(theEvt, \"promise\", { g: function () { return _thePromise; } });\r\n                    theEvt.reason = _settledValue;\r\n                    return theEvt;\r\n                }, !!_hasPromiseRejectionEvent.v);\r\n            }\r\n        }\r\n    }\r\n    _thePromise = {\r\n        then: _then,\r\n        \"catch\": _catch,\r\n        finally: _finally\r\n    };\r\n    objDefineProp(_thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n    if (_promiseDebugEnabled) {\r\n        // eslint-disable-next-line brace-style\r\n        _addDebugState(_thePromise, _strState, function () { return objToString(_settledValue); }, function () { return _handled; });\r\n    }\r\n    if (hasSymbol()) {\r\n        _thePromise[getKnownSymbol(11 /* WellKnownSymbols.toStringTag */)] = \"IPromise\";\r\n    }\r\n    var createStack;\r\n    //#if DEBUG\r\n    //#:(!{DEBUG}) createStack = _getCaller(\"Created\", 5);\r\n    //#endif\r\n    function _toString() {\r\n        return \"IPromise\" + (_promiseDebugEnabled ? \"[\" + _id + (!isUndefined(_parentId) ? (\":\" + _parentId) : \"\") + \"]\" : \"\") + \" \" + _strState() + (_hasResolved ? (\" - \" + dumpFnObj(_settledValue)) : \"\") + (createStack ? \" @ \" + createStack : \"\");\r\n    }\r\n    _thePromise.toString = _toString;\r\n    (function _initialize() {\r\n        if (!isFunction(executor)) {\r\n            throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpFnObj(executor));\r\n        }\r\n        var _rejectFn = _createSettleIfFn(3 /* ePromiseState.Rejected */, 0 /* ePromiseState.Pending */);\r\n        try {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Executing\");\r\n            //#endif\r\n            executor.call(_thePromise, _createSettleIfFn(2 /* ePromiseState.Resolved */, 0 /* ePromiseState.Pending */), _rejectFn);\r\n        }\r\n        catch (e) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_toString(), \"Exception thrown: \" + dumpFnObj(e));\r\n            //#endif\r\n            _rejectFn(e);\r\n        }\r\n        //#ifdef DEBUG\r\n        //#:(!DEBUG) _debugLog(_toString(), \"~Executing\");\r\n        //#endif\r\n    })();\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _debugLog(_toString(), \"Returning\");\r\n    //#endif\r\n    return _thePromise;\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Returns a function which when called will return a new Promise object that resolves to an array of the\r\n * results from the input promises. The returned promise will resolve when all of the inputs' promises have\r\n * resolved, or if the input contains no promises. It rejects immediately upon any of the input promises\r\n * rejected or non-promises throwing an error, and will reject with this first rejection message / error.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllPromise(newPromise) {\r\n    return function (input) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            try {\r\n                var values_1 = [];\r\n                var pending_1 = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n                iterForOf(input, function (item, idx) {\r\n                    if (item) {\r\n                        pending_1++;\r\n                        doAwait(item, function (value) {\r\n                            // Set the result values\r\n                            values_1[idx] = value;\r\n                            if (--pending_1 === 0) {\r\n                                resolve(values_1);\r\n                            }\r\n                        }, reject);\r\n                    }\r\n                });\r\n                // Now decrement the pending so that we finish correctly\r\n                pending_1--;\r\n                if (pending_1 === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values_1);\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * The createResolvedPromise returns a PromiseLike object that is resolved with a given value. If the value is\r\n * PromiseLike (i.e. has a \"then\" method), the returned promise will \"follow\" that thenable, adopting its eventual\r\n * state; otherwise the returned promise will be fulfilled with the value. This function flattens nested layers\r\n * of promise-like objects (e.g. a promise that resolves to a promise that resolves to something) into a single layer.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param value Argument to be resolved by this Promise. Can also be a Promise or a thenable to resolve.\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createResolvedPromise(newPromise) {\r\n    return function (value) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        if (isPromiseLike(value)) {\r\n            return value;\r\n        }\r\n        return newPromise(function (resolve) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Resolving Promise\");\r\n            //#endif\r\n            resolve(value);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * Return a promise like object that is rejected with the given reason.\r\n * @param newPromise - The delegate function used to create a new promise object\r\n * @param reason - The rejection reason\r\n * @param additionalArgs - Any additional arguments that should be passed to the delegate to assist with the creation of\r\n * the new promise instance.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRejectedPromise(newPromise) {\r\n    return function (reason) {\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (_resolve, reject) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(String(this), \"Rejecting Promise\");\r\n            //#endif\r\n            reject(reason);\r\n        }, additionalArgs);\r\n    };\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function which when called will return a new Promise object that resolves to an array of\r\n * IPromiseResults from the input promises. The returned promise will resolve when all of the inputs'\r\n * promises have resolved or rejected, or if the input contains no promises. It will resolve only after\r\n * all input promises have been fulfilled (resolve or rejected).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will be resolved when all arguments are resolved.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAllSettledPromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var values = [];\r\n            var pending = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n            function processItem(item, idx) {\r\n                pending++;\r\n                doAwaitResponse(item, function (value) {\r\n                    if (value.rejected) {\r\n                        values[idx] = {\r\n                            status: REJECTED,\r\n                            reason: value.reason\r\n                        };\r\n                    }\r\n                    else {\r\n                        values[idx] = {\r\n                            status: \"fulfilled\",\r\n                            value: value.value\r\n                        };\r\n                    }\r\n                    if (--pending === 0) {\r\n                        resolve(values);\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0) {\r\n                    // All promises were either resolved or where not a promise\r\n                    resolve(values);\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n/**\r\n * @ignore\r\n * @internal\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise settles with the eventual state of the first promise that settles.\r\n * @description The returned promise is one of the promise concurrency methods. It's useful when you want\r\n * the first async task to complete, but do not care about its eventual state (i.e. it can either succeed\r\n * or fail).\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the first promise to settle is fulfilled,\r\n * and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises,\r\n * the returned promise is still settled.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createRacePromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var isDone = false;\r\n            function processItem(item) {\r\n                doAwaitResponse(item, function (value) {\r\n                    if (!isDone) {\r\n                        isDone = true;\r\n                        if (value.rejected) {\r\n                            reject(value.reason);\r\n                        }\r\n                        else {\r\n                            resolve(value.value);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * @since 0.5.0\r\n * Returns a function takes an iterable of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment\r\n * value. It rejects when all of the input's promises reject (including when an empty iterable is passed),\r\n * with an AggregateError containing an array of rejection reasons.\r\n * @param newPromise - The delegate function used to create a new promise object the new promise instance.\r\n * @returns A function to create a promise that will resolve when the any of the input's promises fulfills,\r\n * with this first fulfillment value. It rejects when all of the input's promises reject (including when\r\n * an empty iterable is passed), with an AggregateError containing an array of rejection reasons.\r\n */\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createAnyPromise(newPromise) {\r\n    var _args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        _args[_i - 1] = arguments[_i];\r\n    }\r\n    return createCachedValue(function (input) {\r\n        var _args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            _args[_i - 1] = arguments[_i];\r\n        }\r\n        var additionalArgs = arrSlice(arguments, 1);\r\n        return newPromise(function (resolve, reject) {\r\n            var theErros = [];\r\n            var pending = 1; // Prefix to 1 so we finish iterating over all of the input promises first\r\n            var isDone = false;\r\n            function processItem(item, idx) {\r\n                pending++;\r\n                doAwaitResponse(item, function (value) {\r\n                    if (!value.rejected) {\r\n                        isDone = true;\r\n                        resolve(value.value);\r\n                        return;\r\n                    }\r\n                    else {\r\n                        theErros[idx] = value.reason;\r\n                    }\r\n                    if (--pending === 0 && !isDone) {\r\n                        reject(_createAggregationError(theErros));\r\n                    }\r\n                });\r\n            }\r\n            try {\r\n                if (isArray(input)) {\r\n                    arrForEach(input, processItem);\r\n                }\r\n                else if (isIterable(input)) {\r\n                    iterForOf(input, processItem);\r\n                }\r\n                else {\r\n                    throwTypeError(\"Input is not an iterable\");\r\n                }\r\n                // Now decrement the pending so that we finish correctly\r\n                pending--;\r\n                if (pending === 0 && !isDone) {\r\n                    // All promises were either resolved or where not a promise\r\n                    reject(_createAggregationError(theErros));\r\n                }\r\n            }\r\n            catch (e) {\r\n                reject(e);\r\n            }\r\n        }, additionalArgs);\r\n    });\r\n}\r\n//# sourceMappingURL=base.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { objDefineProperties } from \"@nevware21/ts-utils\";\r\nvar _debugState;\r\nvar _debugResult;\r\nvar _debugHandled;\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nexport var _promiseDebugEnabled = false;\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) let _theLogger: (id: string, message: string) => void = null;\r\n//#endif\r\n/**\r\n * @internal\r\n * @ignore Internal function enable logging the internal state of the promise during execution, this code and references are\r\n * removed from the production artifacts\r\n */\r\nexport var _debugLog = /*#__PURE__*/ function (id, message) {\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) if (_theLogger) {\r\n    //#:(!DEBUG)     _theLogger(id, message);\r\n    //#:(!DEBUG) }\r\n    //#endif\r\n};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function to add the debug state to the promise so that it provides simular visibility as you would\r\n * see from native promises\r\n * @param thePromise - The Promise implementation\r\n * @param stateFn - The function to return the state of the promise\r\n * @param resultFn - The function to return the result (settled value) of the promise\r\n * @param handledFn - The function to return whether the promise has been handled (used for throwing\r\n * unhandled rejection events)\r\n */\r\nexport function _addDebugState(thePromise, stateFn, resultFn, handledFn) {\r\n    // While the IPromise implementations provide a `state` property, keeping the `[[PromiseState]]`\r\n    // as native promises also have a non-enumerable property of the same name\r\n    _debugState = _debugState || { toString: function () { return \"[[PromiseState]]\"; } };\r\n    _debugResult = _debugResult || { toString: function () { return \"[[PromiseResult]]\"; } };\r\n    _debugHandled = _debugHandled || { toString: function () { return \"[[PromiseIsHandled]]\"; } };\r\n    var props = {};\r\n    props[_debugState] = { get: stateFn };\r\n    props[_debugResult] = { get: resultFn };\r\n    props[_debugHandled] = { get: handledFn };\r\n    objDefineProperties(thePromise, props);\r\n}\r\n/**\r\n * Debug helper to enable internal debugging of the promise implementations. Disabled by default.\r\n * For the generated packages included in the npm package the `logger` will not be called as the\r\n * `_debugLog` function that uses this logger is removed during packaging.\r\n *\r\n * It is available directly from the repository for unit testing.\r\n *\r\n * @group Debug\r\n * @param enabled - Should debugging be enabled (defaults `false`, when `true` promises will have\r\n * additional debug properties and the `toString` will include extra details.\r\n * @param logger - Optional logger that will log internal state changes, only called in debug\r\n * builds as the calling function is removed is the production artifacts.\r\n * @example\r\n * ```ts\r\n * // The Id is the id of the promise\r\n * // The message is the internal debug message\r\n * function promiseDebugLogger(id: string, message: string) {\r\n *     if (console && console.log) {\r\n *         console.log(id, message);\r\n *     }\r\n * }\r\n *\r\n * setPromiseDebugState(true, promiseDebugLogger);\r\n *\r\n * // While the logger will not be called for the production packages\r\n * // Setting the `enabled` flag to tru will cause each promise to have\r\n * // the following additional properties added\r\n * // [[PromiseState]]; => Same as the `state` property\r\n * // [[PromiseResult]]; => The settled value\r\n * // [[PromiseIsHandled]] => Identifies if the promise has been handled\r\n * // It will also cause the `toString` for the promise to include additional\r\n * // debugging information\r\n * ```\r\n */\r\nexport function setPromiseDebugState(enabled, logger) {\r\n    _promiseDebugEnabled = enabled;\r\n    //#ifdef DEBUG\r\n    //#:(!DEBUG) _theLogger = logger;\r\n    //#endif\r\n}\r\n//# sourceMappingURL=debug.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrForEach, isNumber, scheduleIdleCallback, scheduleTimeout } from \"@nevware21/ts-utils\";\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items synchronously\r\n * @return An item processor\r\n */\r\nexport function syncItemProcessor(pending) {\r\n    arrForEach(pending, function (fn) {\r\n        try {\r\n            fn();\r\n        }\r\n        catch (e) {\r\n            // Don't let 1 failing handler break all others\r\n            // TODO: Add some form of error reporting (i.e. Call any registered JS error handler so the error is reported)\r\n        }\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items asynchronously using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function timeoutItemProcessor(timeout) {\r\n    var callbackTimeout = isNumber(timeout) ? timeout : 0;\r\n    return function (pending) {\r\n        scheduleTimeout(function () {\r\n            syncItemProcessor(pending);\r\n        }, callbackTimeout);\r\n    };\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Return an item processor that processes all of the pending items using an idle callback (if available) or based on\r\n * a timeout (when `requestIdenCallback` is not supported) using the optional timeout.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @return An item processor\r\n */\r\nexport function idleItemProcessor(timeout) {\r\n    var options;\r\n    if (timeout >= 0) {\r\n        options = {\r\n            timeout: +timeout\r\n        };\r\n    }\r\n    return function (pending) {\r\n        scheduleIdleCallback(function (deadline) {\r\n            syncItemProcessor(pending);\r\n        }, options);\r\n    };\r\n}\r\n//# sourceMappingURL=itemProcessor.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { timeoutItemProcessor } from \"./itemProcessor\";\r\nvar _allAsyncSettledCreator;\r\nvar _raceAsyncCreator;\r\nvar _anyAsyncCreator;\r\n/**\r\n * Creates an asynchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the optional provided timeout value to schedule when the chained items will be ececuted.\r\n * @group Async\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createAsyncPromise(executor, timeout) {\r\n    return _createPromise(createAsyncPromise, timeoutItemProcessor(timeout), executor, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedul when the chained item will be executed (eg. `then()`; `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createAsyncAllPromise = /*#__PURE__*/ _createAllPromise(createAsyncPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createAsyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createAsyncPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Async\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createAsyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createAsyncPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createAsyncPromise Aasynchronous} promise implementation. Any chained operations will execute\r\n * __asynchronously__  when the final operation pending promises have resolved, or if the input contains\r\n * no promises. It will resolve only after all of the input promises have either resolved or rejected,\r\n * and will resolve with an array of {@link IPromiseResult } objects that each describe the outcome of\r\n * each promise.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAsyncAllSettledPromise(input, timeout) {\r\n    !_allAsyncSettledCreator && (_allAsyncSettledCreator = _createAllSettledPromise(createAsyncPromise));\r\n    return _allAsyncSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createAsyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createAsyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise is still\r\n * asynchronously settled.\r\n */\r\nexport function createAsyncRacePromise(values, timeout) {\r\n    !_raceAsyncCreator && (_raceAsyncCreator = _createRacePromise(createAsyncPromise));\r\n    return _raceAsyncCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createAsyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Async\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAsyncAnyPromise(values, timeout) {\r\n    !_anyAsyncCreator && (_anyAsyncCreator = _createAnyPromise(createAsyncPromise));\r\n    return _anyAsyncCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=asyncPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createAsyncPromise } from \"./asyncPromise\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { STRING_STATES } from \"../internal/state\";\r\nimport { dumpObj, isFunction, objDefineProp, throwTypeError, getInst, createCachedValue, safe } from \"@nevware21/ts-utils\";\r\nimport { STR_PROMISE } from \"../internal/constants\";\r\n/**\r\n * @internal\r\n * @ignore\r\n * Flag to determine if the native Promise class should be used if available, used for testing purposes.\r\n */\r\nvar _useNative = true;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the native Promise class\r\n */\r\nvar _promiseCls;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.all` method\r\n */\r\nvar _allCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.allSettled` method\r\n */\r\nvar _allNativeSettledCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.race` method\r\n */\r\nvar _raceNativeCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Cached value for the `Promise.any` method\r\n */\r\nvar _anyNativeCreator;\r\n/**\r\n * @internal\r\n * @ignore\r\n * Test Hook function to clear the cached values and set whether to use the native Promise class\r\n * @param useNative\r\n */\r\nexport function _clearPromiseCache(useNative) {\r\n    //#ifdef _DEBUG\r\n    //#:(!_DEBUG)     _useNative = !!useNative;\r\n    //#:(!_DEBUG)     _promiseCls = null as any;\r\n    //#:(!_DEBUG)     _allCreator = null as any;\r\n    //#:(!_DEBUG)     _allNativeSettledCreator = null as any;\r\n    //#:(!_DEBUG)     _raceNativeCreator = null as any;\r\n    //#:(!_DEBUG)     _anyNativeCreator = null as any;\r\n    //#endif\r\n}\r\n/*#__NO_SIDE_EFFECTS__*/\r\nexport function _createNativePromiseHelper(name, func) {\r\n    !_promiseCls && (_promiseCls = createCachedValue((_useNative && safe(getInst, [STR_PROMISE]).v) || null));\r\n    if (_promiseCls.v && _promiseCls.v[name]) {\r\n        return createCachedValue(function (input, timeout) {\r\n            return createNativePromise(function (resolve, reject) {\r\n                _promiseCls.v[name](input).then(resolve, reject);\r\n            });\r\n        });\r\n    }\r\n    return func();\r\n}\r\n/**\r\n * Creates a Promise instance that when resolved or rejected will execute it's pending chained operations using the\r\n * available native Promise implementation.\r\n * If runtime does not support native `Promise` class (or no polyfill is available) this function will fallback to using\r\n * `createAsyncPromise` which will resolve them __asynchronously__ using the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * @group Alias\r\n * @group Promise\r\n * @group Native\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createNativePromise(executor, timeout) {\r\n    !_promiseCls && (_promiseCls = createCachedValue((_useNative && safe(getInst, [STR_PROMISE]).v) || null));\r\n    var PrmCls = _promiseCls.v;\r\n    if (!PrmCls) {\r\n        return createAsyncPromise(executor);\r\n    }\r\n    if (!isFunction(executor)) {\r\n        throwTypeError(STR_PROMISE + \": executor is not a function - \" + dumpObj(executor));\r\n    }\r\n    var _state = 0 /* ePromiseState.Pending */;\r\n    function _strState() {\r\n        return STRING_STATES[_state];\r\n    }\r\n    var thePromise = new PrmCls(function (resolve, reject) {\r\n        function _resolve(value) {\r\n            _state = 2 /* ePromiseState.Resolved */;\r\n            resolve(value);\r\n        }\r\n        function _reject(reason) {\r\n            _state = 3 /* ePromiseState.Rejected */;\r\n            reject(reason);\r\n        }\r\n        executor(_resolve, _reject);\r\n    });\r\n    objDefineProp(thePromise, \"state\", {\r\n        get: _strState\r\n    });\r\n    return thePromise;\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @group Native\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport function createNativeAllPromise(input, timeout) {\r\n    !_allCreator && (_allCreator = _createNativePromiseHelper(\"all\", function () { return createCachedValue(_createAllPromise(createNativePromise)); }));\r\n    return _allCreator.v(input, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @group Native\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createNativeResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createNativePromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @group Native\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createNativeRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createNativePromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations using {@link createNativePromise native}\r\n * environment promise implementation, if the runtime does not provide any native then the optional provided\r\n * timeout value will be used to schedule when the chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @group Native\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createNativeResolvedPromise(1),\r\n *   createNativeResolvedPromise(2),\r\n *   createNativeResolvedPromise(3),\r\n *   createNativeRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createNativeAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createNativeAllSettledPromise(input, timeout) {\r\n    !_allNativeSettledCreator && (_allNativeSettledCreator = _createNativePromiseHelper(\"allSettled\", function () { return _createAllSettledPromise(createNativePromise); }));\r\n    return _allNativeSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createNativeRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createNativeRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @group Native\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously.\r\n */\r\nexport function createNativeRacePromise(values, timeout) {\r\n    !_raceNativeCreator && (_raceNativeCreator = _createNativePromiseHelper(\"race\", function () { return _createRacePromise(createNativePromise); }));\r\n    return _raceNativeCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createNativeAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @group Native\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createNativeAnyPromise(values, timeout) {\r\n    !_anyNativeCreator && (_anyNativeCreator = _createNativePromiseHelper(\"any\", function () { return _createAnyPromise(createNativePromise); }));\r\n    return _anyNativeCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=nativePromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { syncItemProcessor } from \"./itemProcessor\";\r\nvar _allSyncSettledCreator;\r\nvar _raceSyncCreator;\r\nvar _anySyncCreator;\r\n/**\r\n * Creates a synchronous Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __synchronously__ in the same execution cycle as the operation that calls the `executors`, `resolve` or `reject` functions.\r\n *\r\n * @group Synchronous\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n */\r\nexport function createSyncPromise(executor) {\r\n    return _createPromise(createSyncPromise, syncItemProcessor, executor);\r\n}\r\n/**\r\n * Returns a single synchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __synchronously__ in the same\r\n * execution cycle as the final operation pending promises have resolved, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __synchronously__ at the point of\r\n * being added (eg. `then()`; `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createSyncAllPromise = /*#__PURE__*/ _createAllPromise(createSyncPromise);\r\n/**\r\n * Returns a single synchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new synchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __synchronously__ at the point of being\r\n * added (calling `then()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n */\r\nexport var createSyncResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createSyncPromise);\r\n/**\r\n * Returns a single synchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __synchronously__ at the point of being added (eg. `catch()`; `finally()`).\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n */\r\nexport var createSyncRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createSyncPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createSyncPromise synchronous} promise implementation. Any chained operations will execute\r\n * __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createSyncAllSettledPromise(input, timeout) {\r\n    !_allSyncSettledCreator && (_allSyncSettledCreator = _createAllSettledPromise(createSyncPromise));\r\n    return _allSyncSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createSyncRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createSyncRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * synchronously.\r\n */\r\nexport function createSyncRacePromise(values, timeout) {\r\n    !_raceSyncCreator && (_raceSyncCreator = _createRacePromise(createSyncPromise));\r\n    return _raceSyncCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createSyncAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Synchronous\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createSyncAnyPromise(values, timeout) {\r\n    !_anySyncCreator && (_anySyncCreator = _createAnyPromise(createSyncPromise));\r\n    return _anySyncCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=syncPromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isUndefined } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { idleItemProcessor } from \"./itemProcessor\";\r\nvar _defaultIdleTimeout;\r\nvar _allIdleSettledCreator;\r\nvar _raceIdleCreator;\r\nvar _anyIdleCreator;\r\n/**\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport function setDefaultIdlePromiseTimeout(idleDeadline) {\r\n    _defaultIdleTimeout = idleDeadline;\r\n}\r\n/**\r\n * @deprecated Use `setDefaultIdlePromiseTimeout` instead\r\n * Sets the global default idle timeout / deadline to use when no timeout is passed during promise creation.\r\n * @param idleDeadline - Specifies the time in milliseconds to use as the idle timeout / deadline by when any\r\n * outstanding chained items should be executed.\r\n * @group Idle\r\n */\r\nexport var setDefaultIdleTimeout = ( /*#__PURE__*/setDefaultIdlePromiseTimeout);\r\n/**\r\n * Creates an idle Promise instance that when resolved or rejected will execute it's pending chained operations\r\n * __asynchronously__ using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed. When `requestIdleCallback` is not available this becomes the same as\r\n * `createAsyncPromise` which uses `setTimeout` to schedule executions.\r\n * @group Idle\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - Optional deadline timeout to wait before processing the items, defaults to undefined. If the number of\r\n * milliseconds represented by this parameter has elapsed and the callback has not already been called, then a task to execute\r\n * the callback is queued in the event loop (even if doing so risks causing a negative performance impact). timeout must be a\r\n * positive value or it is ignored.\r\n */\r\nexport function createIdlePromise(executor, timeout) {\r\n    var theTimeout = isUndefined(timeout) ? _defaultIdleTimeout : timeout;\r\n    return _createPromise(createIdlePromise, idleItemProcessor(theTimeout), executor, theTimeout);\r\n}\r\n/**\r\n * Returns an idle Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__\r\n * using the `requestIdleCallback` API (if available) with the optional provided timeout value to\r\n * schedule when the chained items will be executed.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * When resolved or rejected any additional chained operations will execute __asynchronously__ using\r\n * the `requestIdleCallback` API (if available) with the optional provided timeout value to schedule\r\n * when the chained items will be executed. (eg. `then()`; `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createIdleAllPromise = /*#__PURE__*/ _createAllPromise(createIdlePromise);\r\n/**\r\n * Returns an idle Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the\r\n * `requestIdleCallback` API (if available) with the optional provided timeout value to schedule when\r\n * the chained items will be executed. (eg. `then()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createIdleResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createIdlePromise);\r\n/**\r\n * Returns an idle Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the o`requestIdleCallback` API\r\n * (if available) with the optional provided timeout value to schedule when the chained items will\r\n * be executed. (eg. `catch()`; `finally()`).\r\n * @group Idle\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createIdleRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createIdlePromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the\r\n * {@link createIdlePromise idle} promise implementation. Any chained operations will execute\r\n * __asynchronously__ when the environment is idle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. It will resolve only after all of the input promises have either\r\n * resolved or rejected, and will resolve with an array of {@link IPromiseResult } objects that each describe\r\n * the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createIdleAllSettledPromise(input, timeout) {\r\n    !_allIdleSettledCreator && (_allIdleSettledCreator = _createAllSettledPromise(createIdlePromise));\r\n    return _allIdleSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createIdleRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createIdleRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * asynchronously when the system detects that the runtime is idle.\r\n */\r\nexport function createIdleRacePromise(values, timeout) {\r\n    !_raceIdleCreator && (_raceIdleCreator = _createRacePromise(createIdlePromise));\r\n    return _raceIdleCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createIdleAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Idle\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createIdleAnyPromise(values, timeout) {\r\n    !_anyIdleCreator && (_anyIdleCreator = _createAnyPromise(createIdlePromise));\r\n    return _anyIdleCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=idlePromise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createCachedValue } from \"@nevware21/ts-utils\";\r\nimport { _createAllPromise, _createAllSettledPromise, _createAnyPromise, _createRacePromise, _createRejectedPromise, _createResolvedPromise } from \"./base\";\r\nimport { createNativePromise } from \"./nativePromise\";\r\nvar _promiseCreator;\r\nvar _allSettledCreator;\r\nvar _raceCreator;\r\nvar _anyCreator;\r\n/**\r\n * Set the default promise implementation to use when calling `createPromise`; `createAllPromise`; `createResolvedPromise`\r\n * and `createRejectedPromise`. This is effective a global value and changing this will affect ALL callers of these\r\n * functions, as such these functions should only be used when switching implementations would have not unexpected\r\n * consequences like switching from a `createSyncPromise` to `createIdlePromise` where idle promises have a possibility\r\n * of never getting called during application shutdown or during an expected timeframe.\r\n * @group Alias\r\n * @group Promise\r\n * @param creator - The creator function to call when a new promise is required.\r\n */\r\nexport function setCreatePromiseImpl(creator) {\r\n    _promiseCreator = creator ? createCachedValue(creator) : null;\r\n}\r\n/**\r\n * Creates a Promise instance using the current default promise creator that when resolved or rejected will execute\r\n * it's pending chained operations.\r\n * @group Alias\r\n * @group Promise\r\n * @param executor - The function to be executed during the creation of the promise. Any errors thrown in the executor will\r\n * cause the promise to be rejected. The return value of the executor is always ignored\r\n * @param timeout - [Optional] timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport function createPromise(executor, timeout) {\r\n    !_promiseCreator && (_promiseCreator = createCachedValue(createNativePromise));\r\n    return _promiseCreator.v.call(this, executor, timeout);\r\n}\r\n/**\r\n * Returns a single asynchronous Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations __asynchronously__ using the optional\r\n * provided timeout value to schedule when the chained items will be executed, or if the input contains no promises.\r\n * It rejects immediately upon any of the input promises rejected or non-promises throwing an error,\r\n * and will reject with this first rejection message / error.\r\n * If the runtime doesn't support the Promise.all it will fallback back to an asynchronous Promise implementation.\r\n * @group Alias\r\n * @group Promise\r\n * @group All\r\n * @param input - The array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout\r\n * @returns\r\n * <ul>\r\n * <li> An already resolved `Promise`, if the input passed is empty.\r\n * <li> A pending `Promise` in all other cases. This returned promise is then resolved/rejected __synchronously__\r\n * (as soon as the pending items is empty) when all the promises in the given input have resolved, or if any of the\r\n * promises reject.\r\n * </ul>\r\n */\r\nexport var createAllPromise = /*#__PURE__*/ _createAllPromise(createPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already resolved with the given value. If the value passed is\r\n * a promise then that promise is returned instead of creating a new asynchronous promise instance.\r\n * If a new instance is returned then any chained operations will execute __asynchronously__ using the optional\r\n * timeout value to schedule when the chained items will be executed.(eg. `then()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Resolved\r\n * @param value - The value to be used by this `Promise`. Can also be a `Promise` or a thenable to resolve.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createResolvedPromise = /*#__PURE__*/ _createResolvedPromise(createPromise);\r\n/**\r\n * Returns a single asynchronous Promise instance that is already rejected with the given reason.\r\n * Any chained operations will execute __asynchronously__ using the optional timeout value to schedule\r\n * when then chained items will be executed. (eg. `catch()`; `finally()`).\r\n * @group Alias\r\n * @group Promise\r\n * @group Rejected\r\n * @param reason - The rejection reason\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero.\r\n */\r\nexport var createRejectedPromise = /*#__PURE__*/ _createRejectedPromise(createPromise);\r\n/**\r\n * Returns a single Promise instance that resolves to an array of the results from the input promises.\r\n * This returned promise will resolve and execute it's pending chained operations based on the current\r\n * promise implementation. If the current implementation is synchronous then the chained operations will\r\n * execute __synchronously__ in the same execution cycle as the final operation pending promises have resolved,\r\n * or if the input contains no promises. If the current implementation is asynchronous then the chained\r\n * operations will execute __asynchronously__ using the optional provided timeout value to schedule when the\r\n * chained items will be executed or if the input contains no promises.\r\n * It will resolve only after all of the input promises have either resolved or rejected, and will resolve with an array\r\n * of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group AllSettled\r\n * @param input - An array of promises to wait to be resolved / rejected before resolving or rejecting the new promise\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A pending `Promise` that will resolve to an array of {@link IPromiseResult } objects that each describe the outcome of each promise.\r\n *\r\n * @example\r\n * ```ts\r\n * const promises = [\r\n *   createResolvedPromise(1),\r\n *   createResolvedPromise(2),\r\n *   createResolvedPromise(3),\r\n *   createRejectedPromise(\"error\"),\r\n * ];\r\n *\r\n * const results = await createAllSettledPromise(promises);\r\n *\r\n * // results is:\r\n * // [\r\n * //   { status: \"fulfilled\", value: 1 },\r\n * //   { status: \"fulfilled\", value: 2 },\r\n * //   { status: \"fulfilled\", value: 3 },\r\n * //   { status: \"rejected\", reason: \"error\" }\r\n * // ]\r\n * ```\r\n */\r\nexport function createAllSettledPromise(input, timeout) {\r\n    !_allSettledCreator && (_allSettledCreator = _createAllSettledPromise(createPromise));\r\n    return _allSettledCreator.v(input, timeout);\r\n}\r\n/**\r\n * The `createRacePromise` method takes an array of promises as input and returns a single Promise. This returned promise\r\n * settles with the eventual state of the first promise that settles.\r\n * @description The `createRacePromise` method is one of the promise concurrency methods. It's useful when you want the first\r\n * async task to complete, but do not care about its eventual state (i.e. it can either succeed or fail).\r\n * If the iterable contains one or more non-promise values and/or an already settled promise, then Promise.race() will settle to\r\n * the first of these values found in the iterable.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Race\r\n * @param values - An the array of promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A Promise that settles with the eventual state of the first promise in the iterable to settle. In other words, it fulfills if the\r\n * first promise to settle is fulfilled, and rejects if the first promise to settle is rejected. The returned promise remains pending forever\r\n * if the iterable passed is empty. If the iterable passed is non-empty but contains no pending promises, the returned promise will settle\r\n * based on the current promise implementation.\r\n */\r\nexport function createRacePromise(values, timeout) {\r\n    !_raceCreator && (_raceCreator = _createRacePromise(createPromise));\r\n    return _raceCreator.v(values, timeout);\r\n}\r\n/**\r\n * The `createAnyPromise` method takes an array of promises as input and returns a single Promise.\r\n * This returned promise fulfills when any of the input's promises fulfills, with this first fulfillment value.\r\n * It rejects when all of the input's promises reject (including when an empty iterable is passed), with an\r\n * AggregateError containing an array of rejection reasons.\r\n * @since 0.5.0\r\n * @group Alias\r\n * @group Promise\r\n * @group Any\r\n * @param values - An Array promises.\r\n * @param timeout - Optional timeout to wait before processing the items, defaults to zero, only used when Native promises are not available.\r\n * @returns A new Promise that is:\r\n * - Already rejected, if the iterable passed is empty.\r\n * - Asynchronously fulfilled, when any of the promises in the given iterable fulfills. The fulfillment value\r\n * is the fulfillment value of the first promise that was fulfilled.\r\n * - Asynchronously rejected, when all of the promises in the given iterable reject. The rejection reason is\r\n * an AggregateError containing an array of rejection reasons in its errors property. The errors are in the\r\n * order of the promises passed, regardless of completion order. If the iterable passed is non-empty but\r\n * contains no pending promises, the returned promise is still asynchronously (instead of synchronously)\r\n * rejected.\r\n */\r\nexport function createAnyPromise(values, timeout) {\r\n    !_anyCreator && (_anyCreator = _createAnyPromise(createPromise));\r\n    return _anyCreator.v(values, timeout);\r\n}\r\n//# sourceMappingURL=promise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isFunction, isPromiseLike, utcNow } from \"@nevware21/ts-utils\";\r\nimport { createPromise } from \"../promise/promise\";\r\nimport { doAwait } from \"../promise/await\";\r\nfunction _doneChk(isDone, state, value, thisArg) {\r\n    var result = isDone;\r\n    state.res = value;\r\n    if (!result) {\r\n        if (state.isDone && isFunction(state.isDone)) {\r\n            // Handle synchronous or asynchronous isDone function\r\n            return doAwait(state.isDone.call(thisArg, state), function (done) {\r\n                state.iter++;\r\n                return !!done;\r\n            });\r\n        }\r\n        else {\r\n            result = !!state.isDone;\r\n        }\r\n    }\r\n    state.iter++;\r\n    return result;\r\n}\r\n/**\r\n * Performs a while loop, calling the provided `callbackFn` function until the `state.isDone`\r\n * property is set to `true` or the optional `isDOneFn` returns `true`. The callback function will\r\n * receive a single {@link IWhileState state} argument and may return either a value or a promise,\r\n * if a promise is returned the while loop will wait until the promise is resolved before calling\r\n * the callback function again. If the callback function never returns a promise the while loop\r\n * will be executed synchronous and last value returned by the callback will be returned, if the\r\n * callback function returns a promise the while loop will be asynchronous and an {@link IPromise}\r\n * will be returned and resolved with the last value returned by the callback or rejected if the\r\n * callback promise rejects or throws an error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @typeParam T - Identifies the element type returned by the callback function.\r\n * @param callbackFn A function that will be called until the `state.isDone` flag is set to `true`\r\n * the function will receive a single {@link IWhileState state} argument. The callback function\r\n * may return either a value or a promise, if a promise is returned the while loop will wait\r\n * until the promise is resolved before calling the callback function again.\r\n * @param isDoneFn An optional function that will be called after the callback function is called,\r\n * that can be used to stop the while loop. The function will receive a single {@link IWhileState state}\r\n * argument. If the function returns `true` the while loop will stop, otherwise the while loop will continue.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function.\r\n * If thisArg is omitted, null or undefined the array will be used as the this value.\r\n * @remarks\r\n * - If an `isDoneFn` is provided the `state.isDone` property will be set to the provided value and\r\n * is accessible withing the callback function. The callbackFn may overwrite the value of the\r\n * `state.isDone` property within the callback function with a boolean value or another function that\r\n * returns a boolean value.\r\n * - The callback function is called until until the `state.isDone` property is set to `true` or if\r\n * `state.isDone` is a function until the function returns `true.\r\n * - The callback function will receive a single {@link IWhileState state} argument that contains\r\n * the following properties:\r\n *  - `iter` - The zero-based iteration count, which is incremented after each call to the `callbackFn`\r\n * and any `isDone` function (if provided), the `iter` property is accessible withing the callback\r\n * function and may be overwritten within the callback function.\r\n * - `res` - The last resolved result value returned by the `callbackFn` function.\r\n * - `isDone` - A boolean value or a callback function that will be called to check if the while loop\r\n * should stop, the `isDone` property is accessible withing the callback function and may be\r\n * overwritten within the callback function.\r\n * - The callback function may return either a value or a promise, if a promise is returned the while\r\n * loop will wait until the promise is resolved before calling the callback function again.\r\n * - If the callback function throws an error when executing `synchronously` the exception will\r\n * also be thrown `synchronously` otherwise the returned promise will be rejected with the error.\r\n * @example\r\n * ```ts\r\n * // Synchronous example\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     return \"Hello\";\r\n *  }\r\n * });\r\n *\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Synchronous example with isDoneFn\r\n * const result = doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *    if (state.idx < 10) {\r\n *      // Logs each iteration index (will be called synchronously)\r\n *      // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *      console.log(state.idx);\r\n *   } else {\r\n *     return \"Hello\";\r\n *  }\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Hello after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Asynchronous examples\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   state.isDone = true;\r\n *   return createResolvedPromise(\"Darkness\");\r\n * });\r\n * console.log(result); // Darkness\r\n *\r\n * // Asynchronous example with isDoneFn\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs each iteration index\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 calling the callback function synchronously\r\n *     console.log(state.idx);\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true, state.idx);\r\n *   }\r\n *\r\n *   return createResolvedPromise(\"Darkness\");\r\n * }, (state) => state.idx > 10);\r\n * console.log(result); // returns Darkness after logging 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *\r\n * // Combination Synchronous and Asynchronous example\r\n * const result = await doWhileAsync((state) => { // Note: DO NOT use async here unless you use await withing the function\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     console.log(state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await\r\n * const result = await doWhileAsync(async (state) => {\r\n *   if (state.idx < 10) {\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n *\r\n * // Asynchronous example using await and dynamically setting the isDone function\r\n * const result = await doWhileAsync(async (state) => {\r\n *   // dynamically set the isDone function\r\n *   if (state.idx < 10) {\r\n *     state.isDone = () => return false;\r\n *     // Logs 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\r\n *     // Logs each iteration index (will be called synchronously)\r\n *     await createTimeoutPromise(10, true, state.idx);\r\n *   } else {\r\n *     state.isDone = () => return true;\r\n *     // Returning a promise will cause `doWhileAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before resolving the returned promise.\r\n *     return await createResolvedPromise(\"my old friend\");\r\n *   }\r\n * });\r\n *\r\n * console.log(result); // my old friend\r\n * ```\r\n */\r\nexport function doWhileAsync(callbackFn, isDoneFn, thisArg) {\r\n    var promise;\r\n    var resolve;\r\n    var reject = function (reason) {\r\n        isDone = true;\r\n        throw reason;\r\n    };\r\n    var isDone = false;\r\n    var state = {\r\n        st: utcNow(),\r\n        iter: 0,\r\n        isDone: isDoneFn || false\r\n    };\r\n    if (callbackFn) {\r\n        var _createPromise_1 = function () {\r\n            return createPromise(function (res, rej) {\r\n                resolve = res;\r\n                reject = rej;\r\n            });\r\n        };\r\n        var _handleAsyncDone_1 = function (done) {\r\n            isDone = !!done;\r\n            if (!isDone) {\r\n                _processNext_1();\r\n            }\r\n            else {\r\n                resolve(state.res);\r\n            }\r\n        };\r\n        var _processNext_1 = function () {\r\n            // Attempt to process the next item synchronously if possible (for performance -- to reduce the number of promises created)\r\n            while (!isDone) {\r\n                try {\r\n                    var cbResult = callbackFn.call(thisArg, state);\r\n                    if (isPromiseLike(cbResult)) {\r\n                        promise = promise || _createPromise_1();\r\n                        doAwait(cbResult, function (res) {\r\n                            try {\r\n                                doAwait(_doneChk(isDone, state, res, thisArg), _handleAsyncDone_1, reject);\r\n                            }\r\n                            catch (e) {\r\n                                reject(e);\r\n                            }\r\n                        }, reject);\r\n                        // Break out of synchronous loop and wait for promise to resolve\r\n                        return promise;\r\n                    }\r\n                    else {\r\n                        var dnRes = _doneChk(isDone, state, cbResult, thisArg);\r\n                        if (isPromiseLike(dnRes)) {\r\n                            promise = promise || _createPromise_1();\r\n                            doAwait(dnRes, _handleAsyncDone_1, reject);\r\n                            // Break out of synchronous loop and wait for promise to resolve\r\n                            return promise;\r\n                        }\r\n                        else {\r\n                            isDone = !!dnRes;\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    reject(e);\r\n                    return promise;\r\n                }\r\n            }\r\n            if (isDone && resolve) {\r\n                resolve(state.res);\r\n            }\r\n            return promise || state.res;\r\n        };\r\n        return _processNext_1();\r\n    }\r\n}\r\n//# sourceMappingURL=doWhileAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { arrForEach, arrIndexOf, createCustomError, getLength, isPromiseLike, objDefine, objDefineProp, scheduleTimeout, utcNow } from \"@nevware21/ts-utils\";\r\nimport { doAwait, doAwaitResponse } from \"../promise/await\";\r\nimport { createPromise } from \"../promise/promise\";\r\n//#ifdef DEBUG\r\n//#:(!DEBUG) import { _debugLog } from \"../promise/debug\";\r\n//#endif\r\nvar REJECT = \"reject\";\r\nvar REJECTED_ERROR = \"Rejected\";\r\nvar _schedulerId = 0;\r\nvar _debugName;\r\nvar _debugIntState;\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nvar _customErrors = {};\r\n/**\r\n * @internal\r\n * @ignore\r\n * Empty reject function to avoid trying to re-reject\r\n */\r\nfunction _rejectDone() {\r\n    // A Do nothing function\r\n}\r\nfunction _createError(type, evt, message) {\r\n    // Lazily create the class\r\n    !_customErrors[type] && (_customErrors[type] = createCustomError(type));\r\n    var now = utcNow();\r\n    return new (_customErrors[type])(\"Task [\".concat(evt.id, \"] \").concat(message || \"\", \"- \").concat((evt.st ? \"Running\" : \"Waiting\"), \": \").concat(_calcTime(now, evt.st || evt.cr)));\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Internal function used for displaying the time in milliseconds (during debugging)\r\n * @param now - The current time\r\n * @param start - The start time to subtract\r\n * @returns A string representation of the time difference\r\n */\r\nfunction _calcTime(now, start) {\r\n    return ((now - start) || \"0\") + \" ms\";\r\n}\r\n/**\r\n * Abort any stale tasks in the provided task Queue\r\n * @param taskQueue - The Task Queue to search\r\n * @param staleTimeoutPeriod - The maxumum stale timeout period\r\n */\r\nfunction _abortStaleTasks(taskQueue, staleTimeoutPeriod) {\r\n    var now = utcNow();\r\n    var expired = now - staleTimeoutPeriod;\r\n    arrForEach(taskQueue, function (evt) {\r\n        if (evt && !evt.rj && (evt.st && evt.st < expired) || (!evt.st && evt.cr && evt.cr < expired)) {\r\n            evt && evt[REJECT](evt.rj || _createError(\"Aborted\", evt, \"Stale \"));\r\n        }\r\n    });\r\n}\r\n/**\r\n * @internal\r\n * @ignore\r\n * Remove the `taskDetail` from the `queue` if present\r\n * @param queue - The Task Queue\r\n * @param taskDetail - The Task detail to be removed\r\n */\r\nfunction _removeTask(queue, taskDetail) {\r\n    var idx = arrIndexOf(queue, taskDetail);\r\n    if (idx !== -1) {\r\n        queue.splice(idx, 1);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n * @ignore Internal function to add the debug state to the promise, this code is removed from the production artifacts\r\n * @param theScheduler - The scheduler instance to add the debug accessors to.\r\n * @param nameFn - The function to return then name of this scheduler\r\n * @param stateFn - The function to return the internal state of the scheduler\r\n */\r\nfunction _addDebugState(theScheduler, nameFn, stateFn) {\r\n    _debugName = _debugName || { toString: function () { return \"[[SchedulerName]]\"; } };\r\n    _debugIntState = _debugIntState || { toString: function () { return \"[[SchedulerState]]\"; } };\r\n    objDefineProp(theScheduler, _debugName, { get: nameFn });\r\n    objDefineProp(theScheduler, _debugIntState, { get: stateFn });\r\n}\r\n/**\r\n * Create a Task Scheduler using the optional promise implementation and scheduler name.\r\n * The newPromise can be any value promise creation function, where the execution of the\r\n * queued tasks will be processed based on how the promise implementation processes it's\r\n * chained promises (asynchrounsly; synchronously; idle processing, etc)\r\n *\r\n * The functions used to start each task my return a result (synchronous execution) or an\r\n * {@link IPromise}, `PromiseLike` or `Promise` result (asynchronous execution).\r\n *\r\n * Each task is executed in the order that it was queued and the provided `startTask` function\r\n * will not be called until all previous tasks have completed (whther they resolve or reject).\r\n * The result from any previous task does not affect and is not passed to any later scheduled\r\n * task, if you need this capability then your `startTask` functions will need to co-operate to\r\n * share any common context.\r\n *\r\n * By default, queued tasks which have either been \"waiting\" to run or have been running longer\r\n * then 10 minutes will be Auto-Rejected to try and free up resources. If a task is running when\r\n * it rejected then it will continue to \"run\" based on whatever operation it's `startTask` is\r\n * performing. If a task has not yet had it's `startTask` function called it will never get called.\r\n * In both cases the `IPromise` returned by the call to {@link ITaskScheduler.queue | queue} the\r\n * task will be `rejected`. You can change this default time, including disabling completly via\r\n * the {@link ITaskScheduler.setStaleTimeout | setStaleTimeout}\r\n * function.\r\n * @since 0.2.0\r\n * @group Scheduler\r\n * @param newPromise - The function to use for creating a new promise when required, if not\r\n * provided this will default to {@link createPromise} which will use the default registered\r\n * promise creation function which defaults to runtime native promises or async Promise if not\r\n * supported by the runtime.\r\n * @param name - The name you want to associated with this scheduler, mostly useful for debugging\r\n * @returns A new ITaskScheduler instance\r\n * @example\r\n * ```ts\r\n * let scheduler = createTaskScheduler();\r\n *\r\n * // Schedule a task using the ts-async helper promise functions\r\n * scheduler.queue(() => {\r\n *     return createPromise((resolve, reject) => {\r\n *         scheduleTimeout(() => {\r\n *             // Do something after a delay\r\n *         }, 100);\r\n *     });\r\n * });\r\n *\r\n * // Schedule an asynchronous task which uses async/await\r\n * scheduler.queue(async () => {\r\n *     // This task will only execute after the previous task has completed\r\n *     await performAnotherAsyncTask();\r\n * });\r\n *\r\n * // Schedule a synchronous task that executes and completes immediately\r\n * scheduled.queue(() => {\r\n *     // Do some synchronous task\r\n *     return 42;\r\n * });\r\n *\r\n * // Schedule an asynchronous task which returns a promise\r\n * scheduled.queue(() => {\r\n *     return doAwait(fetch(\"https://github.com/nevware21/ts-async/blob/main/README.md\"), (response) => {\r\n *         let theReadMe = response.text();\r\n *         // Do something with the readme\r\n *     });\r\n * });\r\n * ```\r\n */\r\nexport function createTaskScheduler(newPromise, name) {\r\n    var _theTask;\r\n    var _running = [];\r\n    var _waiting = [];\r\n    var _staleTimeoutPeriod = 600000; // 10 Minutes\r\n    var _staleTimeoutCheckPeriod = _staleTimeoutPeriod / 10; // 1 Minute\r\n    var _taskCount = 0;\r\n    var _schedulerName = (name ? (name + \".\") : \"\") + _schedulerId++;\r\n    var _blockedTimer;\r\n    // Make sure that a promise creator has been assigned\r\n    newPromise = newPromise || createPromise;\r\n    var _startBlockedTimer = function () {\r\n        var hasTasks = (getLength(_running) + getLength(_waiting)) > 0;\r\n        if (_staleTimeoutPeriod > 0) {\r\n            if (!_blockedTimer) {\r\n                // Only attempt to drop stale / blocked tasks if the timeout period is defined\r\n                _blockedTimer = scheduleTimeout(function () {\r\n                    _abortStaleTasks(_running, _staleTimeoutPeriod);\r\n                    _abortStaleTasks(_waiting, _staleTimeoutPeriod);\r\n                    _blockedTimer && (_blockedTimer.enabled = ((getLength(_running) + getLength(_waiting)) > 0));\r\n                }, _staleTimeoutCheckPeriod);\r\n                _blockedTimer.unref();\r\n            }\r\n            _blockedTimer && (_blockedTimer.enabled = hasTasks);\r\n        }\r\n        else {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"Stale Timer disabled\");\r\n            //#endif\r\n        }\r\n    };\r\n    var _queueTask = function (startAction, taskName, timeout) {\r\n        var _a;\r\n        var taskId = _schedulerName + \".\" + _taskCount++;\r\n        if (taskName) {\r\n            taskId += \"-(\" + taskName + \")\";\r\n        }\r\n        var newTask = (_a = {\r\n                id: taskId,\r\n                cr: utcNow(),\r\n                to: timeout\r\n            },\r\n            _a[REJECT] = function (reason) {\r\n                newTask.rj = reason || _createError(REJECTED_ERROR, newTask);\r\n                newTask[REJECT] = _rejectDone;\r\n            },\r\n            _a);\r\n        if (!_theTask) {\r\n            // We don't have any currently running task, so just start the next task\r\n            newTask.p = newPromise(_runTask(newTask, startAction));\r\n        }\r\n        else {\r\n            // Start a new promise which will wait until all current active tasks are completed before starting\r\n            // the new task, it does not resolve this scheduled task until after the new task is resolve to\r\n            // ensure that all scheduled tasks are completed in the correct order\r\n            newTask.p = _waitForPreviousTask(newTask, _theTask, startAction);\r\n        }\r\n        // Set this new task as the last one, so that any future tasks will wait for this one\r\n        _theTask = newTask;\r\n        return newTask.p;\r\n    };\r\n    var _runTask = function (taskDetail, startAction) {\r\n        taskDetail.st = utcNow();\r\n        // There should only ever be a single \"running\" task, but using an array\r\n        // for code reuse.\r\n        _running.push(taskDetail);\r\n        _startBlockedTimer();\r\n        // Create and return the promise executor for this action\r\n        return function (onTaskResolve, onTaskReject) {\r\n            var _promiseReject = function (reason) {\r\n                taskDetail.rj = taskDetail.rj || reason || _createError(REJECTED_ERROR, taskDetail);\r\n                taskDetail[REJECT] = _rejectDone;\r\n                _doCleanup(taskDetail);\r\n                onTaskResolve = null;\r\n                onTaskReject && onTaskReject(reason);\r\n                onTaskReject = null;\r\n            };\r\n            var taskId = taskDetail.id;\r\n            if (taskDetail.rj) {\r\n                // Already aborted / pre-rejected\r\n                _promiseReject(taskDetail.rj);\r\n            }\r\n            else {\r\n                //#ifdef DEBUG\r\n                //#:(!DEBUG) _debugLog(_schedulerName, \"Task [\" + taskId + \"] Started after \" + _calcTime(taskDetail.st, taskDetail.cr));\r\n                //#endif\r\n                taskDetail[REJECT] = _promiseReject;\r\n                try {\r\n                    var startResult = startAction(taskId);\r\n                    if (taskDetail.to && isPromiseLike(startResult)) {\r\n                        taskDetail.t = scheduleTimeout(function () {\r\n                            _promiseReject(_createError(\"Timeout\", taskDetail));\r\n                        }, taskDetail.to);\r\n                    }\r\n                    doAwait(startResult, function (theResult) {\r\n                        _doCleanup(taskDetail);\r\n                        try {\r\n                            onTaskResolve && onTaskResolve(theResult);\r\n                        }\r\n                        catch (e) {\r\n                            onTaskReject && onTaskReject(e);\r\n                        }\r\n                        onTaskReject = null;\r\n                        onTaskResolve = null;\r\n                    }, _promiseReject);\r\n                }\r\n                catch (e) {\r\n                    _promiseReject(e);\r\n                }\r\n            }\r\n        };\r\n    };\r\n    var _waitForPreviousTask = function (taskDetail, prevTask, startAction) {\r\n        _waiting.push(taskDetail);\r\n        _startBlockedTimer();\r\n        return newPromise(function (onWaitResolve, onWaitReject) {\r\n            //#ifdef DEBUG\r\n            //#:(!DEBUG) let taskId = taskDetail.id;\r\n            //#:(!DEBUG) let prevTaskId = prevTask.id;\r\n            //#:(!DEBUG) _debugLog(_schedulerName, \"[\" + taskId + \"] is waiting for [\" + prevTaskId + \"] to complete before starting -- [\" + _waiting.length + \"] waiting\");\r\n            //#endif\r\n            // Wait for the previous tasks to complete before starting this one.\r\n            // This ensures the queue execution order and avoids removing tasks that\r\n            // have not yet been started.\r\n            doAwaitResponse(prevTask.p, function () {\r\n                _removeTask(_waiting, taskDetail);\r\n                _runTask(taskDetail, startAction)(onWaitResolve, onWaitReject);\r\n            });\r\n        });\r\n    };\r\n    var _doCleanup = function (taskDetail) {\r\n        _removeTask(_running, taskDetail);\r\n        // If there was a timeout stop and clear\r\n        taskDetail.t && taskDetail.t.cancel();\r\n        taskDetail.t = null;\r\n        // Clear the matching current task now that it's complete\r\n        if (_theTask && _theTask === taskDetail) {\r\n            _theTask = null;\r\n            if (getLength(_running) + getLength(_waiting) === 0) {\r\n                _blockedTimer && _blockedTimer.cancel();\r\n                _blockedTimer = null;\r\n            }\r\n        }\r\n    };\r\n    var theScheduler = {\r\n        idle: true,\r\n        queue: _queueTask,\r\n        setStaleTimeout: function (staleTimeout, staleCheckPeriod) {\r\n            _blockedTimer && _blockedTimer.cancel();\r\n            _blockedTimer = null;\r\n            _staleTimeoutPeriod = staleTimeout;\r\n            _staleTimeoutCheckPeriod = staleCheckPeriod || staleTimeout / 10;\r\n            _startBlockedTimer();\r\n        }\r\n    };\r\n    // Change the idle property to dynamic\r\n    objDefine(theScheduler, \"idle\", {\r\n        g: function () {\r\n            return getLength(_running) + getLength(_waiting) === 0;\r\n        }\r\n    });\r\n    _addDebugState(theScheduler, function () { return _schedulerName; }, function () {\r\n        return {\r\n            l: _theTask,\r\n            r: _running,\r\n            w: _waiting\r\n        };\r\n    });\r\n    return theScheduler;\r\n}\r\n//# sourceMappingURL=taskScheduler.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nexport var STR_PROMISE = \"Promise\";\r\nexport var DONE = \"done\";\r\nexport var VALUE = \"value\";\r\nexport var ITERATOR = \"iterator\";\r\nexport var RETURN = \"return\";\r\nexport var REJECTED = \"rejected\";\r\n//# sourceMappingURL=constants.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { REJECTED } from \"./constants\";\r\n/**\r\n * @ignore -- Don't include in the generated documentation\r\n * @internal\r\n */\r\nexport var STRING_STATES = /*#__PURE__*/ [\r\n    \"pending\", \"resolving\", \"resolved\", REJECTED\r\n];\r\n//# sourceMappingURL=state.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { createCachedValue, fnCall, getKnownSymbol, isIterator, isPromiseLike } from \"@nevware21/ts-utils\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\nimport { DONE, RETURN, VALUE } from \"../internal/constants\";\r\nimport { doAwait, doFinally } from \"../promise/await\";\r\nvar _iterSymbol;\r\nvar _iterAsyncSymbol;\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in the iterator or iterator returned by\r\n * the iterable and processed in the same order as returned by the iterator. As with the {@link arrForEachAsync}\r\n * you CAN stop or break the iteration by returning -1 from the `callbackFn` function.\r\n *\r\n * The order of processing is not reset if you add or remove elemenets to the iterator, the actual behavior will\r\n * depend on the iterator implementation.\r\n *\r\n * if the passed `iter` is both an Iterable<T> and Iterator<T> the Iterator<T> interface takes precedence. And if\r\n * an iterable and does not have a `Symbol.iterator` property then the `iter` will be used as the iterator.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise`\r\n * then the next iteration will not be called until the promise is resolved. If the `callbackFn` returns a `Promise`\r\n * that is rejected then the iteration will stop and the promise returned by iterForEachAsync will be rejected with\r\n * the same error.\r\n * @remarks\r\n * If Symbols are NOT supported then the iterable MUST be using the same polyFill for the well know symbols, as used\r\n * by the library. If the iterable is using a different polyFill then the `iter` MUST be an Iterator<T> and not an\r\n * Iterable<T>.\r\n * If you are targetting a mixed environment you SHOULD either\r\n * - only use the polyfill Symbol's provided by this library\r\n * - ensure that you add any symbol polyfills BEFORE these utilities\r\n * iterForOfAsync\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Iterator\r\n * @typeParam T - Identifies the element type of the iterator\r\n * @param iter - The iterator or iterable of elements to be searched.\r\n * @param callbackFn - A `asynchronous` or `synchronous` function that accepts up to three arguments. iterForEach\r\n * calls the callbackfn function one time for each element in the iterator.\r\n * @param thisArg - An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted,\r\n * null or undefined the iterator will be used as the this value.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * // using async / await\r\n * let result = await iterForOfAsync(items, async (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   await createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  })\r\n *\r\n * console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *\r\n * // using doAwait\r\n * doAwait(iterForOfAsync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n *\r\n *   return createTimeoutPromise(100); // Wait 100ms before processing the next item, you could also just return the promise\r\n *  }), (result) => {\r\n *    console.log(result); // returns -1 if the loop was stopped, otherwise returns undefined\r\n *  });\r\n */\r\nexport function iterForOfAsync(iter, callbackFn, thisArg) {\r\n    var err;\r\n    var iterResult;\r\n    var theIter = iter;\r\n    function onFailed(failed) {\r\n        err = { e: failed };\r\n        if (theIter.throw) {\r\n            iterResult = null;\r\n            theIter.throw(err);\r\n        }\r\n        throw failed;\r\n    }\r\n    function onFinally() {\r\n        try {\r\n            if (iterResult && !iterResult[DONE]) {\r\n                theIter[RETURN] && theIter[RETURN](iterResult);\r\n            }\r\n        }\r\n        finally {\r\n            if (err) {\r\n                // eslint-disable-next-line no-unsafe-finally\r\n                throw err.e;\r\n            }\r\n        }\r\n    }\r\n    if (iter) {\r\n        if (!isIterator(iter)) {\r\n            // Get the asyncIterator from the iterable\r\n            !_iterAsyncSymbol && (_iterAsyncSymbol = createCachedValue(getKnownSymbol(0 /* WellKnownSymbols.asyncIterator */)));\r\n            theIter = iter[_iterAsyncSymbol.v] ? iter[_iterAsyncSymbol.v]() : null;\r\n            if (!theIter) {\r\n                // Get the iterator from the iterable\r\n                !_iterSymbol && (_iterSymbol = createCachedValue(getKnownSymbol(3 /* WellKnownSymbols.iterator */)));\r\n                theIter = iter[_iterSymbol.v] ? iter[_iterSymbol.v]() : null;\r\n            }\r\n        }\r\n        if (theIter && isIterator(theIter)) {\r\n            var result = void 0;\r\n            try {\r\n                result = doWhileAsync(function (state) {\r\n                    return doAwait(theIter.next(), function (res) {\r\n                        iterResult = res;\r\n                        if (!res[DONE]) {\r\n                            return fnCall(callbackFn, thisArg || theIter, iterResult[VALUE], state.iter, theIter);\r\n                        }\r\n                    }, function (reason) {\r\n                        state.isDone = true;\r\n                        onFailed(reason);\r\n                    });\r\n                }, function (state) {\r\n                    if (!iterResult || iterResult[DONE] || state.res === -1) {\r\n                        onFinally();\r\n                        return true;\r\n                    }\r\n                }, thisArg || theIter);\r\n                if (isPromiseLike(result)) {\r\n                    result = doFinally(result.catch(onFailed), onFinally);\r\n                }\r\n                return result;\r\n            }\r\n            catch (failed) {\r\n                onFailed(failed);\r\n            }\r\n            finally {\r\n                if (result && !isPromiseLike(result)) {\r\n                    onFinally();\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=iterForOfAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2022 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { getKnownSymbol, objDefineProp } from \"@nevware21/ts-utils\";\r\nimport { createAsyncAllPromise, createAsyncAllSettledPromise, createAsyncAnyPromise, createAsyncPromise, createAsyncRacePromise, createAsyncRejectedPromise, createAsyncResolvedPromise } from \"../promise/asyncPromise\";\r\nvar toStringTagSymbol = getKnownSymbol(11 /* WellKnownSymbols.toStringTag */);\r\n/**\r\n * A full polyfill for the Promise class.\r\n * Represents the completion of an asynchronous operation, and its resulting value.\r\n * @since 0.5.0\r\n * @class\r\n * @group Polyfill\r\n * @group Promise\r\n */\r\nexport var PolyPromise = /*#__PURE__*/ (function () {\r\n    /**\r\n     * Creates a new Promise.\r\n     * @constructor\r\n     * @param executor A callback used to initialize the promise. This callback is passed two arguments:\r\n     * a resolve callback used to resolve the promise with a value or the result of another promise,\r\n     * and a reject callback used to reject the promise with a provided reason or error.\r\n     */\r\n    function PolyPromiseImpl(executor) {\r\n        this._$ = createAsyncPromise(executor);\r\n        if (toStringTagSymbol) {\r\n            this[toStringTagSymbol] = \"Promise\";\r\n        }\r\n        // Re-Expose the state of the underlying promise\r\n        objDefineProp(this, \"state\", {\r\n            get: function () {\r\n                return this._$.state;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     */\r\n    PolyPromiseImpl.all = createAsyncAllPromise;\r\n    PolyPromiseImpl.race = createAsyncRacePromise;\r\n    PolyPromiseImpl.any = createAsyncAnyPromise;\r\n    PolyPromiseImpl.reject = createAsyncRejectedPromise;\r\n    PolyPromiseImpl.resolve = createAsyncResolvedPromise;\r\n    PolyPromiseImpl.allSettled = createAsyncAllSettledPromise;\r\n    var theProto = PolyPromiseImpl.prototype;\r\n    theProto.then = function (onResolved, onRejected) {\r\n        return this._$.then(onResolved, onRejected);\r\n    };\r\n    theProto.catch = function (onRejected) {\r\n        return this._$.catch(onRejected);\r\n    };\r\n    theProto.finally = function (onfinally) {\r\n        return this._$.finally(onfinally);\r\n    };\r\n    return PolyPromiseImpl;\r\n}());\r\n//# sourceMappingURL=promise.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2023 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { getLength } from \"@nevware21/ts-utils\";\r\nimport { doWhileAsync } from \"./doWhileAsync\";\r\n/**\r\n * Calls the provided `callbackFn` function once for each element in an array (or ArratLike) instance in ascending index order. It is not invoked\r\n * for index properties that have been deleted or are uninitialized. And unlike the ES6 forEach() this supports async functions and you CAN stop\r\n * or break the iteration  by returning -1 from the `callbackFn` function.\r\n *\r\n * The range (number of elements) processed by arrForEach() is set before the first call to the `callbackFn`. Any elements added beyond the range\r\n * or elements which as assigned to indexes already processed will not be visited by the `callbackFn`.\r\n *\r\n * The `callbackFn` may execute `synchronously` or `asynchronously` and if the `callbackFn` returns a `Promise` then the next iteration will not be\r\n * called until the promise is resolved. If the `callbackFn` returns a `Promise` that is rejected then the iteration will stop and the promise\r\n * returned by arrForEachAsync will be rejected with the same error.\r\n * @since 0.5.0\r\n * @group Loop\r\n * @group Array\r\n * @group ArrayLike\r\n * @typeParam T - Identifies the element type of the array\r\n * @param theArray - The array or array like object of elements to be searched.\r\n * @param callbackFn A `asynchronous` or `synchronous` function that accepts up to three arguments. arrForEach calls the callbackfn function one\r\n * time for each element in the array.\r\n * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, null or undefined\r\n * the array will be used as the this value.\r\n * @remarks\r\n * arrForEachAsync supports either a `synchronous` or `asynchronous` (returns a `Promise`) callback function. If the callback function returns\r\n * a `Promise` then the next iteration will not be called until the promise is resolved. If the callback function returns a `Promise` that is\r\n * rejected then the iteration will stop and the promise returned by arrForEachAsync will be rejected with the same error.\r\n * @example\r\n * ```ts\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * arrForEachASync(items, (value, index) => {\r\n *   copyItems.push(value);\r\n *   if (index === 5) {\r\n *     return -1; // Stop the iteration\r\n *   }\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * // Also supports input as an array like object\r\n * const items = { length: 3, 0: 'item1', 1: 'item2', 2: 'item3' };\r\n *\r\n * // Asynchronous examples using await\r\n * const items = ['item1', 'item2', 'item3', 'item4', 'item5', 'item6', 'item7', 'item8', 'item9', 'item10'];\r\n * const copyItems = [];\r\n *\r\n * await arrForEachASync(items, (value, index) => { // Note: DO NOT use async here unless you use await within the function\r\n *   if (index < 5) {\r\n *     // Logs each iteration index\r\n *     // Logs each value\r\n *     console.log(value);\r\n *     // Returning a promise will cause `arrForEachAsync` to return a promise to the caller\r\n *     // and wait for the promise to resolve before calling the callback function again.\r\n *     return createTimeoutPromise(10, true);\r\n *   }\r\n *\r\n *   return -1; // Stop the iteration\r\n * });\r\n * console.log(copyItems); // ['item1', 'item2', 'item3', 'item4', item5']\r\n *\r\n * ```\r\n */\r\nexport function arrForEachAsync(theArray, callbackFn, thisArg) {\r\n    if (theArray) {\r\n        var len_1 = getLength(theArray);\r\n        if (len_1) {\r\n            var isDone = function (state) {\r\n                if (state.iter >= len_1 || state.res === -1) {\r\n                    return true;\r\n                }\r\n            };\r\n            return doWhileAsync(function (state) {\r\n                var idx = state.iter;\r\n                if (idx in theArray) {\r\n                    return callbackFn.call(thisArg || theArray, theArray[idx], idx, theArray);\r\n                }\r\n            }, isDone);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=arrForEachAsync.js.map","/*\r\n * @nevware21/ts-async\r\n * https://github.com/nevware21/ts-async\r\n *\r\n * Copyright (c) 2024 NevWare21 Solutions LLC\r\n * Licensed under the MIT license.\r\n */\r\nimport { isUndefined, scheduleTimeout } from \"@nevware21/ts-utils\";\r\nimport { createPromise } from \"./promise\";\r\n/**\r\n * Creates a Promise instance that resolve or reject after the specified timeout.\r\n * @since 0.5.0\r\n * @group Timeout\r\n * @group Promise\r\n * @param timeout - The timeout in milliseconds to wait before resolving or rejecting the promise.\r\n * @param resolveReject - [Optional] If true the promise will resolve, otherwise it will reject.\r\n * @param message - [Optional] The message to use when rejecting the promise, if not supplied (or\r\n * undefined) the default message will be used.\r\n * @returns A promise that will resolve or reject after the specified timeout.\r\n * @example\r\n * ```ts\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100);\r\n * // Throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with default message\r\n * const result = await createTimeoutPromise(100, false);\r\n * // throws an Error: Timeout of 100ms exceeded\r\n *\r\n * // Resolves after 100ms with default message\r\n * const result = await createTimeoutPromise(100, true);\r\n * console.log(result); // Timeout of 100ms exceeded\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, false, \"Hello\");\r\n * // throws an Error: Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * const result = await createTimeoutPromise(100, true, \"Hello\");\r\n * console.log(result); // Hello\r\n *\r\n * // Resolves after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, true, \"Hello\"), (result) => {\r\n *  console.log(result); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwait(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   // Not called\r\n * }, (err) => {\r\n *   console.log(err); // Hello\r\n * });\r\n *\r\n * // Rejects after 100ms with the message \"Hello\"\r\n * doAwaitResult(createTimeoutPromise(100, false, \"Hello\"), (result) => {\r\n *   console.log(result.rejected); // true\r\n *   console.log(result.reason); // Hello\r\n * });\r\n * ```\r\n */\r\nexport function createTimeoutPromise(timeout, resolveReject, message) {\r\n    return createPromise(function (resolve, reject) {\r\n        scheduleTimeout(function () {\r\n            (resolveReject ? resolve : reject)(!isUndefined(message) ? message : \"Timeout of \" + timeout + \"ms exceeded\");\r\n        }, timeout);\r\n    });\r\n}\r\n//# sourceMappingURL=timeoutPromise.js.map"],"names":["_pureAssign","func1","func2","_pureRef","value","name","safe","func","argArray","v","apply","this","e","_createIs","theType","isUndefined","UNDEFINED","isPromiseLike","then","isFunction","polyObjHasOwn","obj","prop","ObjProto","hasOwnProperty","CALL","objGetOwnPropertyDescriptor","objForEachKey","theObject","callbackfn","thisArg","NULL_VALUE","OBJECT","objHasOwn","objDefine","target","key","propDesc","objDefineProp","propMap","l","get","desc","set","newValue","_assignMapValue","theMap","writable","enumerable","dumpObj","object","format","propertyValueDump","EMPTY","objType","TO_STRING","ERROR_TYPE","stack","asString","message","JSON","stringify","UNDEF_VALUE","replace","throwTypeError","TypeError","_doNothing","_getProto","__PROTO__","createEnumKeyMap","values","completeFn","objFreeze","_getGlobalValue","result","globalThis","self","window","global","_unwrapProp","propName","_initTestHooks","gbl","_globalCfg","GLOBAL_CONFIG_KEY","_globalLazyTestHooks","createCachedValue","toJSON","_getGlobalInstFn","getFn","theArgs","cachedValue","lzy","getGlobal","useCached","_cachedGlobal","getInst","WINDOW","getWindow","_initSymbol","_symbol","SYMBOL","getSymbol","getKnownSymbol","noPoly","description","knownName","_wellKnownSymbolMap","sym","_wellKnownSymbolCache","theSymbol","toString","POLYFILL_TAG","isIterator","next","isIterable","iterForOf","iter","_iterSymbol$1","err","iterResult","count","done","failed","throw","return","fnApply","fn","arrForEach","theArray","len","LENGTH","idx","arrSlice","ArrSlice","arguments","polyObjCreate","type","tempFunc","PROTOTYPE","objSetPrototypeOf","proto","ObjClass","d","b","_a","_isProtoArray","Array","_setName","baseClass","NAME","createCustomError","constructCb","errorBase","theBaseClass","Error","orgName","captureFn","captureStackTrace","_this","orgProto","_self","objGetPrototypeOf","CONSTRUCTOR","c","objCreate","__","utcNow","Date","now","polyUtcNow","getTime","_createTimerHandler","startTimer","refreshFn","cancelFn","theTimerHandler","ref","timerId","_unref","UNREF","_cancel","_refresh","cancel","refresh","HAS_REF","REF","h","ENABLED","dn","scheduleTimeout","overrideFn","isArr","isArray","length","setFn","setTimeout","clearFn","clearTimeout","timerFn","handler","doAwaitResponse","cb","doAwait","status","rejected","reason","REJECTED","resolveFn","rejectFn","finallyFn","doFinally","finally","_hasInitEventFn","doc","evt","createEvent","initEvent","dumpFnObj","_createAggregationError","_aggregationError","args","errors","_createPromise","newPromise","processor","executor","_settledValue","_thePromise","thePromise","handledFn","props","additionalArgs","_state","_hasResolved","_queue","_id","_uniquePromiseId","_parentId","_currentPromiseId","undefined","_handled","_unHandledRejectionHandler","_then","onResolved","onRejected","push","resolve","reject","_processQueue","pop","_strState","STRING_STATES","pending","slice","_createSettleIfFn","newState","allowState","theValue","_notifyUnhandledRejection","_unhandledRejectionTimeout","evtName","theConsole","theEvt","isNode","process","emit","NODE_UNHANDLED_REJECTION","_hasPromiseRejectionEvent","STR_PROMISE","UNHANDLED_REJECTION","populateEvent","g","useNewEvent","getDocument","_hasInitEvent","Event","DISPATCH_EVENT","catch","onFinally","thenFinally","catchFinally","_promiseDebugEnabled","resultFn","call","_debugResult","_debugHandled","_debugState","objDefineProperties","_rejectFn","_createAllPromise","input","values_1","pending_1","item","_createResolvedPromise","_createRejectedPromise","_resolve","_createAllSettledPromise","processItem","_createRacePromise","isDone","_createAnyPromise","theErros","syncItemProcessor","createAsyncPromise","timeout","callbackTimeout","isNumber","createAsyncAllSettledPromise","_allAsyncSettledCreator","createAsyncRacePromise","_raceAsyncCreator","createAsyncAnyPromise","_anyAsyncCreator","_createNativePromiseHelper","_promiseCls","createNativePromise","PrmCls","createSyncPromise","setDefaultIdlePromiseTimeout","idleDeadline","_defaultIdleTimeout","createIdlePromise","options","theTimeout","callback","deadline","scheduleIdleCallback","handler_1","_createDeadline","timedOut","startTime","didTimeout","timeRemaining","_maxExecutionTime","getIdleCallback","idleId","getCancelIdleCallback","createPromise","_promiseCreator","_doneChk","state","res","doWhileAsync","callbackFn","isDoneFn","promise","_createPromise_1","_handleAsyncDone_1","_processNext_1","st","rej","cbResult","dnRes","_rejectDone","_createError","_customErrors","concat","id","cr","_abortStaleTasks","taskQueue","staleTimeoutPeriod","expired","rj","REJECT","_removeTask","queue","taskDetail","arrIndexOf","splice","ArrProto","getLength","DONE","_allCreator","_allNativeSettledCreator","_raceNativeCreator","_anyNativeCreator","createAsyncAllPromise","createAsyncResolvedPromise","createAsyncRejectedPromise","_allSyncSettledCreator","_raceSyncCreator","_anySyncCreator","createNativeResolvedPromise","createNativeRejectedPromise","_allIdleSettledCreator","_raceIdleCreator","_anyIdleCreator","createSyncAllPromise","createSyncResolvedPromise","createSyncRejectedPromise","setDefaultIdleTimeout","_allSettledCreator","_raceCreator","_anyCreator","createIdleAllPromise","createIdleResolvedPromise","createIdleRejectedPromise","_iterSymbol","_iterAsyncSymbol","createAllPromise","createResolvedPromise","createRejectedPromise","_debugName","_debugIntState","REJECTED_ERROR","_schedulerId","toStringTagSymbol","Object","ArrCls","w","s","String","asyncIterator","hasInstance","isConcatSpreadable","iterator","match","matchAll","search","species","split","toPrimitive","toStringTag","unscopables","versions","node","funcName","clsFn","theFunc","toLowerCase","PolyPromiseImpl","_$","all","race","any","allSettled","theProto","prototype","onfinally","len_1","_startBlockedTimer","hasTasks","_running","_waiting","_staleTimeoutPeriod","_blockedTimer","enabled","_staleTimeoutCheckPeriod","unref","_runTask","startAction","onTaskResolve","onTaskReject","_promiseReject","_doCleanup","taskId","startResult","to","t","theResult","_theTask","theScheduler","stateFn","_taskCount","_schedulerName","idle","taskName","prevTask","newTask","p","onWaitResolve","onWaitReject","setStaleTimeout","staleTimeout","staleCheckPeriod","r","resolveReject","theIter","onFailed","creator","logger"],"mappings":";;;;;;AAMA,SAASA,EAAYC,EAAOC,GACxB,OAAOD,GAASC,CACpB,CAEA,SAASC,EAASC,EAAOC,GACrB,OAAOD,EAAMC,EACjB,CA0BA,SAASC,EAAKC,EAAMC,GAChB,IACI,MAAO,CACHC,EAAGF,EAAKG,MAAMC,KAAMH,CAAQ,CACxC,CAIK,CAFD,MAAOI,GACH,MAAO,CAAEA,EAAGA,EACf,CACL,CAUA,SAASC,EAAUC,GACf,OAAO,SAAUV,GACb,OAAO,OAAOA,IAAUU,CAChC,CACA,CAiBA,SAASC,EAAYX,GACjB,OAAO,OAAOA,IAAUY,GAAaZ,IAAUY,CACnD,CA8CA,SAASC,EAAcb,GACnB,OAAUA,GAASA,EAAMc,MAAQC,EAAWf,EAAMc,IAAI,CAC1D,CAwBA,SAASE,EAAcC,EAAKC,GACxB,MANO,CAAC,CAMiBD,GANTE,GAASC,eAAeC,GAMfJ,EAAKC,CANyB,GAMhB,CAAC,CAACI,GAA4BL,EAAKC,CAAI,CAClF,CAEA,SAASK,EAAcC,EAAWC,EAAYC,GAC1C,GAAIF,IAAsBA,GAAAA,IAtETG,GAAchB,CAAAA,EAsELa,CAtEsB,IAsEtBA,GA5CR,OA4CQA,IA5CSI,GA6C/B,IAAK,IAAIV,KAAQM,EACb,GAAIK,GAAUL,EAAWN,CAAI,GAC6C,CAAC,IAAnEO,EAAWJ,GAAMK,GAAWF,EAAWN,EAAMM,EAAUN,EAAK,EAC5D,KAKpB,CAqDA,SAASY,EAAUC,EAAQC,EAAKC,GAC5B,OAAOC,EAAcH,EAAQC,GA3CZhC,EA2C6BiC,GA1C1Cf,EAAO,IACNiB,GAAW,GAAK,CAAA,EACrBjB,EAAKiB,GAAW,GAAK,CAAA,EACjBnC,EAAMoC,IACNlB,EAAKmB,IAAM,WAAc,OAAOrC,EAAMoC,EAAE/B,GACpCiC,EAAOhB,GAA4BtB,EAAMoC,EAAG,GAAG,IACvCE,EAAKC,MACbrB,EAAKqB,IAAM,SAAUC,GACjBxC,EAAMoC,EAAE/B,EAAImC,CAC5B,GAGIjB,EAAcvB,EAAO,SAAUgC,EAAKhC,GAChCkB,EAAKiB,GAAQH,IAAQrB,EAAYX,CAAK,EAAIkB,EAAKiB,GAAQH,IAAQhC,CACvE,CAAK,EACMkB,EA2BgD,EA3C3D,IAAqBlB,EACbkB,CA2CR,CAkBA,SAASuB,EAAgBC,EAAQV,EAAKhC,EAAO2C,GACzCT,EAAcQ,EAAQV,EAAK,CACvBhC,MAAOA,EACP4C,WAAY,CAAA,EACZD,SAAU,CAAC,CAACA,CACpB,CAAK,CACL,CAMA,SAASE,EAAQC,EAAQC,GACrB,IAAIC,EAAoBC,GACpBC,EAAU/B,GAASgC,IAAW9B,GAAMyB,CAAM,EAC1CI,IAAYE,KACZN,EAAS,CAAEO,MAAOC,EAASR,EAAOO,KAAK,EAAGE,QAASD,EAASR,EAAOS,OAAO,EAAGtD,KAAMqD,EAASR,EAAO7C,IAAI,IAE3G,IAEI+C,GADAA,EAAoBQ,KAAKC,UAAUX,EAAQnB,EAAYoB,EAA6B,UAAlB,OAAOA,EAAuBA,EAAS,EAAKW,CAAW,IAC/EV,EAAkBW,QAAQ,sBAAuB,MAAM,GAAML,EAASR,CAAM,CAIzH,CAFD,MAAOtC,GACHwC,EAAoB,MAAQH,EAAQrC,EAAGuC,CAAM,CAChD,CACD,OAAOG,EAAU,KAAOF,CAC5B,CAKA,SAASY,EAAeL,GACpB,MAAM,IAAIM,UAAUN,CAAO,CAC/B,CA4BA,SAASO,EAAW9D,GAChB,OAAOA,CACX,CAEA,SAAS+D,EAAU/D,GACf,OAAOA,EAAMgE,KAAcrC,CAC/B,CAuBA,SAASsC,EAAiBC,GACtB,OAnGoDC,EAmGVC,GAlGtC1B,EAAS,GACbnB,EAiG0B2C,EAjGJ,SAAUlC,EAAKhC,GACjCyC,EAAgBC,EAAQV,EAAuBA,EAHaW,KAAAA,CAGA,EAC5DF,EAAgBC,EAAQ1C,EAA2BgC,EAJSW,KAAAA,CAII,CACxE,CAAK,EACMwB,EAAaA,EAAWzB,CAAM,EAAIA,EAN7C,IAAwDyB,EAChDzB,CAmGR,CAsCA,SAAS2B,IACL,IAAIC,EAaJ,OALIA,GAHAA,GAHAA,EADA,OAAOC,aAAe3D,EACb2D,WAERD,IAAU,OAAOE,OAAS5D,EAG1B0D,EAFQE,OAEE,OAAOC,SAAW7D,EAG5B0D,EAFQG,SAEE,OAAOC,SAAW9D,EAG1B0D,EAFMI,MAGjB,CAwBA,SAASC,EAAYC,GACjB,OAAO,SAAUlD,GACb,OAAOA,EAAQkD,EACvB,CACA,CAuFA,SAASC,IAjHT,IAEYC,EADHC,KACGD,EAAM5E,EAAKmE,CAAe,EAAEhE,GAAK,GACrC0E,GAAaD,EAAIE,IAAqBF,EAAIE,KAAsB,IA+GpEC,EA7GOF,EA8GX,CA2BA,SAASG,EAAkBlF,GACvB,OAAOkC,EAAc,CACjBiD,OAAQ,WAAc,OAAOnF,CAAQ,CACxC,EAAE,IAAK,CAAEA,MAAOA,CAAO,CAAA,CAC5B,CAmBA,SAASoF,EAAiBC,EAAOC,GAC7B,IAAIC,EACJ,OAAO,WAGH,OAFCN,GAAwBJ,KACsBU,EAA7CA,GAAeN,CAAAA,EAAqBO,IAC/BD,EADsDL,EAAkBhF,EAAKmF,EAAOC,CAAO,EAAEjF,CAAC,GAClFA,CAC3B,CACA,CAMA,SAASoF,EAAUC,GAGf,OAFCT,GAAwBJ,KAC+Cc,GAAtEA,IAA+B,CAAA,IAAdD,GAAuBT,CAAAA,EAAqBO,IACxDG,GADiFT,EAAkBhF,EAAKmE,CAAe,EAAEhE,GAAKsB,CAAU,GAC1HtB,CACzB,CAEA,SAASuF,EAAQ3F,EAAMyF,GACfZ,EAAQa,IAA+B,CAAA,IAAdD,EAA8CC,GAActF,EAArCoF,EAAUC,CAAS,EACvE,OAAIZ,GAAOA,EAAI7E,GACJ6E,EAAI7E,GAEXA,IAAS4F,GACFC,GAAS,EAEbnE,CACX,CAgCA,SAASoE,IAEL,OADAC,GAAyBd,EAAkBhF,IAAgB,CAAC+F,GAAO,EAAE5F,CAAE,CAE3E,CAWA,SAAS6F,IAEL,OADCjB,GAAwBJ,MACfI,EAAqBO,IAAgB,EAAVQ,KAAgBD,EAAa,GAAE1F,CACxE,CAEA,SAAS8F,EAAelG,EAAMmG,GAC1B,IA5KmBC,EA4KfC,EAAYC,GAAoBtG,GAEhCuG,GADHvB,GAAwBJ,KACZI,EAAqBO,IAAgB,EAAVQ,KAAgBD,EAAW,GACnE,OAAOS,EAAInG,EAAImG,EAAInG,EAAEiG,GAAarG,GAAUmG,EAAoC1C,GAjJ/E+C,GAAAA,IAAkD,IAE/CH,EAAYC,GA+IwDtG,IA7I3DwG,GAAsBH,GAAaG,GAAsBH,MAjClEI,EAAY,CACZL,YAAa/C,EAFE+C,EAkC+EJ,GAAS,IAAMK,CAhC5E,EACjCK,SAAU,WAAc,OAAOV,GAAS,IAAMI,EAAc,GAAM,CAC1E,GACcO,IAAgB,CAAA,EACnBF,GAyBHpC,KAAAA,EAiJR,CAqBA,SAASuC,EAAW7G,GAChB,OAASA,GAASe,EAAWf,EAAM8G,IAAI,CAC3C,CAEA,SAASC,EAAW/G,GAChB,OAAgCA,IA1jBf2B,IA0jBe3B,GAAAA,IAtjBR0D,IAsjBkB3C,EAAWf,EAAMmG,EAAe,CAAG,EAAC,CAClF,CAGA,SAASa,EAAUC,EAAMxF,EAAYC,GACjC,GAAIuF,IACKJ,EAAWI,CAAI,IAEhBA,EAAOA,GADNC,GAAAA,IAAkChC,EAAkBiB,EAAe,CAAG,CAAA,GAC7C9F,GAAK4G,EAAKC,GAAc7G,GAAI,EAAG,MAEzDwG,EAAWI,CAAI,GAAG,CAClB,IAAIE,EAAMzD,EACN0D,EAAa1D,EACjB,IAEI,IADA,IAAI2D,EAAQ,EACL,EAAED,EAAaH,EAAKH,KAAI,GAAIQ,MAC0C,CAAC,IAAtE7F,EAAWJ,GAAMK,GAAWuF,EAAMG,EAAWpH,MAAOqH,EAAOJ,CAAI,GAGnEI,CAAK,EAsBZ,CAnBD,MAAOE,GACHJ,EAAM,CAAE3G,EAAG+G,GACPN,EAAKO,QACLJ,EAAazF,EACbsF,EAAKO,MAAML,CAAG,EAErB,CACO,QACJ,IACQC,GAAc,CAACA,EAAWE,MAC1BL,EAAKQ,QAAUR,EAAKQ,OAAOL,CAAU,CAQ5C,CALO,QACJ,GAAID,EAEA,MAAMA,EAAI3G,CAEjB,CACJ,CACJ,CAET,CAEA,SAASkH,GAAQC,EAAIjG,EAAStB,GAC1B,OAAOuH,EAAGrH,MAAMoB,EAAStB,CAAQ,CACrC,CA4BA,SAASwH,GAAWC,EAAUpG,EAAYC,GACtC,GAAImG,EAEA,IADA,IAAIC,EAAMD,EAASE,MAAY,EACtBC,EAAM,EAAGA,EAAMF,GAChBE,EAAAA,KAAOH,GACqE,CAAC,IAAzEpG,EAAWJ,GAAMK,GAAWmG,EAAUA,EAASG,GAAMA,EAAKH,CAAQ,GAFjDG,CAAG,IAQxC,CAOA,SAASC,EAASJ,GACd,OAASA,GAAYA,EAAgB,OAAMK,GAAU5H,MAAMuH,EAAUK,EAAS7G,GAAM8G,UAAW,CAAC,CAAC,CACrG,CA2HA,SAASC,GAAcnH,GACnB,IAGIoH,EAHJ,OAAKpH,IAGDoH,EAAO,OAAOpH,KACLW,IAp2BF,YAo2BYyG,GACnBzE,EAAe,4CAA8Cf,EAAQ5B,CAAG,CAAC,EAG7EqH,EAASC,GAAatH,EACf,IAAIqH,GARA,GAMX,SAASA,KAGb,CAGA,SAASE,GAAkBvH,EAAKwH,GAO5B,OANSC,EAAyB,gBAC9B,SAAUC,EAAGC,GACT,IAAIC,GACHC,GAAAA,IAAkC5D,IAAmB2D,EAAK,IAAO7E,IAAa,GAAI6E,aAAeE,MAAK,GACzF1I,EAAIsI,EAAE3E,IAAa4E,EAAIrH,EAAcqH,EAAG,SAAU5G,EAAKhC,GAAS,OAAO2I,EAAE3G,GAAOhC,CAAM,CAAE,CAClH,GACciB,EAAKwH,CAAK,CACxB,CAaA,SAASO,GAASC,EAAWhJ,GACzBA,IAASgJ,EAAUC,IAAQjJ,EAC/B,CAEA,SAASkJ,GAAkBlJ,EAAMmJ,EAAaC,GAC1C,IAfwBpJ,EAAM0I,EAe1BW,EAAeD,GAAaE,MAC5BC,EAAUF,EAAaf,GAAWW,IAClCO,EAAYF,MAAMG,kBAjBWd,EAqC9BU,EAnBH,OAjBApJ,EAAK4B,EAAW,CADc6G,EAkBE,WAC5B,IAAIgB,EAAQpJ,KACR+E,EAAU6C,UACd,IACIjI,EAAK8I,GAAU,CAACM,EAAcrJ,EAAK,EACnC,IAEQ2J,EAFJC,EAAQnC,GAAQ4B,EAAcK,EAAOzB,EAAS7G,GAAMiE,CAAO,CAAC,GAAKqE,EASrE,OARIE,IAAUF,IACNC,EAAWE,GAAkBH,CAAK,KACrBG,GAAkBD,CAAK,GACpCrB,GAAkBqB,EAAOD,CAAQ,EAGzCH,GAAaA,EAAUI,EAAOF,EAAMI,GAAY,EAChDX,GAAeA,EAAYS,EAAOvE,CAAO,EAClCuE,CAIV,CAFO,QACJ3J,EAAK8I,GAAU,CAACM,EAAcE,EAAQ,CACzC,CACJ,EApCmBN,GAAM,CAAE7I,EADJJ,EAkBEA,EAjBW+J,EAAG,CAAA,EAAMxJ,EAAG,CAAA,CAAK,EAAG,GACzDmI,EAAIH,GAAkBG,EAAGC,CAAC,GAKxBL,GAAaK,IAAMjH,EAAasI,GAAUrB,CAAC,GAAKsB,EAAG3B,GAAaK,EAAEL,GAAY,IAAI2B,GAC7EvB,EALP,SAASuB,IACL3J,KAAKwJ,IAAepB,EACpBzI,EAAK4B,EAAW,CAACvB,KAAM2I,GAAM,CAAE7I,EAAGJ,EAAM+J,EAAG,CAAA,EAAMxJ,EAAG,CAAA,CAAK,EAAG,CAC/D,CAgCL,CAUA,SAAS2J,IACL,OAAQC,KAAKC,KAAOC,KACxB,CAEA,SAASA,KACL,OAAO,IAAIF,MAAOG,SACtB,CA0sBA,SAASC,GAAoBC,EAAYC,EAAWC,GAChD,IAEIC,EAFAC,EAAM,CAAA,EACNC,EAAUL,EAAaC,EAAU/I,CAAU,EAAIA,EAEnD,SAASoJ,IAGL,OAFAF,EAAM,CAAA,EACNC,GAAWA,EAAQE,KAAUF,EAAQE,IAAM,EACpCJ,CACV,CACD,SAASK,IACLH,GAAWH,EAASG,CAAO,EAC3BA,EAAUnJ,CACb,CACD,SAASuJ,IAKL,OAJAJ,EAAUJ,EAAUI,CAAO,EACtBD,GACDE,IAEGH,CACV,CAyBD,OApBAA,EAAkB,CACdO,OAAQF,EACRG,QAASF,CACjB,GACoBG,IAAW,WACvB,OAAIP,GAAWA,EAAQO,IACZP,EAAQO,MAEZR,CACf,EACID,EAAgBU,IAAO,WAGnB,OAFAT,EAAM,CAAA,EACNC,GAAWA,EAAQQ,KAAQR,EAAQQ,IAAI,EAChCV,CACf,EACIA,EAAgBI,IAASD,EAKlB,CACHQ,EALJX,EAAkB1I,EAAc0I,EAAiBY,GAAS,CACtDnJ,IAAK,WAAc,MAAO,CAAC,CAACyI,CAAU,EACtCvI,IAtBJ,SAAqBvC,GACjB,CAACA,GAAS8K,GAAWG,IACrBjL,GAAS,CAAC8K,GAAWI,GACxB,CAoBL,CAAK,EAGGO,GAAI,WACAX,EAAUnJ,CACb,CACT,CACA,CA0BA,SAAS+J,IACL,OAzBoCC,EAyBJjI,EAzBgB4B,EAyBH4C,EAAS7G,GAAM8G,SAAS,EAvBjEL,GADA8D,EAAQC,GAAQF,CAAU,GACZA,EAAWG,OAAS,EAClCC,GAAe,EAANjE,EAAU6D,EAAW,GAAOC,EAAqBlI,EAAbiI,IAA8BK,WAC3EC,GAAiB,EAANnE,EAAU6D,EAAW,GAAKjI,IAAgBwI,aACrDC,EAAU7G,EAAQ,GACtBA,EAAQ,GAAK,WACT8G,EAAQX,GAAE,EACV/D,GAAQyE,EAASzI,EAAawE,EAAS7G,GAAM8G,SAAS,CAAC,CAC/D,GACQiE,EAAU5B,GAeY,CAAA,EAfoB,SAAUM,GACpD,GAAIA,EAAS,CACT,GAAIA,EAAQM,QAER,OADAN,EAAQM,QAAO,EACRN,EAEXpD,GAAQuE,EAASvI,EAAa,CAACoH,EAAQ,CAC1C,CACD,OAAOpD,GAAQqE,EAAOrI,EAAa4B,CAAO,CAC7C,EAAE,SAAUwF,GACTpD,GAAQuE,EAASvI,EAAa,CAACoH,EAAQ,CAC/C,CAAK,GACcS,EAtBnB,IAAwCI,EAAYrG,EAC5CsG,EACA9D,EACAiE,EACAE,EACAE,EAKAC,CAgBR,CC1qDO,SAASC,GAAgBrM,EAAOsM,GACnC,OAAOC,EAAQvM,EAAO,SAAUA,GAC5B,OAAOsM,EAAKA,EAAG,CACXE,OAAQ,YACRC,SAAU,CAAA,EACVzM,MAAOA,CACV,CAAA,EAAIA,CACR,EAAE,SAAU0M,GACT,OAAOJ,EAAKA,EAAG,CACXE,OAAQG,GACRF,SAAU,CAAA,EACVC,OAAQA,CACX,CAAA,EAAIA,CACb,CAAK,CACL,CAmCO,SAASH,EAAQvM,EAAO4M,EAAWC,EAAUC,GAChD,IAAIxI,EAAStE,EACb,IACI,GAAIa,EAAcb,CAAK,GACf4M,GAAaC,KACbvI,EAAStE,EAAMc,KAAK8L,EAAWC,CAAQ,QAI3C,IACQD,IACAtI,EAASsI,EAAU5M,CAAK,EAU/B,CAPD,MAAOmH,GACH,GAAI0F,CAAAA,EAIA,MAAM1F,EAHN7C,EAASuI,EAAS1F,CAAG,CAK5B,CAOR,CAJO,QACA2F,GACAC,GAAUzI,EAAQwI,CAAS,CAElC,CACD,OAAOxI,CACX,CASO,SAASyI,GAAU/M,EAAO8M,GAC7B,IAAIxI,EAAStE,EAqBb,OApBI8M,IACIjM,EAAcb,CAAK,EAEfsE,EADAtE,EAAMgN,QACGhN,EAAMgN,QAAQF,CAAS,EAIvB9M,EAAMc,KAAK,SAAUd,GAE1B,OADA8M,IACO9M,CACV,EAAE,SAAU0M,GAET,MADAI,IACMJ,CAC1B,CAAiB,EAILI,KAGDxI,CACX,CC3IA,SAAS2I,GAAgBC,GACrB,IAAIC,EAIJ,MAAQ,CAAC,EAFLA,EADAD,GAAOA,EAAIE,YACLF,EAAIE,YAAY,OAAO,EAEvBD,IAAOA,EAAIE,SACzB,CCAA,SAASC,GAAUtN,GACf,OAAIe,EAAWf,CAAK,EACTA,EAAM2G,WAEV9D,EAAQ7C,CAAK,CACxB,CAcA,SAASuN,GAAwBrJ,GAI7B,OAAO,IAHNsJ,GAAAA,IAA0CtI,EAAkBhF,EAAK0F,EAAS,CAAC,mBAAmB,EAAEvF,GAAK8I,GAAkB,mBAAoB,SAAU3E,EAAMiJ,GACxJjJ,EAAKkJ,OAASD,EAAK,EACtB,CAAA,CAAC,GAC2BpN,EAAE6D,CAAM,CACzC,CAYO,SAASyJ,GAAeC,EAAYC,EAAWC,GAClD,IAGIC,EAMAC,EC3BuBC,EAA+BC,EAMtDC,EDYAC,EAAiBnG,EAASE,UAAW,CAAC,EACtCkG,EAAS,EACTC,EAAe,CAAA,EAEfC,EAAS,GACTC,EAAMC,EAAgB,GACtBC,EAAuC,EAA3BC,EAAkB7C,OAAa6C,EAAkBA,EAAkB7C,OAAS,GAAK8C,KAAAA,EAC7FC,EAAW,CAAA,EACXC,EAA6B,KAGjC,SAASC,EAAMC,EAAYC,GACvB,IA8DI,OA7DAN,EAAkBO,KAAKV,CAAG,EAC1BK,EAAW,CAAA,EACXC,GAA8BA,EAA2B3D,SACzD2D,EAA6B,KACXlB,EAAW,SAAUuB,EAASC,GAM5Cb,EAAOW,KAAK,WAGR,IAOI,IAAI9C,EAAqB,IAAXiC,EAA4CW,EAAaC,EACnEjP,EAAQW,EAAYyL,CAAO,EAAI2B,EAAiBhN,EAAWqL,CAAO,EAAIA,EAAQ2B,CAAa,EAAI3B,EAI/FvL,EAAcb,CAAK,EAGnBA,EAAMc,KAAKqO,EAASC,CAAM,GAErBhD,GAIW,IAAXiC,EAQLc,EALAC,GALQpP,CAAK,CAepB,CAFD,MAAOQ,GACH4O,EAAO5O,CAAC,CACX,CACrB,CAAiB,EAMG8N,GACAe,GAEP,EAAEjB,CAAc,CAQpB,CAFO,QACJO,EAAkBW,IAAG,CACxB,CACJ,CAsBD,SAASC,IACL,OAAOC,GAAcnB,EACxB,CACD,SAASgB,IACL,IAGQI,EAHY,EAAhBlB,EAAOzC,SAGH2D,EAAUlB,EAAOmB,QACrBnB,EAAS,GAITM,EAAW,CAAA,EACXC,GAA8BA,EAA2B3D,SACzD2D,EAA6B,KAC7BjB,EAAU4B,CAAO,EAUxB,CACD,SAASE,EAAkBC,EAAUC,GACjC,OAAO,SAAUC,GACTzB,IAAWwB,IACM,IAAbD,GAA+C/O,EAAciP,CAAQ,GACrEzB,EAAS,EAITyB,EAAShP,KAAK6O,EAAkB,EAAgC,CAAgC,EAAEA,EAAkB,EAAgC,CAAC,CAA+B,IAGxLtB,EAASuB,EACTtB,EAAe,CAAA,EACfP,EAAgB+B,EAIhBT,IACKR,GAAyB,IAAbe,IAAgDd,EAAAA,GAIhCpD,EAAgBqE,EAA2BC,EAA0B,IAQtH,CACK,CACD,SAASD,IACL,ID5LkBhO,EAAQkO,EAiBlBC,EAhBRhD,EAEAiD,ECyLKtB,IAEDA,EAAW,CAAA,EACPuB,GAAM,EAINC,QAAQC,KAAKC,GAA0BxC,EAAeC,CAAW,GAG7DlJ,EAAMgB,MAAeL,IACxB+K,GAAAA,IAA0DtL,EAAkBhF,EAAM,EAAU,CAACuQ,EAAc,iBAAiB,EAAEpQ,CAAC,EDvMtH0B,EC2MA+C,ED3MQmL,EC2MHS,GD3MYC,EC2MS,SAAUR,GAG1C,OAFArO,EAAUqO,EAAQ,UAAW,CAAES,EAAG,WAAc,OAAO5C,CAAc,CAAA,CAAE,EACvEmC,EAAOzD,OAASqB,EACToC,CAC3B,ED/M0DU,EC+MvC,CAAC,CAACL,GAA0BnQ,ED9MvC6M,EAAM4D,KAGOH,EADbR,GADHY,GAAAA,IAAkC7L,EAAkB,CAAC,CAAChF,EAAK+M,GAAiB,CAACC,EAAI,EAAE7M,CAAC,GAC1DA,EAAI6M,EAAIE,YAAY,OAAO,EAAKyD,EAAc,IAAIG,MAAMf,CAAO,EAAI,EACzD,EACjCc,GAAc1Q,GACd8P,EAAO9C,UAAU4C,EAAS,CAAA,EAAO,CAAA,CAAI,EAErCE,GAAUpO,EAAOkP,IACjBlP,EAAOkP,IAAgBd,CAAM,GAGzB/D,EAAUrK,EAAO,KAAOkO,IAExB7D,EAAQ+D,CAAM,GAGVD,EAAatK,EAAQ,SAAS,KACnBsK,EAAkB,OAAKA,EAAgB,KAAGD,EAASpN,EAAQsN,CAAM,CAAC,GCgMxF,CAMDjO,EALA8L,EAAc,CACVlN,KAAMiO,EACNmC,MAxGJ,SAAgBjC,GAEZ,OAAOF,EAAMH,KAAAA,EAAWK,CAAU,CACrC,EAsGGjC,QApGJ,SAAkBmE,GACd,IAAIC,EAAcD,EACdE,EAAeF,EAWnB,OAVIpQ,EAAWoQ,CAAS,IACpBC,EAAc,SAAUpR,GAEpB,OADAmR,GAAaA,EAAS,EACfnR,CACvB,EACYqR,EAAe,SAAU3E,GAErB,MADAyE,GAAaA,EAAS,EAChBzE,CACtB,GAEeqC,EAAMqC,EAAaC,CAAY,CACzC,CAuFL,EAC+B,QAAS,CAChChP,IAAKkN,CACb,CAAK,EACG+B,KCjNuBrD,EDmNRD,ECnN6BuD,EDmNL,WAAc,OHvLxCvR,EGuL2D+N,EHtLrE5M,GAASgC,IAAWqO,KAAKxR,CAAK,EADzC,IAAqBA,CGuL4E,ECnNnCkO,EDmNqC,WAAc,OAAOW,CAAW,EC/M/H4C,GAAeA,IAAgB,CAAE9K,SAAU,WAAc,MAAO,mBAAoB,GACpF+K,GAAgBA,IAAiB,CAAE/K,SAAU,WAAc,MAAO,sBAAuB,IACrFwH,EAAQ,IAHZwD,GAAcA,IAAe,CAAEhL,SAAU,WAAc,MAAO,kBAAmB,IAI5D,CAAEtE,ID4MSkN,CC5MG,EACnCpB,EAAMsD,IAAgB,CAAEpP,IAAKkP,CAAQ,EACrCpD,EAAMuD,IAAiB,CAAErP,IAAK6L,CAAS,EACvC0D,GAAoB3D,EAAYE,CAAK,GJ0jBbjI,EAAW,IG9W/B8H,EAAY7H,EAAe,EAAsC,GAAI,YASzE6H,EAAYrH,SAHZ,WACI,MAAO,YAAc2K,GAAuB,IAAM9C,GAAQ7N,EAAY+N,CAAS,EAAwB,GAAnB,IAAMA,GAAmB,IAAM,IAAM,IAAMa,EAAW,GAAIjB,EAAgB,MAAQhB,GAAUS,CAAa,EAAK,GACrM,EAGQhN,EAAW+M,CAAQ,GACpBlK,EAAe6M,EAAc,kCAAoCnD,GAAUQ,CAAQ,CAAC,EAExF,IAAI+D,EAAYlC,EAAkB,EAAgC,CAAC,EACnE,IAII7B,EAAS0D,KAAKxD,EAAa2B,EAAkB,EAAgC,CAAC,EAA+BkC,CAAS,CAOzH,CALD,MAAOrR,GAIHqR,EAAUrR,CAAC,CACd,CAQL,OAAOwN,CACX,CAYO,SAAS8D,GAAkBlE,GAC9B,OAAO,SAAUmE,GACb,IAAI3D,EAAiBnG,EAASE,UAAW,CAAC,EAC1C,OAAOyF,EAAW,SAAUuB,EAASC,GACjC,IACI,IAAI4C,EAAW,GACXC,EAAY,EAChBjL,EAAU+K,EAAO,SAAUG,EAAMlK,GACzBkK,IACAD,CAAS,GACT1F,EAAQ2F,EAAM,SAAUlS,GAEpBgS,EAAShK,GAAOhI,EACI,GAAhB,EAAEiS,GACF9C,EAAQ6C,CAAQ,CAEvB,EAAE5C,CAAM,EAEjC,CAAiB,EAGiB,GADlB6C,EAAAA,GAGI9C,EAAQ6C,CAAQ,CAKvB,CAFD,MAAOxR,GACH4O,EAAO5O,CAAC,CACX,CACJ,EAAE4N,CAAc,CACzB,CACA,CAcO,SAAS+D,GAAuBvE,GACnC,OAAO,SAAU5N,GACb,IAAIoO,EAAiBnG,EAASE,UAAW,CAAC,EAC1C,OAAItH,EAAcb,CAAK,EACZA,EAEJ4N,EAAW,SAAUuB,GAIxBA,EAAQnP,CAAK,CAChB,EAAEoO,CAAc,CACzB,CACA,CAWO,SAASgE,GAAuBxE,GACnC,OAAO,SAAUlB,GACb,IAAI0B,EAAiBnG,EAASE,UAAW,CAAC,EAC1C,OAAOyF,EAAW,SAAUyE,EAAUjD,GAIlCA,EAAO1C,CAAM,CAChB,EAAE0B,CAAc,CACzB,CACA,CAaO,SAASkE,GAAyB1E,GAKrC,OAAO1I,EAAkB,SAAU6M,GAK/B,IAAI3D,EAAiBnG,EAASE,UAAW,CAAC,EAC1C,OAAOyF,EAAW,SAAUuB,EAASC,GACjC,IAAIlL,EAAS,GACTuL,EAAU,EACd,SAAS8C,EAAYL,EAAMlK,GACvByH,CAAO,GACPpD,GAAgB6F,EAAM,SAAUlS,GACxBA,EAAMyM,SACNvI,EAAO8D,GAAO,CACVwE,OAAQG,GACRD,OAAQ1M,EAAM0M,MAC1C,EAGwBxI,EAAO8D,GAAO,CACVwE,OAAQ,YACRxM,MAAOA,EAAMA,KACzC,EAEsC,GAAd,EAAEyP,GACFN,EAAQjL,CAAM,CAEtC,CAAiB,CACJ,CACD,IACQ2H,GAAQkG,CAAK,EACbnK,GAAWmK,EAAOQ,CAAW,EAExBxL,EAAWgL,CAAK,EACrB/K,EAAU+K,EAAOQ,CAAW,EAG5B3O,EAAe,0BAA0B,EAI7B,GADhB6L,EAAAA,GAGIN,EAAQjL,CAAM,CAKrB,CAFD,MAAO1D,GACH4O,EAAO5O,CAAC,CACX,CACJ,EAAE4N,CAAc,CACzB,CAAK,CACL,CAiBO,SAASoE,GAAmB5E,GAK/B,OAAO1I,EAAkB,SAAU6M,GAK/B,IAAI3D,EAAiBnG,EAASE,UAAW,CAAC,EAC1C,OAAOyF,EAAW,SAAUuB,EAASC,GACjC,IAAIqD,EAAS,CAAA,EACb,SAASF,EAAYL,GACjB7F,GAAgB6F,EAAM,SAAUlS,GACvByS,IACDA,EAAS,CAAA,EACLzS,EAAMyM,SACN2C,EAAOpP,EAAM0M,MAAM,EAGnByC,EAAQnP,EAAMA,KAAK,EAG/C,CAAiB,CACJ,CACD,IACQ6L,GAAQkG,CAAK,EACbnK,GAAWmK,EAAOQ,CAAW,EAExBxL,EAAWgL,CAAK,EACrB/K,EAAU+K,EAAOQ,CAAW,EAG5B3O,EAAe,0BAA0B,CAKhD,CAFD,MAAOpD,GACH4O,EAAO5O,CAAC,CACX,CACJ,EAAE4N,CAAc,CACzB,CAAK,CACL,CAeO,SAASsE,GAAkB9E,GAK9B,OAAO1I,EAAkB,SAAU6M,GAK/B,IAAI3D,EAAiBnG,EAASE,UAAW,CAAC,EAC1C,OAAOyF,EAAW,SAAUuB,EAASC,GACjC,IAAIuD,EAAW,GACXlD,EAAU,EACVgD,EAAS,CAAA,EACb,SAASF,EAAYL,EAAMlK,GACvByH,CAAO,GACPpD,GAAgB6F,EAAM,SAAUlS,GACvBA,EAAMyM,UAMPkG,EAAS3K,GAAOhI,EAAM0M,OAER,GAAd,EAAE+C,GAAkBgD,GACpBrD,EAAO7B,GAAwBoF,CAAQ,CAAC,IARxCF,EAAS,CAAA,EACTtD,EAAQnP,EAAMA,KAAK,EAS3C,CAAiB,CACJ,CACD,IACQ6L,GAAQkG,CAAK,EACbnK,GAAWmK,EAAOQ,CAAW,EAExBxL,EAAWgL,CAAK,EACrB/K,EAAU+K,EAAOQ,CAAW,EAG5B3O,EAAe,0BAA0B,EAI7B,GADhB6L,EAAAA,GACsBgD,GAElBrD,EAAO7B,GAAwBoF,CAAQ,CAAC,CAK/C,CAFD,MAAOnS,GACH4O,EAAO5O,CAAC,CACX,CACJ,EAAE4N,CAAc,CACzB,CAAK,CACL,CEpjBO,SAASwE,GAAkBnD,GAC9B7H,GAAW6H,EAAS,SAAU9H,GAC1B,IACIA,GAKH,CAHD,MAAOnH,IAIf,CAAK,CACL,CCHO,SAASqS,EAAmB/E,EAAUgF,GACzC,OAAOnF,GAAekF,GDWlBE,EAAkBC,GADWF,ECV8BA,CDWzB,EAAIA,EAAU,EAC7C,SAAUrD,GACb/D,EAAgB,WACZkH,GAAkBnD,CAAO,CAC5B,EAAEsD,CAAe,CAC1B,GChB6EjF,EAAUgF,CAAO,EDUvF,IAA8BA,EAC7BC,CCVR,CAkFO,SAASE,GAA6BlB,EAAOe,GAEhD,OADCI,GAAAA,IAAsDZ,GAAyBO,CAAkB,GACnExS,EAAE0R,EAAOe,CAAO,CACnD,CAmBO,SAASK,GAAuBjP,EAAQ4O,GAE3C,OADCM,GAAAA,IAA0CZ,GAAmBK,CAAkB,GACvDxS,EAAE6D,EAAQ4O,CAAO,CAC9C,CAsBO,SAASO,GAAsBnP,EAAQ4O,GAE1C,OADCQ,GAAAA,IAAwCZ,GAAkBG,CAAkB,GACrDxS,EAAE6D,EAAQ4O,CAAO,CAC7C,CC1FO,SAASS,GAA2BtT,EAAME,GAE7C,OADCqT,EAAAA,GAA8BtO,EAAiChF,EAAK0F,EAAS,CAAC6K,EAAY,EAAG,GAAK,IAAI,GACvFpQ,GAAKmT,EAAYnT,EAAEJ,GACxBiF,EAAkB,SAAU6M,EAAOe,GACtC,OAAOW,EAAoB,SAAUtE,EAASC,GAC1CoE,EAAYnT,EAAEJ,GAAM8R,CAAK,EAAEjR,KAAKqO,EAASC,CAAM,CAC/D,CAAa,CACb,CAAS,EAEEjP,EAAI,CACf,CAcO,SAASsT,EAAoB3F,EAAUgF,GAE1C,IAAIY,GADHF,EAAAA,GAA8BtO,EAAiChF,EAAK0F,EAAS,CAAC6K,EAAY,EAAG,GAAK,IAAI,GAC9EpQ,EACzB,GAAI,CAACqT,EACD,OAAOb,EAAmB/E,CAAQ,EAEjC/M,EAAW+M,CAAQ,GACpBlK,EAAe6M,EAAc,kCAAoC5N,EAAQiL,CAAQ,CAAC,EAEtF,IAAIO,EAAS,EAITJ,EAAa,IAAIyF,EAAO,SAAUvE,EAASC,GAS3CtB,EARA,SAAkB9N,GACdqO,EAAS,EACTc,EAAQnP,CAAK,CAChB,EACD,SAAiB0M,GACb2B,EAAS,EACTe,EAAO1C,CAAM,CAChB,CACyB,CAClC,CAAK,EAID,OAHAxK,EAAc+L,EAAY,QAAS,CAC/B5L,IAfJ,WACI,OAAOmN,GAAcnB,EACxB,CAcL,CAAK,EACMJ,CACX,CChGO,SAAS0F,EAAkB7F,GAC9B,OAAOH,GAAegG,EAAmBf,GAAmB9E,CAAQ,CACxE,CCHO,SAAS8F,GAA6BC,GACzCC,GAAsBD,CAC1B,CAuBO,SAASE,EAAkBjG,EAAUgF,GACxC,IJGIkB,EIHAC,EAAatT,EAAYmS,CAAO,EAAIgB,GAAsBhB,EAC9D,OAAOnF,GAAeoG,GJGP,GIH4CE,IJIvDD,EAAU,CACNlB,QAAS,CIL0CmB,CJM/D,GAEW,SAAUxE,GACQ,SLwrDCyE,EKxrDSC,GAC3BvB,GAAkBnD,CAAO,CAC5B,CAFD2E,ILmsDIC,EAWJvB,EAtBgCkB,EKtrD7BA,ELurDP,SAASM,EAAgBC,GACrB,IAAIC,EApbDrK,EAAM,EAqbT,MAAO,CACHsK,WAAYF,EACZG,cAAe,WACX,OAAOC,IArbFH,EAqbkCA,EAxb5CrK,EAAM,EAIMqK,GADvB,IAAqBA,CAsbR,CACb,CACK,CAnBuBI,GAAiB,GAqBjCP,EAAY7J,GAAoB,CAAA,EAAM,SAAUqK,GAEhD,OADAA,GAAUC,KAAwBD,CAAM,EACjCD,GAAe,EAAG,SAAUT,GAC/BE,EAAU5I,GAAE,EACZyI,EAASC,GAAYG,EAAgB,CAAA,CAAK,CAAC,CAC9C,EAAEN,CAAO,CACb,EAAE,SAAUa,GACTC,GAAqB,EAAGD,CAAM,CAC1C,CAAS,GACgBtJ,EAMdG,EAAgB,WACnBwI,EAASI,EAAgB,CAAA,CAAI,CAAC,CACjC,EALG3T,EADAmS,GAAWkB,GAAW,IAAIlB,OACP,EACTgB,GAIXhB,CAAO,CKjtDd,GIZ4EhF,EAAUmG,CAAU,CAChG,CCZO,SAASc,EAAcjH,EAAUgF,GAEpC,OADCkC,GAAAA,IAAsC9P,EAAkBuO,CAAmB,GACrDpT,EAAEmR,KAAKjR,KAAMuN,EAAUgF,CAAO,CACzD,CC7BA,SAASmC,GAASxC,EAAQyC,EAAOlV,EAAO0B,GAGpC,GADAwT,EAAMC,IAAMnV,EACR,CAACsE,EAAQ,CACT,GAAI4Q,EAAMzC,QAAU1R,EAAWmU,EAAMzC,MAAM,EAEvC,OAAOlG,EAAQ2I,EAAMzC,OAAOjB,KAAK9P,EAASwT,CAAK,EAAG,SAAU5N,GAExD,OADA4N,EAAMjO,IAAI,GACH,CAAC,CAACK,CACzB,CAAa,EAGDhD,EAAS,CAAC,CAAC4Q,EAAMzC,MAExB,CAED,OADAyC,EAAMjO,IAAI,GACH3C,CACX,CAyJO,SAAS8Q,GAAaC,EAAYC,EAAU5T,GAC/C,IAAI6T,EACApG,EAYIqG,EAMAC,EASAC,EA1BJtG,EAAS,SAAU1C,GAEnB,MADA+F,EAAS,CAAA,EACH/F,CACd,EACQ+F,EAAS,CAAA,EACTyC,EAAQ,CACRS,GAAIxL,EAAQ,EACZlD,KAAM,EACNwL,OAAQ6C,GAAY,CAAA,CAC5B,EACI,GAAID,EAyDA,OAxDIG,EAAmB,WACnB,OAAOT,EAAc,SAAUI,EAAKS,GAChCzG,EAAUgG,EACV/F,EAASwG,CACzB,CAAa,CACb,EACYH,EAAqB,SAAUnO,IAC/BmL,EAAS,CAAC,CAACnL,GAKP6H,EAAQ+F,EAAMC,GAAG,EAHjBO,GAKhB,GACYA,EAAiB,WAEjB,KAAO,CAACjD,GACJ,IACI,IAAIoD,EAAWR,EAAW7D,KAAK9P,EAASwT,CAAK,EAC7C,GAAIrU,EAAcgV,CAAQ,EAWtB,OAVAN,EAAUA,GAAWC,IACrBjJ,EAAQsJ,EAAU,SAAUV,GACxB,IACI5I,EAAQ0I,GAASxC,EAAQyC,EAAOC,EAAKzT,CAAO,EAAG+T,EAAoBrG,CAAM,CAI5E,CAFD,MAAO5O,GACH4O,EAAO5O,CAAC,CACX,CACJ,EAAE4O,CAAM,EAEFmG,EAGP,IAAIO,EAAQb,GAASxC,EAAQyC,EAAOW,EAAUnU,CAAO,EACrD,GAAIb,EAAciV,CAAK,EAInB,OAHAP,EAAUA,GAAWC,IACrBjJ,EAAQuJ,EAAOL,EAAoBrG,CAAM,EAElCmG,EAGP9C,EAAS,CAAC,CAACqD,CAOtB,CAHD,MAAOtV,GAEH,OADA4O,EAAO5O,CAAC,EACD+U,CACV,CAKL,OAHI9C,GAAUtD,GACVA,EAAQ+F,EAAMC,GAAG,EAEdI,GAAWL,EAAMC,GACpC,GAC6B,CAE7B,CChOA,SAASY,MAGT,SAASC,GAAa3N,EAAM8E,EAAK5J,GAE5B0S,GAAc5N,KAAU4N,GAAc5N,GAAQc,GAAkBd,CAAI,GACrE,IAAIgC,EAAMF,IACV,OAAO,IAAK8L,GAAc5N,GAAO,SAAS6N,OAAO/I,EAAIgJ,GAAI,IAAI,EAAED,OAAO3S,GAAW,GAAI,IAAI,EAAE2S,OAAQ/I,EAAIwI,GAAK,UAAY,UAAY,IAAI,EAAEO,QAAiB7L,GAAK8C,EAAIwI,IAAMxI,EAAIiJ,KAWrJ,KAAO,KAXiJ,CAAC,CACtL,CAiBA,SAASC,GAAiBC,EAAWC,GACjC,IACIC,EADMrM,IACUoM,EACpB3O,GAAW0O,EAAW,SAAUnJ,IACxBA,GAAO,CAACA,EAAIsJ,IAAOtJ,EAAIwI,IAAMxI,EAAIwI,GAAKa,GAAa,CAACrJ,EAAIwI,IAAMxI,EAAIiJ,IAAMjJ,EAAIiJ,GAAKI,IACjFrJ,GAAOA,EAAIuJ,GAAQvJ,EAAIsJ,IAAMT,GAAa,UAAW7I,EAAK,QAAQ,CAAC,CAE/E,CAAK,CACL,CAQA,SAASwJ,GAAYC,EAAOC,GACpB7O,EAAM8O,GAAWF,EAAOC,CAAU,EAC1B,CAAC,IAAT7O,GACA4O,EAAMG,OAAO/O,EAAK,CAAC,CAE3B,OZ5DItE,EACA/B,EACAsB,GAEArB,GACA2G,EACAvE,GACApD,EACAmJ,GACA9D,GACAW,GACAmB,GACAmB,GACA7H,EACA8B,GACAuF,EACAvH,GAKA6V,GACA9O,EAuEAnH,EAQA8K,GAEAmH,GA0BA1R,GAOAO,GAkBAM,GA2BAD,EACA0P,GAmDAtO,EAEAF,GAsEAgB,GAEA0F,GA8CA/E,GA0FA0B,GAyCAxB,EApJAsB,GAgBAvB,GAwLAW,GADAE,GA0DAG,GAyDAkB,GAhFA4J,GAKAhL,GAWAsK,GAsJA0G,GA+IAhO,GAfAmB,GAibAgN,EAqWA3L,GACAN,GACAK,GACAG,GA2FAsI,GACAa,GAKAC,GACAE,GIjuDAnD,GACAF,GACAC,GSHOjB,EACAyG,GAIAvK,GTGA2E,GFNPP,GYGOvB,GZJPyB,GCaAzD,GACAgD,GGbA0C,GACAE,GACAE,GHKA/C,GACAG,GACA/B,EACAF,GACAuB,GIGAwD,EAMA2D,GAMAC,GAMAC,GAMAC,GDFOC,GAYAC,GAWAC,GE3DPC,GACAC,GACAC,GDgJOC,GAYAC,GE7JPhE,GACAiE,GACAC,GACAC,GD+BOC,GAWAC,GASAC,GClCAC,GCpBPrD,GACAsD,GACAC,GACAC,GD2DOC,GAaAC,GAYAC,GMtFPC,GACAC,GLgDOC,GAYAC,GAWAC,GEnEPC,GACAC,GAJAxC,EACAyC,GACAC,GAOAnD,GIbAoD,sEhBKA3V,EAAckL,KAAAA,EACdjN,EAAa,KACbsB,GAAQ,GAERrB,GAAS,SAEToC,GAAY,YACZpD,EAAY,YACZmJ,GAAc,cACd9D,GAAS,SACTW,GAAe,YACfmB,GAAS,SACTmB,GAAO,OACP7H,EAAO,OACP8B,GAAY,WAEZhC,GAA0BpB,EAD1B2I,EAA0B9I,EAAY0Z,MAAO,EAV7C/Q,EAAY,WAW2C,EAMvDL,EAA0BnI,EAD1BiX,GAA0BjX,EAD1BwZ,GAAwB3Z,EAAYmJ,KAAM,EACCR,CAAU,EACR,OAAQ,EAuErDxH,EAA4BN,EA1FjB,UA0FoC,EAQ/CoL,GAA0B9L,EAASwZ,GAAQ,SAAU,EAErDvG,GAA0BvS,EAAU,QAAS,EA0B7Ca,GAA+CvB,EAAS2I,EAAU,0BAA2B,EAO7F7G,GAA2BjC,EAA6BG,EAAS2I,EAAU,QAAS,EAAG1H,CAAc,EAkBrGmB,GAAU,CACV3B,EAAG,aACHwJ,EAAG,eACH3J,EAAG,QACHmZ,EAAG,WACH5I,EAAG,MACH6I,EAAG,KACP,EAoBIvX,EAA+BnC,EAAS2I,EAAU,gBAAiB,EACnEkJ,GAAqC7R,EAAS2I,EAAU,kBAAmB,EAmD3EpF,EAA4B1D,EAxNJA,EAAY8Z,MAAO,CAwNI,EAE/CtW,GAAa,iBAsEbgB,GAA4BxE,EApBEG,EAAS2I,EAAU,QAAS,EAoBN5E,CAAW,EAE/DgG,GAAoClK,EAA4BG,EAAS2I,EAAU,gBAAiB,EAAG3E,CAAU,EA6BjHwC,GAAoCtC,EAAiB,CACrD0V,cAAe,EACfC,YAAa,EACbC,mBAAoB,EACpBC,SAAU,EACVC,MAAO,EACPC,SAAU,EACVrW,QAAS,EACTsW,OAAQ,EACRC,QAAS,EACTC,MAAO,EACPC,YAAa,GACbC,YAAa,GACbC,YAAa,EACjB,CAAC,EAEGtV,GAAoB,mBA0NpB8L,GAA6B1L,EAAiBQ,EAAS,CAAC,WAAY,EAKpEE,GAA2BV,EAAiBQ,EAAS,CAxCrDC,GAAS,SAwCqD,EAW9DuK,GAAwBhL,EAAiB,WACzC,MAAO,CAAC,CAAgBlF,EAAK,WAAc,OAAQmQ,UAAYA,QAAQkK,UAAY,IAAIC,KAAQ,EAAG,CACtG,CAAE,EAoJE1D,GAlWJ,SAAiC2D,GAC7B,IAAIC,EAiWmD1D,IAAAA,GAjWtByD,GACjC,OAAO,SAAU/Y,GACb,IAEQ4D,EAFJqV,EAAWjZ,GAAWA,EAAQ+Y,IAAcC,EAChD,GAAIC,EAEA,OADIrV,EAAU6C,WACNwS,WAAqBra,MAAMoB,EAASiZ,EAAUzS,EAAS7G,GAAMiE,EAAS,CAAC,EAAIA,CAAO,EAE9F1B,EAAe,IAAON,EAASmX,CAAQ,EAAI,qBAAwB5X,EAAQnB,CAAO,CAAC,CAC3F,CACA,EAwVgD,SAAoB,EAgIhEuI,GAA4BrK,EAA4BG,EAAS2I,EAAU,QAAS,EAAGN,EAAc,EAibrG6O,EAA2BtS,EAAYoD,EAAO,EAqW9CuD,GAAM,MACNN,GAAQ,QACRK,GAAU,SACVG,GAAU,UA2FVsI,GAAsB,IACtBa,GAAoB,GAKpBC,GAAiCxP,EAAiBQ,EAAS,CAAC,sBAAuB,EACnFkP,GAAuC1P,EAAiBQ,EAAS,CAAC,qBAAsB,EaluDjF6K,EAAc,UACdyG,GAAO,OTOP5F,GAAuB,ESHvB3E,GAAW,YCAX6C,GAA8B,CACrC,UAAW,YAAa,WAAY7C,IZLpCsE,GAAiB,gBCSjBP,IADAH,GAA2B,sBACoBqK,cAC/CjM,EAAoB,GAEpBqB,GAA6B,GGyBtBuH,GAAsCzF,GAAkBe,CAAkB,EAY1E2E,GAA2CrF,GAAuBU,CAAkB,EAWpF4E,GAA2CrF,GAAuBS,CAAkB,ECuFpFgF,GAA4C1F,GAAuBsB,CAAmB,EAYtFqE,GAA4C1F,GAAuBqB,CAAmB,EC3HtFyE,GAAqCpG,GAAkB6B,CAAiB,EAWxEwE,GAA0ChG,GAAuBwB,CAAiB,EASlFyE,GAA0ChG,GAAuBuB,CAAiB,EClClF0E,GAAuC,GA0CvCI,GAAqC3G,GAAkBiC,CAAiB,EAaxE2E,GAA0CvG,GAAuB4B,CAAiB,EAYlF4E,GAA0CvG,GAAuB2B,CAAiB,ECrClF+E,GAAiChH,GAAkBiD,CAAa,EAYhEgE,GAAsC5G,GAAuB4C,CAAa,EAW1EiE,GAAsC5G,GAAuB2C,CAAa,EEtEjF2B,EAAS,SACTyC,GAAiB,WACjBC,GTIA3K,GAAmB,ESGnBwH,GAAgB,GIbhBoD,GAAoBlT,EAAe,kBASC,WAQpC,SAAS0U,EAAgB/M,GACrBvN,KAAKua,GAAKjI,EAAmB/E,CAAQ,EACjCuL,KACA9Y,KAAK8Y,IAAqB,WAG9BnX,EAAc3B,KAAM,QAAS,CACzB8B,IAAK,WACD,OAAO9B,KAAKua,GAAG5F,KAClB,CACb,CAAS,CACJ,CAGD2F,EAAgBE,IAAMxD,GACtBsD,EAAgBG,KAAO7H,GACvB0H,EAAgBI,IAAM5H,GACtBwH,EAAgBzL,OAASqI,GACzBoD,EAAgB1L,QAAUqI,GAC1BqD,EAAgBK,WAAajI,GAC7B,IAAIkI,EAAWN,EAAgBO,UAU/B,OATAD,EAASra,KAAO,SAAUkO,EAAYC,GAClC,OAAO1O,KAAKua,GAAGha,KAAKkO,EAAYC,CAAU,CAClD,EACIkM,EAASjK,MAAQ,SAAUjC,GACvB,OAAO1O,KAAKua,GAAG5J,MAAMjC,CAAU,CACvC,EACIkM,EAASnO,QAAU,SAAUqO,GACzB,OAAO9a,KAAKua,GAAG9N,QAAQqO,CAAS,CACxC,EACWR,CACX,EAAG,oBCaI,SAAyBhT,EAAUwN,EAAY3T,GAClD,GAAImG,EAAU,CACV,IAAIyT,EAAQrE,EAAUpP,CAAQ,EAC9B,GAAIyT,EAMA,OAAOlG,GAAa,SAAUF,GACtBlN,EAAMkN,EAAMjO,KAChB,GAAIe,KAAOH,EACP,OAAOwN,EAAW7D,KAAK9P,GAAWmG,EAAUA,EAASG,GAAMA,EAAKH,CAAQ,CAE/E,EAVY,SAAUqN,GACnB,GAAIA,EAAMjO,MAAQqU,GAAuB,CAAC,IAAfpG,EAAMC,IAC7B,MAAO,CAAA,CAE3B,CAMqB,CAEhB,CACL,kDPmCO,SAAiCpD,EAAOe,GAE3C,OADCwF,GAAAA,IAA4ChG,GAAyByC,CAAa,GACzD1U,EAAE0R,EAAOe,CAAO,CAC9C,qBA4CO,SAA0B5O,EAAQ4O,GAErC,OADC0F,GAAAA,IAA8B9F,GAAkBqC,CAAa,GAC3C1U,EAAE6D,EAAQ4O,CAAO,CACxC,qQDtCO,SAAqCf,EAAOe,GAE/C,OADCiF,GAAAA,IAAoDzF,GAAyByB,CAAiB,GACjE1T,EAAE0R,EAAOe,CAAO,CAClD,yBA4CO,SAA8B5O,EAAQ4O,GAEzC,OADCmF,GAAAA,IAAsCvF,GAAkBqB,CAAiB,GACnD1T,EAAE6D,EAAQ4O,CAAO,CAC5C,gDA5BO,SAA+B5O,EAAQ4O,GAE1C,OADCkF,GAAAA,IAAwCxF,GAAmBuB,CAAiB,GACrD1T,EAAE6D,EAAQ4O,CAAO,CAC7C,yFFpBO,SAAgCf,EAAOe,GAE1C,OADCqE,GAAAA,IAA8B5D,GAA2B,MAAO,WAAc,OAAOrO,EAAkB4M,GAAkB2B,CAAmB,CAAC,CAAE,CAAE,GAC/HpT,EAAE0R,EAAOe,CAAO,CACvC,kCA8DO,SAAuCf,EAAOe,GAEjD,OADCsE,GAAAA,IAAwD7D,GAA2B,aAAc,WAAc,OAAOjB,GAAyBmB,CAAmB,CAAI,CAAA,GACvIpT,EAAE0R,EAAOe,CAAO,CACpD,2BA8CO,SAAgC5O,EAAQ4O,GAE3C,OADCwE,GAAAA,IAA0C/D,GAA2B,MAAO,WAAc,OAAOb,GAAkBe,CAAmB,CAAI,CAAA,GAClHpT,EAAE6D,EAAQ4O,CAAO,CAC9C,oDA7BO,SAAiC5O,EAAQ4O,GAE5C,OADCuE,GAAAA,IAA4C9D,GAA2B,OAAQ,WAAc,OAAOf,GAAmBiB,CAAmB,CAAI,CAAA,GACrHpT,EAAE6D,EAAQ4O,CAAO,CAC/C,0GGtFO,SAA2B5O,EAAQ4O,GAEtC,OADCyF,GAAAA,IAAgC/F,GAAmBuC,CAAa,GAC7C1U,EAAE6D,EAAQ4O,CAAO,CACzC,gHF9CO,SAAqCf,EAAOe,GAE/C,OADC4E,GAAAA,IAAoDpF,GAAyBqB,CAAiB,GACjEtT,EAAE0R,EAAOe,CAAO,CAClD,yBA4CO,SAA8B5O,EAAQ4O,GAEzC,OADC8E,GAAAA,IAAsClF,GAAkBiB,CAAiB,GACnDtT,EAAE6D,EAAQ4O,CAAO,CAC5C,gDA5BO,SAA+B5O,EAAQ4O,GAE1C,OADC6E,GAAAA,IAAwCnF,GAAmBmB,CAAiB,GACrDtT,EAAE6D,EAAQ4O,CAAO,CAC7C,sFI2BO,SAA6BlF,EAAY3N,GAWnB,SAArBsb,IACA,IAAIC,EAAyD,EAA7CvE,EAAUwE,CAAQ,EAAIxE,EAAUyE,CAAQ,EAC9B,EAAtBC,IACKC,IAEDA,EAAgBlQ,EAAgB,WAC5B2K,GAAiBoF,EAAUE,CAAmB,EAC9CtF,GAAiBqF,EAAUC,CAAmB,EAC9CC,IAAkBA,EAAcC,QAAyD,EAA7C5E,EAAUwE,CAAQ,EAAIxE,EAAUyE,CAAQ,EACvF,EAAEI,CAAwB,GACbC,MAAK,EAEvBH,KAAkBA,EAAcC,QAAUL,EAOtD,CA+BmB,SAAXQ,EAAqBnF,EAAYoF,GAOjC,OANApF,EAAWlB,GAAKxL,IAGhBsR,EAASvM,KAAK2H,CAAU,EACxB0E,IAEO,SAAUW,EAAeC,GACP,SAAjBC,EAA2B1P,GAC3BmK,EAAWJ,GAAKI,EAAWJ,IAAM/J,GAAUsJ,GAAamD,GAAgBtC,CAAU,EAClFA,EAAWH,GAAUX,GACrBsG,EAAWxF,CAAU,EACrBqF,EAAgB,KAChBC,GAAgBA,EAAazP,CAAM,EACnCyP,EAAe,IAC/B,CAPY,IAQIG,EAASzF,EAAWV,GACxB,GAAIU,EAAWJ,GAEX2F,EAAevF,EAAWJ,EAAE,MAE3B,CAIDI,EAAWH,GAAU0F,EACrB,IACI,IAAIG,EAAcN,EAAYK,CAAM,EAChCzF,EAAW2F,IAAM3b,EAAc0b,CAAW,IAC1C1F,EAAW4F,EAAI/Q,EAAgB,WAC3B0Q,EAAepG,GAAa,UAAWa,CAAU,CAAC,CAC9E,EAA2BA,EAAW2F,EAAE,GAEpBjQ,EAAQgQ,EAAa,SAAUG,GAC3BL,EAAWxF,CAAU,EACrB,IACIqF,GAAiBA,EAAcQ,CAAS,CAI3C,CAFD,MAAOlc,GACH2b,GAAgBA,EAAa3b,CAAC,CACjC,CAED0b,EADAC,EAAe,IAElB,EAAEC,CAAc,CAIpB,CAFD,MAAO5b,GACH4b,EAAe5b,CAAC,CACnB,CACJ,CACb,CACA,CAmBqB,SAAb6b,EAAuBxF,GACvBF,GAAY8E,EAAU5E,CAAU,EAEhCA,EAAW4F,GAAK5F,EAAW4F,EAAEtR,OAAM,EACnC0L,EAAW4F,EAAI,KAEXE,GAAYA,IAAa9F,IACzB8F,EAAW,KACP1F,EAAUwE,CAAQ,EAAIxE,EAAUyE,CAAQ,IAAM,KAC9CE,GAAiBA,EAAczQ,SAC/ByQ,EAAgB,KAGhC,CA9II,IAAIe,EAOAf,EA/EgBgB,EAAsBC,EAyEtCpB,EAAW,GACXC,EAAW,GACXC,EAAsB,IACtBG,EAA2BH,EAAsB,GACjDmB,EAAa,EACbC,GAAkB9c,EAAQA,EAAO,IAAO,IAAMmZ,EAAY,GAyI1DwD,GAtIJhP,EAAaA,GAAcmH,EAsIR,CACfiI,KAAM,CAAA,EACNpG,MAnHa,SAAUqF,EAAagB,EAAUnK,GAC9C,IAgFiC+D,EAAYqG,EAAUjB,EA/EnDK,EAASS,EAAiB,IAAMD,CAAU,GAI1CK,GAHAF,IACAX,GAAU,KAAOW,EAAW,MAEjBpU,EAAK,CACZsN,GAAImG,EACJlG,GAAIjM,EAAQ,EACZqS,GAAI1J,CACP,GACE4D,GAAU,SAAUhK,GACnByQ,EAAQ1G,GAAK/J,GAAUsJ,GAAamD,GAAgBgE,CAAO,EAC3DA,EAAQzG,GAAUX,EACrB,EACDlN,GAaJ,OAJIsU,EAAQC,EARPT,GAiEwCO,EAzDCP,EAyDSV,EAzDCA,EA0DxDP,EAASxM,KADwB2H,EAzDIsG,CA0Db,EACxB5B,IACO3N,EAAW,SAAUyP,EAAeC,GASvCjR,GAAgB6Q,EAASE,EAAG,WACxBzG,GAAY+E,EAAU7E,CAAU,EAChCmF,EAASnF,EAAYoF,CAAW,EAAEoB,EAAeC,CAAY,CAC7E,CAAa,CACb,CAAS,GA/Ee1P,EAAWoO,EAASmB,EAASlB,CAAW,CAAC,GASzDU,EAAWQ,GACIC,CACvB,EAuFQG,gBAAiB,SAAUC,EAAcC,GACrC7B,GAAiBA,EAAczQ,SAC/ByQ,EAAgB,KAChBD,EAAsB6B,EACtB1B,EAA2B2B,GAAoBD,EAAe,GAC9DjC,GACH,CACT,GAcI,OAZAzZ,EAAU8a,EAAc,OAAQ,CAC5BhM,EAAG,WACC,OAAOqG,EAAUwE,CAAQ,EAAIxE,EAAUyE,CAAQ,IAAM,CACxD,CACT,CAAK,EAvOyCmB,EAwO2B,WACjE,MAAO,CACHza,EAAGua,EACHe,EAAGjC,EACHjC,EAAGkC,CACf,CACA,EA5OIxC,GAAiBA,IAAkB,CAAEvS,SAAU,WAAc,MAAO,oBAAqB,GACzFzE,EAHoB0a,EAwOLA,EAvOf3D,GAAaA,IAAc,CAAEtS,SAAU,WAAc,MAAO,mBAAoB,GAExC,CAAEtE,IAqOb,WAAc,OAAO0a,CAAiB,CArOZ,CAAA,EACvD7a,EAAc0a,EAAc1D,GAAgB,CAAE7W,IAAKwa,CAAS,CAAA,EA2OrDD,CACX,yBMlQO,SAA8B9J,EAAS6K,EAAepa,GACzD,OAAOwR,EAAc,SAAU5F,EAASC,GACpC1D,EAAgB,YACXiS,EAAgBxO,EAAUC,GAASzO,EAAY4C,CAAO,EAAc,cAAgBuP,EAAU,cAApCvP,CAAiD,CAC/G,EAAEuP,CAAO,CAClB,CAAK,CACL,qFHIO,SAAwB7L,EAAMoO,EAAY3T,GAC7C,IAAIyF,EACAC,EACAwW,EAAU3W,EACd,SAAS4W,EAAStW,GAMd,MALAJ,EAAM,CAAE3G,EAAG+G,GACPqW,EAAQpW,QACRJ,EAAa,KACbwW,EAAQpW,MAAML,CAAG,GAEfI,CACT,CACD,SAAS4J,IACL,IACQ/J,GAAc,CAACA,EAAW8P,KAC1B0G,EAAc,QAAKA,EAAc,OAAExW,CAAU,CAQpD,CALO,QACJ,GAAID,EAEA,MAAMA,EAAI3G,CAEjB,CACJ,CACD,GAAIyG,IACKJ,EAAWI,CAAI,IAEf4R,GAAAA,IAAwC3T,EAAkBiB,EAAe,CAAuC,CAAA,EACjHyX,EAAU3W,EAAK4R,GAAiBxY,GAAK4G,EAAK4R,GAAiBxY,GAAI,EAAG,QAG7DuY,GAAAA,IAA8B1T,EAAkBiB,EAAe,CAAkC,CAAA,EAClGyX,EAAU3W,EAAK2R,GAAYvY,GAAK4G,EAAK2R,GAAYvY,GAAI,EAAG,MAG5Dud,IAAW/W,EAAW+W,CAAO,EAAG,CAC5BtZ,EAAS,KAAA,EACb,IAoBI,OAFIA,EADAzD,EAhBJyD,EAAS8Q,GAAa,SAAUF,GAC5B,OAAO3I,EAAQqR,EAAQ9W,KAAM,EAAE,SAAUqO,GAErC,GAAI,EADJ/N,EAAa+N,GACJ+B,IACL,OfilB5B,SAAgBvP,EAAIjG,GAChB,OAAOiG,EAAGrH,MAAMoB,EAASwG,EAAS7G,GAAM8G,UAAW,CAAC,CAAC,CACzD,EenlB0CkN,EAAY3T,GAAWkc,EAASxW,EAAgB,MAAG8N,EAAMjO,KAAM2W,CAAO,CAE3F,EAAE,SAAUlR,GACTwI,EAAMzC,OAAS,CAAA,EACfoL,EAASnR,CAAM,CACvC,CAAqB,CACJ,EAAE,SAAUwI,GACT,GAAI,CAAC9N,GAAcA,EAAW8P,KAAuB,CAAC,IAAfhC,EAAMC,IAEzC,OADAhE,IACO,CAAA,CAE/B,EAAmBzP,GAAWkc,CAAO,CACG,EACX7Q,GAAUzI,EAAO4M,MAAM2M,CAAQ,EAAG1M,CAAS,EAEjD7M,CASV,CAPD,MAAOiD,GACHsW,EAAStW,CAAM,CAClB,CACO,QACAjD,GAAU,CAACzD,EAAcyD,CAAM,GAC/B6M,GAEP,CACJ,CAET,yBLxHO,SAA8B2M,GACjC9I,GAAkB8I,EAAU5Y,EAAkB4Y,CAAO,EAAI,IAC7D,sFN8DO,SAA8BjC,EAASkC,GAC1CzM,GAAuBuK,CAI3B","x_google_ignoreList":[0]}